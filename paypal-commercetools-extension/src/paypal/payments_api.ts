/* tslint:disable */
/* eslint-disable */
/**
 * Payments
 * Call the Payments API to authorize payments, capture authorized payments, refund payments that have already been captured, and show payment information. Use the Payments API in conjunction with the <a href=\"/docs/api/orders/v2/\">Orders API</a>. For more information, see the <a href=\"/docs/checkout/\">PayPal Checkout Overview</a>.
 *
 * The version of the OpenAPI document: 2.4
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { AxiosInstance, AxiosPromise, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import type { Configuration } from './configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import type { RequestArgs } from './base';
import {
  assertParamExists,
  createRequestFunction,
  DUMMY_BASE_URL,
  serializeDataIfNeeded,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
// @ts-ignore
import { BaseAPI, BASE_PATH } from './base';

/**
 *
 * @export
 * @interface AUTHCAPTURECURRENCYMISMATCH
 */
export interface AUTHCAPTURECURRENCYMISMATCH {
  /**
   *
   * @type {string}
   * @memberof AUTHCAPTURECURRENCYMISMATCH
   */
  issue?: AUTHCAPTURECURRENCYMISMATCHIssueEnum;
  /**
   *
   * @type {string}
   * @memberof AUTHCAPTURECURRENCYMISMATCH
   */
  description?: AUTHCAPTURECURRENCYMISMATCHDescriptionEnum;
}

export const AUTHCAPTURECURRENCYMISMATCHIssueEnum = {
  AuthCaptureCurrencyMismatch: 'AUTH_CAPTURE_CURRENCY_MISMATCH',
} as const;

export type AUTHCAPTURECURRENCYMISMATCHIssueEnum =
  (typeof AUTHCAPTURECURRENCYMISMATCHIssueEnum)[keyof typeof AUTHCAPTURECURRENCYMISMATCHIssueEnum];
export const AUTHCAPTURECURRENCYMISMATCHDescriptionEnum = {
  CurrencyOfCaptureMustBeTheSameAsCurrencyOfAuthorization:
    'Currency of capture must be the same as currency of authorization.',
} as const;

export type AUTHCAPTURECURRENCYMISMATCHDescriptionEnum =
  (typeof AUTHCAPTURECURRENCYMISMATCHDescriptionEnum)[keyof typeof AUTHCAPTURECURRENCYMISMATCHDescriptionEnum];

/**
 *
 * @export
 * @interface AUTHCURRENCYMISMATCH
 */
export interface AUTHCURRENCYMISMATCH {
  /**
   *
   * @type {string}
   * @memberof AUTHCURRENCYMISMATCH
   */
  issue?: AUTHCURRENCYMISMATCHIssueEnum;
  /**
   *
   * @type {string}
   * @memberof AUTHCURRENCYMISMATCH
   */
  description?: AUTHCURRENCYMISMATCHDescriptionEnum;
}

export const AUTHCURRENCYMISMATCHIssueEnum = {
  AuthCurrencyMismatch: 'AUTH_CURRENCY_MISMATCH',
} as const;

export type AUTHCURRENCYMISMATCHIssueEnum =
  (typeof AUTHCURRENCYMISMATCHIssueEnum)[keyof typeof AUTHCURRENCYMISMATCHIssueEnum];
export const AUTHCURRENCYMISMATCHDescriptionEnum = {
  TheCurrencySpecifiedDuringReauthorizationShouldBeTheSameAsTheCurrencySpecifiedInTheOriginalAuthorizationPleaseCheckTheCurrencyOfTheAuthorizationForWhichYouAreTryingToReauthorizeAndTryAgain:
    'The currency specified during reauthorization should be the same as the currency specified in the original authorization. Please check the currency of the authorization for which you are trying to reauthorize and try again.',
} as const;

export type AUTHCURRENCYMISMATCHDescriptionEnum =
  (typeof AUTHCURRENCYMISMATCHDescriptionEnum)[keyof typeof AUTHCURRENCYMISMATCHDescriptionEnum];

/**
 *
 * @export
 * @interface AUTHORIZATIONALREADYCAPTURED
 */
export interface AUTHORIZATIONALREADYCAPTURED {
  /**
   *
   * @type {string}
   * @memberof AUTHORIZATIONALREADYCAPTURED
   */
  issue?: AUTHORIZATIONALREADYCAPTUREDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof AUTHORIZATIONALREADYCAPTURED
   */
  description?: AUTHORIZATIONALREADYCAPTUREDDescriptionEnum;
}

export const AUTHORIZATIONALREADYCAPTUREDIssueEnum = {
  AuthorizationAlreadyCaptured: 'AUTHORIZATION_ALREADY_CAPTURED',
} as const;

export type AUTHORIZATIONALREADYCAPTUREDIssueEnum =
  (typeof AUTHORIZATIONALREADYCAPTUREDIssueEnum)[keyof typeof AUTHORIZATIONALREADYCAPTUREDIssueEnum];
export const AUTHORIZATIONALREADYCAPTUREDDescriptionEnum = {
  AuthorizationHasPreviouslyBeenCaptured:
    'Authorization has previously been captured.',
} as const;

export type AUTHORIZATIONALREADYCAPTUREDDescriptionEnum =
  (typeof AUTHORIZATIONALREADYCAPTUREDDescriptionEnum)[keyof typeof AUTHORIZATIONALREADYCAPTUREDDescriptionEnum];

/**
 *
 * @export
 * @interface AUTHORIZATIONDENIED
 */
export interface AUTHORIZATIONDENIED {
  /**
   *
   * @type {string}
   * @memberof AUTHORIZATIONDENIED
   */
  issue?: AUTHORIZATIONDENIEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof AUTHORIZATIONDENIED
   */
  description?: AUTHORIZATIONDENIEDDescriptionEnum;
}

export const AUTHORIZATIONDENIEDIssueEnum = {
  AuthorizationDenied: 'AUTHORIZATION_DENIED',
} as const;

export type AUTHORIZATIONDENIEDIssueEnum =
  (typeof AUTHORIZATIONDENIEDIssueEnum)[keyof typeof AUTHORIZATIONDENIEDIssueEnum];
export const AUTHORIZATIONDENIEDDescriptionEnum = {
  AnDeniedAuthorizationCannotBeCaptured:
    'An denied authorization cannot be captured.',
} as const;

export type AUTHORIZATIONDENIEDDescriptionEnum =
  (typeof AUTHORIZATIONDENIEDDescriptionEnum)[keyof typeof AUTHORIZATIONDENIEDDescriptionEnum];

/**
 *
 * @export
 * @interface AUTHORIZATIONEXPIRED
 */
export interface AUTHORIZATIONEXPIRED {
  /**
   *
   * @type {string}
   * @memberof AUTHORIZATIONEXPIRED
   */
  issue?: AUTHORIZATIONEXPIREDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof AUTHORIZATIONEXPIRED
   */
  description?: AUTHORIZATIONEXPIREDDescriptionEnum;
}

export const AUTHORIZATIONEXPIREDIssueEnum = {
  AuthorizationExpired: 'AUTHORIZATION_EXPIRED',
} as const;

export type AUTHORIZATIONEXPIREDIssueEnum =
  (typeof AUTHORIZATIONEXPIREDIssueEnum)[keyof typeof AUTHORIZATIONEXPIREDIssueEnum];
export const AUTHORIZATIONEXPIREDDescriptionEnum = {
  AnExpiredAuthorizationCannotBeCaptured:
    'An expired authorization cannot be captured.',
} as const;

export type AUTHORIZATIONEXPIREDDescriptionEnum =
  (typeof AUTHORIZATIONEXPIREDDescriptionEnum)[keyof typeof AUTHORIZATIONEXPIREDDescriptionEnum];

/**
 *
 * @export
 * @interface AUTHORIZATIONVOIDED
 */
export interface AUTHORIZATIONVOIDED {
  /**
   *
   * @type {string}
   * @memberof AUTHORIZATIONVOIDED
   */
  issue?: AUTHORIZATIONVOIDEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof AUTHORIZATIONVOIDED
   */
  description?: AUTHORIZATIONVOIDEDDescriptionEnum;
}

export const AUTHORIZATIONVOIDEDIssueEnum = {
  AuthorizationVoided: 'AUTHORIZATION_VOIDED',
} as const;

export type AUTHORIZATIONVOIDEDIssueEnum =
  (typeof AUTHORIZATIONVOIDEDIssueEnum)[keyof typeof AUTHORIZATIONVOIDEDIssueEnum];
export const AUTHORIZATIONVOIDEDDescriptionEnum = {
  AVoidedAuthorizationCannotBeCapturedOrReauthorized:
    'A voided authorization cannot be captured or reauthorized. ',
} as const;

export type AUTHORIZATIONVOIDEDDescriptionEnum =
  (typeof AUTHORIZATIONVOIDEDDescriptionEnum)[keyof typeof AUTHORIZATIONVOIDEDDescriptionEnum];

/**
 * The date and time stamps that are common to authorized payment, captured payment, and refund transactions.
 * @export
 * @interface ActivityTimestamps
 */
export interface ActivityTimestamps {
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof ActivityTimestamps
   */
  create_time?: string;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof ActivityTimestamps
   */
  update_time?: string;
}
/**
 * The authorized payment transaction.
 * @export
 * @interface Authorization
 */
export interface Authorization {
  /**
   * The status for the authorized payment.
   * @type {string}
   * @memberof Authorization
   */
  status?: AuthorizationStatusEnum;
  /**
   *
   * @type {AuthorizationStatusDetails}
   * @memberof Authorization
   */
  status_details?: AuthorizationStatusDetails;
  /**
   * The PayPal-generated ID for the authorized payment.
   * @type {string}
   * @memberof Authorization
   */
  id?: string;
  /**
   *
   * @type {Money}
   * @memberof Authorization
   */
  amount?: Money;
  /**
   * The API caller-provided external invoice number for this order. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof Authorization
   */
  invoice_id?: string;
  /**
   * The API caller-provided external ID. Used to reconcile API caller-initiated transactions with PayPal transactions. Appears in transaction and settlement reports.
   * @type {string}
   * @memberof Authorization
   */
  custom_id?: string;
  /**
   *
   * @type {NetworkTransactionReference}
   * @memberof Authorization
   */
  network_transaction_reference?: NetworkTransactionReference;
  /**
   *
   * @type {SellerProtection}
   * @memberof Authorization
   */
  seller_protection?: SellerProtection;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof Authorization
   */
  expiration_time?: string;
  /**
   * An array of related [HATEOAS links](/docs/api/reference/api-responses/#hateoas-links).
   * @type {Array<LinkDescription>}
   * @memberof Authorization
   */
  links?: Array<LinkDescription>;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof Authorization
   */
  create_time?: string;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof Authorization
   */
  update_time?: string;
}

export const AuthorizationStatusEnum = {
  Created: 'CREATED',
  Captured: 'CAPTURED',
  Denied: 'DENIED',
  PartiallyCaptured: 'PARTIALLY_CAPTURED',
  Voided: 'VOIDED',
  Pending: 'PENDING',
} as const;

export type AuthorizationStatusEnum =
  (typeof AuthorizationStatusEnum)[keyof typeof AuthorizationStatusEnum];

/**
 * The authorized payment transaction.
 * @export
 * @interface Authorization2
 */
export interface Authorization2 {
  /**
   * The status for the authorized payment.
   * @type {string}
   * @memberof Authorization2
   */
  status?: Authorization2StatusEnum;
  /**
   *
   * @type {AuthorizationStatusDetails}
   * @memberof Authorization2
   */
  status_details?: AuthorizationStatusDetails;
  /**
   * The PayPal-generated ID for the authorized payment.
   * @type {string}
   * @memberof Authorization2
   */
  id?: string;
  /**
   *
   * @type {Money}
   * @memberof Authorization2
   */
  amount?: Money;
  /**
   * The API caller-provided external invoice number for this order. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof Authorization2
   */
  invoice_id?: string;
  /**
   * The API caller-provided external ID. Used to reconcile API caller-initiated transactions with PayPal transactions. Appears in transaction and settlement reports.
   * @type {string}
   * @memberof Authorization2
   */
  custom_id?: string;
  /**
   *
   * @type {NetworkTransactionReference}
   * @memberof Authorization2
   */
  network_transaction_reference?: NetworkTransactionReference;
  /**
   *
   * @type {SellerProtection}
   * @memberof Authorization2
   */
  seller_protection?: SellerProtection;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof Authorization2
   */
  expiration_time?: string;
  /**
   * An array of related [HATEOAS links](/docs/api/reference/api-responses/#hateoas-links).
   * @type {Array<LinkDescription>}
   * @memberof Authorization2
   */
  links?: Array<LinkDescription>;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof Authorization2
   */
  create_time?: string;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof Authorization2
   */
  update_time?: string;
  /**
   *
   * @type {SupplementaryData}
   * @memberof Authorization2
   */
  supplementary_data?: SupplementaryData;
  /**
   *
   * @type {PayeeBase}
   * @memberof Authorization2
   */
  payee?: PayeeBase;
}

export const Authorization2StatusEnum = {
  Created: 'CREATED',
  Captured: 'CAPTURED',
  Denied: 'DENIED',
  PartiallyCaptured: 'PARTIALLY_CAPTURED',
  Voided: 'VOIDED',
  Pending: 'PENDING',
} as const;

export type Authorization2StatusEnum =
  (typeof Authorization2StatusEnum)[keyof typeof Authorization2StatusEnum];

/**
 *
 * @export
 * @interface Authorization2AllOf
 */
export interface Authorization2AllOf {
  /**
   *
   * @type {SupplementaryData}
   * @memberof Authorization2AllOf
   */
  supplementary_data?: SupplementaryData;
  /**
   *
   * @type {PayeeBase}
   * @memberof Authorization2AllOf
   */
  payee?: PayeeBase;
}
/**
 *
 * @export
 * @interface AuthorizationAllOf
 */
export interface AuthorizationAllOf {
  /**
   * The PayPal-generated ID for the authorized payment.
   * @type {string}
   * @memberof AuthorizationAllOf
   */
  id?: string;
  /**
   *
   * @type {Money}
   * @memberof AuthorizationAllOf
   */
  amount?: Money;
  /**
   * The API caller-provided external invoice number for this order. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof AuthorizationAllOf
   */
  invoice_id?: string;
  /**
   * The API caller-provided external ID. Used to reconcile API caller-initiated transactions with PayPal transactions. Appears in transaction and settlement reports.
   * @type {string}
   * @memberof AuthorizationAllOf
   */
  custom_id?: string;
  /**
   *
   * @type {NetworkTransactionReference}
   * @memberof AuthorizationAllOf
   */
  network_transaction_reference?: NetworkTransactionReference;
  /**
   *
   * @type {SellerProtection}
   * @memberof AuthorizationAllOf
   */
  seller_protection?: SellerProtection;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof AuthorizationAllOf
   */
  expiration_time?: string;
  /**
   * An array of related [HATEOAS links](/docs/api/reference/api-responses/#hateoas-links).
   * @type {Array<LinkDescription>}
   * @memberof AuthorizationAllOf
   */
  links?: Array<LinkDescription>;
}
/**
 * The status fields for an authorized payment.
 * @export
 * @interface AuthorizationStatus
 */
export interface AuthorizationStatus {
  /**
   * The status for the authorized payment.
   * @type {string}
   * @memberof AuthorizationStatus
   */
  status?: AuthorizationStatusStatusEnum;
  /**
   *
   * @type {AuthorizationStatusDetails}
   * @memberof AuthorizationStatus
   */
  status_details?: AuthorizationStatusDetails;
}

export const AuthorizationStatusStatusEnum = {
  Created: 'CREATED',
  Captured: 'CAPTURED',
  Denied: 'DENIED',
  PartiallyCaptured: 'PARTIALLY_CAPTURED',
  Voided: 'VOIDED',
  Pending: 'PENDING',
} as const;

export type AuthorizationStatusStatusEnum =
  (typeof AuthorizationStatusStatusEnum)[keyof typeof AuthorizationStatusStatusEnum];

/**
 * The details of the authorized payment status.
 * @export
 * @interface AuthorizationStatusDetails
 */
export interface AuthorizationStatusDetails {
  /**
   * The reason why the authorized status is `PENDING`.
   * @type {string}
   * @memberof AuthorizationStatusDetails
   */
  reason?: AuthorizationStatusDetailsReasonEnum;
}

export const AuthorizationStatusDetailsReasonEnum = {
  PendingReview: 'PENDING_REVIEW',
} as const;

export type AuthorizationStatusDetailsReasonEnum =
  (typeof AuthorizationStatusDetailsReasonEnum)[keyof typeof AuthorizationStatusDetailsReasonEnum];

/**
 *
 * @export
 * @interface AuthorizationsCapture400Response
 */
export interface AuthorizationsCapture400Response {
  /**
   *
   * @type {string}
   * @memberof AuthorizationsCapture400Response
   */
  name?: AuthorizationsCapture400ResponseNameEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizationsCapture400Response
   */
  message?: AuthorizationsCapture400ResponseMessageEnum;
  /**
   *
   * @type {Array<Model400IssuesInner>}
   * @memberof AuthorizationsCapture400Response
   */
  issues?: Array<Model400IssuesInner>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof AuthorizationsCapture400Response
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof AuthorizationsCapture400Response
   */
  information_link?: string;
}

export const AuthorizationsCapture400ResponseNameEnum = {
  InvalidRequest: 'INVALID_REQUEST',
} as const;

export type AuthorizationsCapture400ResponseNameEnum =
  (typeof AuthorizationsCapture400ResponseNameEnum)[keyof typeof AuthorizationsCapture400ResponseNameEnum];
export const AuthorizationsCapture400ResponseMessageEnum = {
  RequestIsNotWellFormedSyntacticallyIncorrectOrViolatesSchema:
    'Request is not well-formed, syntactically incorrect, or violates schema.',
} as const;

export type AuthorizationsCapture400ResponseMessageEnum =
  (typeof AuthorizationsCapture400ResponseMessageEnum)[keyof typeof AuthorizationsCapture400ResponseMessageEnum];

/**
 *
 * @export
 * @interface AuthorizationsCapture422Response
 */
export interface AuthorizationsCapture422Response {
  /**
   *
   * @type {string}
   * @memberof AuthorizationsCapture422Response
   */
  name?: AuthorizationsCapture422ResponseNameEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizationsCapture422Response
   */
  message?: AuthorizationsCapture422ResponseMessageEnum;
  /**
   *
   * @type {Array<Model422IssuesInner>}
   * @memberof AuthorizationsCapture422Response
   */
  issues?: Array<Model422IssuesInner>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof AuthorizationsCapture422Response
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof AuthorizationsCapture422Response
   */
  information_link?: string;
}

export const AuthorizationsCapture422ResponseNameEnum = {
  UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
} as const;

export type AuthorizationsCapture422ResponseNameEnum =
  (typeof AuthorizationsCapture422ResponseNameEnum)[keyof typeof AuthorizationsCapture422ResponseNameEnum];
export const AuthorizationsCapture422ResponseMessageEnum = {
  TheRequestedActionCouldNotBePerformedSemanticallyIncorrectOrFailedBusinessValidation:
    'The requested action could not be performed, semantically incorrect, or failed business validation.',
} as const;

export type AuthorizationsCapture422ResponseMessageEnum =
  (typeof AuthorizationsCapture422ResponseMessageEnum)[keyof typeof AuthorizationsCapture422ResponseMessageEnum];

/**
 *
 * @export
 * @interface AuthorizationsGet403Response
 */
export interface AuthorizationsGet403Response {
  /**
   *
   * @type {string}
   * @memberof AuthorizationsGet403Response
   */
  name?: AuthorizationsGet403ResponseNameEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizationsGet403Response
   */
  message?: AuthorizationsGet403ResponseMessageEnum;
  /**
   *
   * @type {Array<Model403IssuesInner>}
   * @memberof AuthorizationsGet403Response
   */
  issues?: Array<Model403IssuesInner>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof AuthorizationsGet403Response
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof AuthorizationsGet403Response
   */
  information_link?: string;
}

export const AuthorizationsGet403ResponseNameEnum = {
  NotAuthorized: 'NOT_AUTHORIZED',
} as const;

export type AuthorizationsGet403ResponseNameEnum =
  (typeof AuthorizationsGet403ResponseNameEnum)[keyof typeof AuthorizationsGet403ResponseNameEnum];
export const AuthorizationsGet403ResponseMessageEnum = {
  AuthorizationFailedDueToInsufficientPermissions:
    'Authorization failed due to insufficient permissions.',
} as const;

export type AuthorizationsGet403ResponseMessageEnum =
  (typeof AuthorizationsGet403ResponseMessageEnum)[keyof typeof AuthorizationsGet403ResponseMessageEnum];

/**
 *
 * @export
 * @interface AuthorizationsGet404Response
 */
export interface AuthorizationsGet404Response {
  /**
   *
   * @type {string}
   * @memberof AuthorizationsGet404Response
   */
  name?: AuthorizationsGet404ResponseNameEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizationsGet404Response
   */
  message?: AuthorizationsGet404ResponseMessageEnum;
  /**
   *
   * @type {Array<Model404IssuesInner>}
   * @memberof AuthorizationsGet404Response
   */
  issues?: Array<Model404IssuesInner>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof AuthorizationsGet404Response
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof AuthorizationsGet404Response
   */
  information_link?: string;
}

export const AuthorizationsGet404ResponseNameEnum = {
  ResourceNotFound: 'RESOURCE_NOT_FOUND',
} as const;

export type AuthorizationsGet404ResponseNameEnum =
  (typeof AuthorizationsGet404ResponseNameEnum)[keyof typeof AuthorizationsGet404ResponseNameEnum];
export const AuthorizationsGet404ResponseMessageEnum = {
  TheSpecifiedResourceDoesNotExist: 'The specified resource does not exist.',
} as const;

export type AuthorizationsGet404ResponseMessageEnum =
  (typeof AuthorizationsGet404ResponseMessageEnum)[keyof typeof AuthorizationsGet404ResponseMessageEnum];

/**
 *
 * @export
 * @interface AuthorizationsReauthorize400
 */
export interface AuthorizationsReauthorize400 {
  /**
   *
   * @type {Array<AuthorizationsReauthorize400IssuesInner>}
   * @memberof AuthorizationsReauthorize400
   */
  issues?: Array<AuthorizationsReauthorize400IssuesInner>;
}
/**
 *
 * @export
 * @interface AuthorizationsReauthorize400IssuesInner
 */
export interface AuthorizationsReauthorize400IssuesInner {
  /**
   *
   * @type {string}
   * @memberof AuthorizationsReauthorize400IssuesInner
   */
  issue?: AuthorizationsReauthorize400IssuesInnerIssueEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizationsReauthorize400IssuesInner
   */
  description?: AuthorizationsReauthorize400IssuesInnerDescriptionEnum;
}

export const AuthorizationsReauthorize400IssuesInnerIssueEnum = {
  InvalidParameterSyntax: 'INVALID_PARAMETER_SYNTAX',
} as const;

export type AuthorizationsReauthorize400IssuesInnerIssueEnum =
  (typeof AuthorizationsReauthorize400IssuesInnerIssueEnum)[keyof typeof AuthorizationsReauthorize400IssuesInnerIssueEnum];
export const AuthorizationsReauthorize400IssuesInnerDescriptionEnum = {
  TheValueOfAFieldDoesNotConformToTheExpectedFormat:
    'The value of a field does not conform to the expected format.',
} as const;

export type AuthorizationsReauthorize400IssuesInnerDescriptionEnum =
  (typeof AuthorizationsReauthorize400IssuesInnerDescriptionEnum)[keyof typeof AuthorizationsReauthorize400IssuesInnerDescriptionEnum];

/**
 *
 * @export
 * @interface AuthorizationsReauthorize400Response
 */
export interface AuthorizationsReauthorize400Response {
  /**
   *
   * @type {string}
   * @memberof AuthorizationsReauthorize400Response
   */
  name?: AuthorizationsReauthorize400ResponseNameEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizationsReauthorize400Response
   */
  message?: AuthorizationsReauthorize400ResponseMessageEnum;
  /**
   *
   * @type {Array<AuthorizationsReauthorize400IssuesInner>}
   * @memberof AuthorizationsReauthorize400Response
   */
  issues?: Array<AuthorizationsReauthorize400IssuesInner>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof AuthorizationsReauthorize400Response
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof AuthorizationsReauthorize400Response
   */
  information_link?: string;
}

export const AuthorizationsReauthorize400ResponseNameEnum = {
  InvalidRequest: 'INVALID_REQUEST',
} as const;

export type AuthorizationsReauthorize400ResponseNameEnum =
  (typeof AuthorizationsReauthorize400ResponseNameEnum)[keyof typeof AuthorizationsReauthorize400ResponseNameEnum];
export const AuthorizationsReauthorize400ResponseMessageEnum = {
  RequestIsNotWellFormedSyntacticallyIncorrectOrViolatesSchema:
    'Request is not well-formed, syntactically incorrect, or violates schema.',
} as const;

export type AuthorizationsReauthorize400ResponseMessageEnum =
  (typeof AuthorizationsReauthorize400ResponseMessageEnum)[keyof typeof AuthorizationsReauthorize400ResponseMessageEnum];

/**
 *
 * @export
 * @interface AuthorizationsReauthorize422
 */
export interface AuthorizationsReauthorize422 {
  /**
   *
   * @type {Array<AuthorizationsReauthorize422IssuesInner>}
   * @memberof AuthorizationsReauthorize422
   */
  issues?: Array<AuthorizationsReauthorize422IssuesInner>;
}
/**
 *
 * @export
 * @interface AuthorizationsReauthorize422IssuesInner
 */
export interface AuthorizationsReauthorize422IssuesInner {
  /**
   *
   * @type {string}
   * @memberof AuthorizationsReauthorize422IssuesInner
   */
  issue?: AuthorizationsReauthorize422IssuesInnerIssueEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizationsReauthorize422IssuesInner
   */
  description?: AuthorizationsReauthorize422IssuesInnerDescriptionEnum;
}

export const AuthorizationsReauthorize422IssuesInnerIssueEnum = {
  AuthCurrencyMismatch: 'AUTH_CURRENCY_MISMATCH',
} as const;

export type AuthorizationsReauthorize422IssuesInnerIssueEnum =
  (typeof AuthorizationsReauthorize422IssuesInnerIssueEnum)[keyof typeof AuthorizationsReauthorize422IssuesInnerIssueEnum];
export const AuthorizationsReauthorize422IssuesInnerDescriptionEnum = {
  TheCurrencySpecifiedDuringReauthorizationShouldBeTheSameAsTheCurrencySpecifiedInTheOriginalAuthorizationPleaseCheckTheCurrencyOfTheAuthorizationForWhichYouAreTryingToReauthorizeAndTryAgain:
    'The currency specified during reauthorization should be the same as the currency specified in the original authorization. Please check the currency of the authorization for which you are trying to reauthorize and try again.',
} as const;

export type AuthorizationsReauthorize422IssuesInnerDescriptionEnum =
  (typeof AuthorizationsReauthorize422IssuesInnerDescriptionEnum)[keyof typeof AuthorizationsReauthorize422IssuesInnerDescriptionEnum];

/**
 *
 * @export
 * @interface AuthorizationsReauthorize422Response
 */
export interface AuthorizationsReauthorize422Response {
  /**
   *
   * @type {string}
   * @memberof AuthorizationsReauthorize422Response
   */
  name?: AuthorizationsReauthorize422ResponseNameEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizationsReauthorize422Response
   */
  message?: AuthorizationsReauthorize422ResponseMessageEnum;
  /**
   *
   * @type {Array<AuthorizationsReauthorize422IssuesInner>}
   * @memberof AuthorizationsReauthorize422Response
   */
  issues?: Array<AuthorizationsReauthorize422IssuesInner>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof AuthorizationsReauthorize422Response
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof AuthorizationsReauthorize422Response
   */
  information_link?: string;
}

export const AuthorizationsReauthorize422ResponseNameEnum = {
  UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
} as const;

export type AuthorizationsReauthorize422ResponseNameEnum =
  (typeof AuthorizationsReauthorize422ResponseNameEnum)[keyof typeof AuthorizationsReauthorize422ResponseNameEnum];
export const AuthorizationsReauthorize422ResponseMessageEnum = {
  TheRequestedActionCouldNotBePerformedSemanticallyIncorrectOrFailedBusinessValidation:
    'The requested action could not be performed, semantically incorrect, or failed business validation.',
} as const;

export type AuthorizationsReauthorize422ResponseMessageEnum =
  (typeof AuthorizationsReauthorize422ResponseMessageEnum)[keyof typeof AuthorizationsReauthorize422ResponseMessageEnum];

/**
 *
 * @export
 * @interface AuthorizationsVoid401Response
 */
export interface AuthorizationsVoid401Response {
  /**
   *
   * @type {string}
   * @memberof AuthorizationsVoid401Response
   */
  name?: AuthorizationsVoid401ResponseNameEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizationsVoid401Response
   */
  message?: AuthorizationsVoid401ResponseMessageEnum;
  /**
   *
   * @type {Array<Model401IssuesInner>}
   * @memberof AuthorizationsVoid401Response
   */
  issues?: Array<Model401IssuesInner>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof AuthorizationsVoid401Response
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof AuthorizationsVoid401Response
   */
  information_link?: string;
}

export const AuthorizationsVoid401ResponseNameEnum = {
  AuthenticationFailure: 'AUTHENTICATION_FAILURE',
} as const;

export type AuthorizationsVoid401ResponseNameEnum =
  (typeof AuthorizationsVoid401ResponseNameEnum)[keyof typeof AuthorizationsVoid401ResponseNameEnum];
export const AuthorizationsVoid401ResponseMessageEnum = {
  AuthenticationFailedDueToMissingAuthorizationHeaderOrInvalidAuthenticationCredentials:
    'Authentication failed due to missing authorization header, or invalid authentication credentials.',
} as const;

export type AuthorizationsVoid401ResponseMessageEnum =
  (typeof AuthorizationsVoid401ResponseMessageEnum)[keyof typeof AuthorizationsVoid401ResponseMessageEnum];

/**
 *
 * @export
 * @interface AuthorizationsVoid409Response
 */
export interface AuthorizationsVoid409Response {
  /**
   *
   * @type {string}
   * @memberof AuthorizationsVoid409Response
   */
  name?: AuthorizationsVoid409ResponseNameEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizationsVoid409Response
   */
  message?: AuthorizationsVoid409ResponseMessageEnum;
  /**
   *
   * @type {Array<Model409IssuesInner>}
   * @memberof AuthorizationsVoid409Response
   */
  issues?: Array<Model409IssuesInner>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof AuthorizationsVoid409Response
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof AuthorizationsVoid409Response
   */
  information_link?: string;
}

export const AuthorizationsVoid409ResponseNameEnum = {
  ResourceConflict: 'RESOURCE_CONFLICT',
} as const;

export type AuthorizationsVoid409ResponseNameEnum =
  (typeof AuthorizationsVoid409ResponseNameEnum)[keyof typeof AuthorizationsVoid409ResponseNameEnum];
export const AuthorizationsVoid409ResponseMessageEnum = {
  TheServerHasDetectedAConflictWhileProcessingThisRequest:
    'The server has detected a conflict while processing this request.',
} as const;

export type AuthorizationsVoid409ResponseMessageEnum =
  (typeof AuthorizationsVoid409ResponseMessageEnum)[keyof typeof AuthorizationsVoid409ResponseMessageEnum];

/**
 *
 * @export
 * @interface AuthorizationsVoid422
 */
export interface AuthorizationsVoid422 {
  /**
   *
   * @type {Array<AuthorizationsVoid422IssuesInner>}
   * @memberof AuthorizationsVoid422
   */
  issues?: Array<AuthorizationsVoid422IssuesInner>;
}
/**
 *
 * @export
 * @interface AuthorizationsVoid422IssuesInner
 */
export interface AuthorizationsVoid422IssuesInner {
  /**
   *
   * @type {string}
   * @memberof AuthorizationsVoid422IssuesInner
   */
  issue?: AuthorizationsVoid422IssuesInnerIssueEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizationsVoid422IssuesInner
   */
  description?: AuthorizationsVoid422IssuesInnerDescriptionEnum;
}

export const AuthorizationsVoid422IssuesInnerIssueEnum = {
  CannotBeVoided: 'CANNOT_BE_VOIDED',
} as const;

export type AuthorizationsVoid422IssuesInnerIssueEnum =
  (typeof AuthorizationsVoid422IssuesInnerIssueEnum)[keyof typeof AuthorizationsVoid422IssuesInnerIssueEnum];
export const AuthorizationsVoid422IssuesInnerDescriptionEnum = {
  AReauthorizationCannotBeVoidedPleaseVoidTheOriginalParentAuthorization:
    'A reauthorization cannot be voided. Please void the original parent authorization.',
} as const;

export type AuthorizationsVoid422IssuesInnerDescriptionEnum =
  (typeof AuthorizationsVoid422IssuesInnerDescriptionEnum)[keyof typeof AuthorizationsVoid422IssuesInnerDescriptionEnum];

/**
 *
 * @export
 * @interface AuthorizationsVoid422Response
 */
export interface AuthorizationsVoid422Response {
  /**
   *
   * @type {string}
   * @memberof AuthorizationsVoid422Response
   */
  name?: AuthorizationsVoid422ResponseNameEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizationsVoid422Response
   */
  message?: AuthorizationsVoid422ResponseMessageEnum;
  /**
   *
   * @type {Array<AuthorizationsVoid422IssuesInner>}
   * @memberof AuthorizationsVoid422Response
   */
  issues?: Array<AuthorizationsVoid422IssuesInner>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof AuthorizationsVoid422Response
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof AuthorizationsVoid422Response
   */
  information_link?: string;
}

export const AuthorizationsVoid422ResponseNameEnum = {
  UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
} as const;

export type AuthorizationsVoid422ResponseNameEnum =
  (typeof AuthorizationsVoid422ResponseNameEnum)[keyof typeof AuthorizationsVoid422ResponseNameEnum];
export const AuthorizationsVoid422ResponseMessageEnum = {
  TheRequestedActionCouldNotBePerformedSemanticallyIncorrectOrFailedBusinessValidation:
    'The requested action could not be performed, semantically incorrect, or failed business validation.',
} as const;

export type AuthorizationsVoid422ResponseMessageEnum =
  (typeof AuthorizationsVoid422ResponseMessageEnum)[keyof typeof AuthorizationsVoid422ResponseMessageEnum];

/**
 *
 * @export
 * @interface CANNOTBENEGATIVE
 */
export interface CANNOTBENEGATIVE {
  /**
   *
   * @type {string}
   * @memberof CANNOTBENEGATIVE
   */
  issue?: CANNOTBENEGATIVEIssueEnum;
  /**
   *
   * @type {string}
   * @memberof CANNOTBENEGATIVE
   */
  description?: string;
}

export const CANNOTBENEGATIVEIssueEnum = {
  CannotBeNegative: 'CANNOT_BE_NEGATIVE',
} as const;

export type CANNOTBENEGATIVEIssueEnum =
  (typeof CANNOTBENEGATIVEIssueEnum)[keyof typeof CANNOTBENEGATIVEIssueEnum];

/**
 *
 * @export
 * @interface CANNOTBEVOIDED
 */
export interface CANNOTBEVOIDED {
  /**
   *
   * @type {string}
   * @memberof CANNOTBEVOIDED
   */
  issue?: CANNOTBEVOIDEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof CANNOTBEVOIDED
   */
  description?: CANNOTBEVOIDEDDescriptionEnum;
}

export const CANNOTBEVOIDEDIssueEnum = {
  CannotBeVoided: 'CANNOT_BE_VOIDED',
} as const;

export type CANNOTBEVOIDEDIssueEnum =
  (typeof CANNOTBEVOIDEDIssueEnum)[keyof typeof CANNOTBEVOIDEDIssueEnum];
export const CANNOTBEVOIDEDDescriptionEnum = {
  AReauthorizationCannotBeVoidedPleaseVoidTheOriginalParentAuthorization:
    'A reauthorization cannot be voided. Please void the original parent authorization.',
} as const;

export type CANNOTBEVOIDEDDescriptionEnum =
  (typeof CANNOTBEVOIDEDDescriptionEnum)[keyof typeof CANNOTBEVOIDEDDescriptionEnum];

/**
 *
 * @export
 * @interface CANNOTBEZEROORNEGATIVE
 */
export interface CANNOTBEZEROORNEGATIVE {
  /**
   *
   * @type {string}
   * @memberof CANNOTBEZEROORNEGATIVE
   */
  issue?: CANNOTBEZEROORNEGATIVEIssueEnum;
  /**
   *
   * @type {string}
   * @memberof CANNOTBEZEROORNEGATIVE
   */
  description?: CANNOTBEZEROORNEGATIVEDescriptionEnum;
}

export const CANNOTBEZEROORNEGATIVEIssueEnum = {
  CannotBeZeroOrNegative: 'CANNOT_BE_ZERO_OR_NEGATIVE',
} as const;

export type CANNOTBEZEROORNEGATIVEIssueEnum =
  (typeof CANNOTBEZEROORNEGATIVEIssueEnum)[keyof typeof CANNOTBEZEROORNEGATIVEIssueEnum];
export const CANNOTBEZEROORNEGATIVEDescriptionEnum = {
  MustBeGreaterThanZeroIfTheCurrencySupportsDecimalsOnlyTwoDecimalPlacePrecisionIsSupported:
    'Must be greater than zero. If the currency supports decimals, only two decimal place precision is supported.',
} as const;

export type CANNOTBEZEROORNEGATIVEDescriptionEnum =
  (typeof CANNOTBEZEROORNEGATIVEDescriptionEnum)[keyof typeof CANNOTBEZEROORNEGATIVEDescriptionEnum];

/**
 *
 * @export
 * @interface CANNOTBEZEROORNEGATIVE1
 */
export interface CANNOTBEZEROORNEGATIVE1 {
  /**
   *
   * @type {string}
   * @memberof CANNOTBEZEROORNEGATIVE1
   */
  issue?: CANNOTBEZEROORNEGATIVE1IssueEnum;
  /**
   *
   * @type {string}
   * @memberof CANNOTBEZEROORNEGATIVE1
   */
  description?: string;
}

export const CANNOTBEZEROORNEGATIVE1IssueEnum = {
  CannotBeZeroOrNegative: 'CANNOT_BE_ZERO_OR_NEGATIVE',
} as const;

export type CANNOTBEZEROORNEGATIVE1IssueEnum =
  (typeof CANNOTBEZEROORNEGATIVE1IssueEnum)[keyof typeof CANNOTBEZEROORNEGATIVE1IssueEnum];

/**
 *
 * @export
 * @interface CAPTUREFULLYREFUNDED
 */
export interface CAPTUREFULLYREFUNDED {
  /**
   *
   * @type {string}
   * @memberof CAPTUREFULLYREFUNDED
   */
  issue?: CAPTUREFULLYREFUNDEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof CAPTUREFULLYREFUNDED
   */
  description?: CAPTUREFULLYREFUNDEDDescriptionEnum;
}

export const CAPTUREFULLYREFUNDEDIssueEnum = {
  CaptureFullyRefunded: 'CAPTURE_FULLY_REFUNDED',
} as const;

export type CAPTUREFULLYREFUNDEDIssueEnum =
  (typeof CAPTUREFULLYREFUNDEDIssueEnum)[keyof typeof CAPTUREFULLYREFUNDEDIssueEnum];
export const CAPTUREFULLYREFUNDEDDescriptionEnum = {
  TheCaptureHasAlreadyBeenFullyRefunded:
    'The capture has already been fully refunded',
} as const;

export type CAPTUREFULLYREFUNDEDDescriptionEnum =
  (typeof CAPTUREFULLYREFUNDEDDescriptionEnum)[keyof typeof CAPTUREFULLYREFUNDEDDescriptionEnum];

/**
 *
 * @export
 * @interface CURRENCYMISMATCH
 */
export interface CURRENCYMISMATCH {
  /**
   *
   * @type {string}
   * @memberof CURRENCYMISMATCH
   */
  issue?: CURRENCYMISMATCHIssueEnum;
  /**
   *
   * @type {string}
   * @memberof CURRENCYMISMATCH
   */
  description?: string;
}

export const CURRENCYMISMATCHIssueEnum = {
  CurrencyMismatch: 'CURRENCY_MISMATCH',
} as const;

export type CURRENCYMISMATCHIssueEnum =
  (typeof CURRENCYMISMATCHIssueEnum)[keyof typeof CURRENCYMISMATCHIssueEnum];

/**
 * A captured payment.
 * @export
 * @interface Capture
 */
export interface Capture {
  /**
   * The status of the captured payment.
   * @type {string}
   * @memberof Capture
   */
  status?: CaptureStatusEnum;
  /**
   *
   * @type {CaptureStatusDetails}
   * @memberof Capture
   */
  status_details?: CaptureStatusDetails;
  /**
   * The PayPal-generated ID for the captured payment.
   * @type {string}
   * @memberof Capture
   */
  id?: string;
  /**
   *
   * @type {Money}
   * @memberof Capture
   */
  amount?: Money;
  /**
   * The API caller-provided external invoice number for this order. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof Capture
   */
  invoice_id?: string;
  /**
   * The API caller-provided external ID. Used to reconcile API caller-initiated transactions with PayPal transactions. Appears in transaction and settlement reports.
   * @type {string}
   * @memberof Capture
   */
  custom_id?: string;
  /**
   *
   * @type {NetworkTransactionReference}
   * @memberof Capture
   */
  network_transaction_reference?: NetworkTransactionReference;
  /**
   *
   * @type {SellerProtection}
   * @memberof Capture
   */
  seller_protection?: SellerProtection;
  /**
   * Indicates whether you can make additional captures against the authorized payment. Set to `true` if you do not intend to capture additional payments against the authorization. Set to `false` if you intend to capture additional payments against the authorization.
   * @type {boolean}
   * @memberof Capture
   */
  final_capture?: boolean;
  /**
   *
   * @type {SellerReceivableBreakdown}
   * @memberof Capture
   */
  seller_receivable_breakdown?: SellerReceivableBreakdown;
  /**
   *
   * @type {DisbursementMode}
   * @memberof Capture
   */
  disbursement_mode?: DisbursementMode;
  /**
   * An array of related [HATEOAS links](/docs/api/reference/api-responses/#hateoas-links).
   * @type {Array<LinkDescription>}
   * @memberof Capture
   */
  links?: Array<LinkDescription>;
  /**
   *
   * @type {ProcessorResponse}
   * @memberof Capture
   */
  processor_response?: ProcessorResponse;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof Capture
   */
  create_time?: string;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof Capture
   */
  update_time?: string;
}

export const CaptureStatusEnum = {
  Completed: 'COMPLETED',
  Declined: 'DECLINED',
  PartiallyRefunded: 'PARTIALLY_REFUNDED',
  Pending: 'PENDING',
  Refunded: 'REFUNDED',
  Failed: 'FAILED',
} as const;

export type CaptureStatusEnum =
  (typeof CaptureStatusEnum)[keyof typeof CaptureStatusEnum];

/**
 * A captured payment.
 * @export
 * @interface Capture2
 */
export interface Capture2 {
  /**
   * The status of the captured payment.
   * @type {string}
   * @memberof Capture2
   */
  status?: Capture2StatusEnum;
  /**
   *
   * @type {CaptureStatusDetails}
   * @memberof Capture2
   */
  status_details?: CaptureStatusDetails;
  /**
   * The PayPal-generated ID for the captured payment.
   * @type {string}
   * @memberof Capture2
   */
  id?: string;
  /**
   *
   * @type {Money}
   * @memberof Capture2
   */
  amount?: Money;
  /**
   * The API caller-provided external invoice number for this order. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof Capture2
   */
  invoice_id?: string;
  /**
   * The API caller-provided external ID. Used to reconcile API caller-initiated transactions with PayPal transactions. Appears in transaction and settlement reports.
   * @type {string}
   * @memberof Capture2
   */
  custom_id?: string;
  /**
   *
   * @type {NetworkTransactionReference}
   * @memberof Capture2
   */
  network_transaction_reference?: NetworkTransactionReference;
  /**
   *
   * @type {SellerProtection}
   * @memberof Capture2
   */
  seller_protection?: SellerProtection;
  /**
   * Indicates whether you can make additional captures against the authorized payment. Set to `true` if you do not intend to capture additional payments against the authorization. Set to `false` if you intend to capture additional payments against the authorization.
   * @type {boolean}
   * @memberof Capture2
   */
  final_capture?: boolean;
  /**
   *
   * @type {SellerReceivableBreakdown}
   * @memberof Capture2
   */
  seller_receivable_breakdown?: SellerReceivableBreakdown;
  /**
   *
   * @type {DisbursementMode}
   * @memberof Capture2
   */
  disbursement_mode?: DisbursementMode;
  /**
   * An array of related [HATEOAS links](/docs/api/reference/api-responses/#hateoas-links).
   * @type {Array<LinkDescription>}
   * @memberof Capture2
   */
  links?: Array<LinkDescription>;
  /**
   *
   * @type {ProcessorResponse}
   * @memberof Capture2
   */
  processor_response?: ProcessorResponse;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof Capture2
   */
  create_time?: string;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof Capture2
   */
  update_time?: string;
  /**
   *
   * @type {SupplementaryData}
   * @memberof Capture2
   */
  supplementary_data?: SupplementaryData;
  /**
   *
   * @type {PayeeBase}
   * @memberof Capture2
   */
  payee?: PayeeBase;
}

export const Capture2StatusEnum = {
  Completed: 'COMPLETED',
  Declined: 'DECLINED',
  PartiallyRefunded: 'PARTIALLY_REFUNDED',
  Pending: 'PENDING',
  Refunded: 'REFUNDED',
  Failed: 'FAILED',
} as const;

export type Capture2StatusEnum =
  (typeof Capture2StatusEnum)[keyof typeof Capture2StatusEnum];

/**
 *
 * @export
 * @interface CaptureAllOf
 */
export interface CaptureAllOf {
  /**
   * The PayPal-generated ID for the captured payment.
   * @type {string}
   * @memberof CaptureAllOf
   */
  id?: string;
  /**
   *
   * @type {Money}
   * @memberof CaptureAllOf
   */
  amount?: Money;
  /**
   * The API caller-provided external invoice number for this order. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof CaptureAllOf
   */
  invoice_id?: string;
  /**
   * The API caller-provided external ID. Used to reconcile API caller-initiated transactions with PayPal transactions. Appears in transaction and settlement reports.
   * @type {string}
   * @memberof CaptureAllOf
   */
  custom_id?: string;
  /**
   *
   * @type {NetworkTransactionReference}
   * @memberof CaptureAllOf
   */
  network_transaction_reference?: NetworkTransactionReference;
  /**
   *
   * @type {SellerProtection}
   * @memberof CaptureAllOf
   */
  seller_protection?: SellerProtection;
  /**
   * Indicates whether you can make additional captures against the authorized payment. Set to `true` if you do not intend to capture additional payments against the authorization. Set to `false` if you intend to capture additional payments against the authorization.
   * @type {boolean}
   * @memberof CaptureAllOf
   */
  final_capture?: boolean;
  /**
   *
   * @type {SellerReceivableBreakdown}
   * @memberof CaptureAllOf
   */
  seller_receivable_breakdown?: SellerReceivableBreakdown;
  /**
   *
   * @type {DisbursementMode}
   * @memberof CaptureAllOf
   */
  disbursement_mode?: DisbursementMode;
  /**
   * An array of related [HATEOAS links](/docs/api/reference/api-responses/#hateoas-links).
   * @type {Array<LinkDescription>}
   * @memberof CaptureAllOf
   */
  links?: Array<LinkDescription>;
  /**
   *
   * @type {ProcessorResponse}
   * @memberof CaptureAllOf
   */
  processor_response?: ProcessorResponse;
}

/**
 * Captures either a portion or the full authorized amount of an authorized payment.
 * @export
 * @interface CaptureRequest
 */
export interface CaptureRequest {
  /**
   * The API caller-provided external invoice number for this order. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof CaptureRequest
   */
  invoice_id?: string;
  /**
   * An informational note about this settlement. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof CaptureRequest
   */
  note_to_payer?: string;
  /**
   *
   * @type {Money}
   * @memberof CaptureRequest
   */
  amount?: Money;
  /**
   * Indicates whether you can make additional captures against the authorized payment. Set to `true` if you do not intend to capture additional payments against the authorization. Set to `false` if you intend to capture additional payments against the authorization.
   * @type {boolean}
   * @memberof CaptureRequest
   */
  final_capture?: boolean;
  /**
   *
   * @type {PaymentInstruction}
   * @memberof CaptureRequest
   */
  payment_instruction?: PaymentInstruction;
  /**
   * The payment descriptor on the payer\'s account statement.
   * @type {string}
   * @memberof CaptureRequest
   */
  soft_descriptor?: string;
}
/**
 *
 * @export
 * @interface CaptureRequestAllOf
 */
export interface CaptureRequestAllOf {
  /**
   *
   * @type {Money}
   * @memberof CaptureRequestAllOf
   */
  amount?: Money;
  /**
   * The API caller-provided external invoice number for this order. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof CaptureRequestAllOf
   */
  invoice_id?: string;
  /**
   * Indicates whether you can make additional captures against the authorized payment. Set to `true` if you do not intend to capture additional payments against the authorization. Set to `false` if you intend to capture additional payments against the authorization.
   * @type {boolean}
   * @memberof CaptureRequestAllOf
   */
  final_capture?: boolean;
  /**
   *
   * @type {PaymentInstruction}
   * @memberof CaptureRequestAllOf
   */
  payment_instruction?: PaymentInstruction;
  /**
   * An informational note about this settlement. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof CaptureRequestAllOf
   */
  note_to_payer?: string;
  /**
   * The payment descriptor on the payer\'s account statement.
   * @type {string}
   * @memberof CaptureRequestAllOf
   */
  soft_descriptor?: string;
}
/**
 * The status of a captured payment.
 * @export
 * @interface CaptureStatus
 */
export interface CaptureStatus {
  /**
   * The status of the captured payment.
   * @type {string}
   * @memberof CaptureStatus
   */
  status?: CaptureStatusStatusEnum;
  /**
   *
   * @type {CaptureStatusDetails}
   * @memberof CaptureStatus
   */
  status_details?: CaptureStatusDetails;
}

export const CaptureStatusStatusEnum = {
  Completed: 'COMPLETED',
  Declined: 'DECLINED',
  PartiallyRefunded: 'PARTIALLY_REFUNDED',
  Pending: 'PENDING',
  Refunded: 'REFUNDED',
  Failed: 'FAILED',
} as const;

export type CaptureStatusStatusEnum =
  (typeof CaptureStatusStatusEnum)[keyof typeof CaptureStatusStatusEnum];

/**
 * The details of the captured payment status.
 * @export
 * @interface CaptureStatusDetails
 */
export interface CaptureStatusDetails {
  /**
   * The reason why the captured payment status is `PENDING` or `DENIED`.
   * @type {string}
   * @memberof CaptureStatusDetails
   */
  reason?: CaptureStatusDetailsReasonEnum;
}

export const CaptureStatusDetailsReasonEnum = {
  BuyerComplaint: 'BUYER_COMPLAINT',
  Chargeback: 'CHARGEBACK',
  Echeck: 'ECHECK',
  InternationalWithdrawal: 'INTERNATIONAL_WITHDRAWAL',
  Other: 'OTHER',
  PendingReview: 'PENDING_REVIEW',
  ReceivingPreferenceMandatesManualAction:
    'RECEIVING_PREFERENCE_MANDATES_MANUAL_ACTION',
  Refunded: 'REFUNDED',
  TransactionApprovedAwaitingFunding: 'TRANSACTION_APPROVED_AWAITING_FUNDING',
  Unilateral: 'UNILATERAL',
  VerificationRequired: 'VERIFICATION_REQUIRED',
} as const;

export type CaptureStatusDetailsReasonEnum =
  (typeof CaptureStatusDetailsReasonEnum)[keyof typeof CaptureStatusDetailsReasonEnum];

/**
 *
 * @export
 * @interface CapturesRefund400
 */
export interface CapturesRefund400 {
  /**
   *
   * @type {Array<CapturesRefund400IssuesInner>}
   * @memberof CapturesRefund400
   */
  issues?: Array<CapturesRefund400IssuesInner>;
}
/**
 *
 * @export
 * @interface CapturesRefund400IssuesInner
 */
export interface CapturesRefund400IssuesInner {
  /**
   *
   * @type {string}
   * @memberof CapturesRefund400IssuesInner
   */
  issue?: CapturesRefund400IssuesInnerIssueEnum;
  /**
   *
   * @type {string}
   * @memberof CapturesRefund400IssuesInner
   */
  description?: string;
}

export const CapturesRefund400IssuesInnerIssueEnum = {
  InvalidStringLength: 'INVALID_STRING_LENGTH',
} as const;

export type CapturesRefund400IssuesInnerIssueEnum =
  (typeof CapturesRefund400IssuesInnerIssueEnum)[keyof typeof CapturesRefund400IssuesInnerIssueEnum];

/**
 *
 * @export
 * @interface CapturesRefund400Response
 */
export interface CapturesRefund400Response {
  /**
   *
   * @type {string}
   * @memberof CapturesRefund400Response
   */
  name?: CapturesRefund400ResponseNameEnum;
  /**
   *
   * @type {string}
   * @memberof CapturesRefund400Response
   */
  message?: CapturesRefund400ResponseMessageEnum;
  /**
   *
   * @type {Array<CapturesRefund400IssuesInner>}
   * @memberof CapturesRefund400Response
   */
  issues?: Array<CapturesRefund400IssuesInner>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof CapturesRefund400Response
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof CapturesRefund400Response
   */
  information_link?: string;
}

export const CapturesRefund400ResponseNameEnum = {
  InvalidRequest: 'INVALID_REQUEST',
} as const;

export type CapturesRefund400ResponseNameEnum =
  (typeof CapturesRefund400ResponseNameEnum)[keyof typeof CapturesRefund400ResponseNameEnum];
export const CapturesRefund400ResponseMessageEnum = {
  RequestIsNotWellFormedSyntacticallyIncorrectOrViolatesSchema:
    'Request is not well-formed, syntactically incorrect, or violates schema.',
} as const;

export type CapturesRefund400ResponseMessageEnum =
  (typeof CapturesRefund400ResponseMessageEnum)[keyof typeof CapturesRefund400ResponseMessageEnum];

/**
 *
 * @export
 * @interface CapturesRefund422
 */
export interface CapturesRefund422 {
  /**
   *
   * @type {Array<CapturesRefund422IssuesInner>}
   * @memberof CapturesRefund422
   */
  issues?: Array<CapturesRefund422IssuesInner>;
}
/**
 *
 * @export
 * @interface CapturesRefund422IssuesInner
 */
export interface CapturesRefund422IssuesInner {
  /**
   *
   * @type {string}
   * @memberof CapturesRefund422IssuesInner
   */
  issue?: CapturesRefund422IssuesInnerIssueEnum;
  /**
   *
   * @type {string}
   * @memberof CapturesRefund422IssuesInner
   */
  description?: CapturesRefund422IssuesInnerDescriptionEnum;
}

export const CapturesRefund422IssuesInnerIssueEnum = {
  PlatformFeeNotEnabled: 'PLATFORM_FEE_NOT_ENABLED',
} as const;

export type CapturesRefund422IssuesInnerIssueEnum =
  (typeof CapturesRefund422IssuesInnerIssueEnum)[keyof typeof CapturesRefund422IssuesInnerIssueEnum];
export const CapturesRefund422IssuesInnerDescriptionEnum = {
  TheApiCallerAccountIsNotSetupToBeAbleToProcessRefundsWithPlatformFeesPleaseContactYourAccountManagerThisFeatureIsUsefulWhenYouWantToContributeAPortionOfThePlatformFeesYouHadCaptureAsPartOfTheRefundBeingProcessed:
    "The API Caller account is not setup to be able to process refunds with 'platform_fees'. Please contact your Account Manager. This feature is useful when you want to contribute a portion of the 'platform_fees' you had capture as part of the refund being processed.",
} as const;

export type CapturesRefund422IssuesInnerDescriptionEnum =
  (typeof CapturesRefund422IssuesInnerDescriptionEnum)[keyof typeof CapturesRefund422IssuesInnerDescriptionEnum];

/**
 *
 * @export
 * @interface CapturesRefund422Response
 */
export interface CapturesRefund422Response {
  /**
   *
   * @type {string}
   * @memberof CapturesRefund422Response
   */
  name?: CapturesRefund422ResponseNameEnum;
  /**
   *
   * @type {string}
   * @memberof CapturesRefund422Response
   */
  message?: CapturesRefund422ResponseMessageEnum;
  /**
   *
   * @type {Array<CapturesRefund422IssuesInner>}
   * @memberof CapturesRefund422Response
   */
  issues?: Array<CapturesRefund422IssuesInner>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof CapturesRefund422Response
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof CapturesRefund422Response
   */
  information_link?: string;
}

export const CapturesRefund422ResponseNameEnum = {
  UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
} as const;

export type CapturesRefund422ResponseNameEnum =
  (typeof CapturesRefund422ResponseNameEnum)[keyof typeof CapturesRefund422ResponseNameEnum];
export const CapturesRefund422ResponseMessageEnum = {
  TheRequestedActionCouldNotBePerformedSemanticallyIncorrectOrFailedBusinessValidation:
    'The requested action could not be performed, semantically incorrect, or failed business validation.',
} as const;

export type CapturesRefund422ResponseMessageEnum =
  (typeof CapturesRefund422ResponseMessageEnum)[keyof typeof CapturesRefund422ResponseMessageEnum];

/**
 * The card network or brand. Applies to credit, debit, gift, and payment cards.
 * @export
 * @enum {string}
 */

export const CardBrand = {
  Visa: 'VISA',
  Mastercard: 'MASTERCARD',
  Discover: 'DISCOVER',
  Amex: 'AMEX',
  Solo: 'SOLO',
  Jcb: 'JCB',
  Star: 'STAR',
  Delta: 'DELTA',
  Switch: 'SWITCH',
  Maestro: 'MAESTRO',
  CbNationale: 'CB_NATIONALE',
  Configoga: 'CONFIGOGA',
  Confidis: 'CONFIDIS',
  Electron: 'ELECTRON',
  Cetelem: 'CETELEM',
  ChinaUnionPay: 'CHINA_UNION_PAY',
} as const;

export type CardBrand = (typeof CardBrand)[keyof typeof CardBrand];

/**
 *
 * @export
 * @interface DECIMALPRECISION
 */
export interface DECIMALPRECISION {
  /**
   *
   * @type {string}
   * @memberof DECIMALPRECISION
   */
  issue?: DECIMALPRECISIONIssueEnum;
  /**
   *
   * @type {string}
   * @memberof DECIMALPRECISION
   */
  description?: DECIMALPRECISIONDescriptionEnum;
}

export const DECIMALPRECISIONIssueEnum = {
  DecimalPrecision: 'DECIMAL_PRECISION',
} as const;

export type DECIMALPRECISIONIssueEnum =
  (typeof DECIMALPRECISIONIssueEnum)[keyof typeof DECIMALPRECISIONIssueEnum];
export const DECIMALPRECISIONDescriptionEnum = {
  IfTheCurrencySupportsDecimalsOnlyTwoDecimalPlacePrecisionIsSupported:
    'If the currency supports decimals, only two decimal place precision is supported.',
} as const;

export type DECIMALPRECISIONDescriptionEnum =
  (typeof DECIMALPRECISIONDescriptionEnum)[keyof typeof DECIMALPRECISIONDescriptionEnum];

/**
 *
 * @export
 * @interface DECIMALPRECISION1
 */
export interface DECIMALPRECISION1 {
  /**
   *
   * @type {string}
   * @memberof DECIMALPRECISION1
   */
  issue?: DECIMALPRECISION1IssueEnum;
  /**
   *
   * @type {string}
   * @memberof DECIMALPRECISION1
   */
  description?: string;
}

export const DECIMALPRECISION1IssueEnum = {
  DecimalPrecision: 'DECIMAL_PRECISION',
} as const;

export type DECIMALPRECISION1IssueEnum =
  (typeof DECIMALPRECISION1IssueEnum)[keyof typeof DECIMALPRECISION1IssueEnum];

/**
 *
 * @export
 * @interface DECIMALSNOTSUPPORTED
 */
export interface DECIMALSNOTSUPPORTED {
  /**
   *
   * @type {string}
   * @memberof DECIMALSNOTSUPPORTED
   */
  issue?: DECIMALSNOTSUPPORTEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof DECIMALSNOTSUPPORTED
   */
  description?: DECIMALSNOTSUPPORTEDDescriptionEnum;
}

export const DECIMALSNOTSUPPORTEDIssueEnum = {
  DecimalsNotSupported: 'DECIMALS_NOT_SUPPORTED',
} as const;

export type DECIMALSNOTSUPPORTEDIssueEnum =
  (typeof DECIMALSNOTSUPPORTEDIssueEnum)[keyof typeof DECIMALSNOTSUPPORTEDIssueEnum];
export const DECIMALSNOTSUPPORTEDDescriptionEnum = {
  CurrencyDoesNotSupportDecimalsPleaseReferToHttpsDeveloperPaypalComDocsApiReferenceCurrencyCodesForMoreInformation:
    'Currency does not support decimals. Please refer to https://developer.paypal.com/docs/api/reference/currency-codes/ for more information.',
} as const;

export type DECIMALSNOTSUPPORTEDDescriptionEnum =
  (typeof DECIMALSNOTSUPPORTEDDescriptionEnum)[keyof typeof DECIMALSNOTSUPPORTEDDescriptionEnum];

/**
 *
 * @export
 * @interface DECIMALSNOTSUPPORTED1
 */
export interface DECIMALSNOTSUPPORTED1 {
  /**
   *
   * @type {string}
   * @memberof DECIMALSNOTSUPPORTED1
   */
  issue?: DECIMALSNOTSUPPORTED1IssueEnum;
  /**
   *
   * @type {string}
   * @memberof DECIMALSNOTSUPPORTED1
   */
  description?: string;
}

export const DECIMALSNOTSUPPORTED1IssueEnum = {
  DecimalsNotSupported: 'DECIMALS_NOT_SUPPORTED',
} as const;

export type DECIMALSNOTSUPPORTED1IssueEnum =
  (typeof DECIMALSNOTSUPPORTED1IssueEnum)[keyof typeof DECIMALSNOTSUPPORTED1IssueEnum];

/**
 *
 * @export
 * @interface DUPLICATEINVOICEID
 */
export interface DUPLICATEINVOICEID {
  /**
   *
   * @type {string}
   * @memberof DUPLICATEINVOICEID
   */
  issue?: DUPLICATEINVOICEIDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof DUPLICATEINVOICEID
   */
  description?: DUPLICATEINVOICEIDDescriptionEnum;
}

export const DUPLICATEINVOICEIDIssueEnum = {
  DuplicateInvoiceId: 'DUPLICATE_INVOICE_ID',
} as const;

export type DUPLICATEINVOICEIDIssueEnum =
  (typeof DUPLICATEINVOICEIDIssueEnum)[keyof typeof DUPLICATEINVOICEIDIssueEnum];
export const DUPLICATEINVOICEIDDescriptionEnum = {
  RequestedInvoiceIdHasBeenPreviouslyCapturedPossibleDuplicateTransaction:
    'Requested invoice_id has been previously captured. Possible duplicate transaction.',
} as const;

export type DUPLICATEINVOICEIDDescriptionEnum =
  (typeof DUPLICATEINVOICEIDDescriptionEnum)[keyof typeof DUPLICATEINVOICEIDDescriptionEnum];

/**
 *
 * @export
 * @interface DUPLICATEINVOICEID1
 */
export interface DUPLICATEINVOICEID1 {
  /**
   *
   * @type {string}
   * @memberof DUPLICATEINVOICEID1
   */
  issue?: DUPLICATEINVOICEID1IssueEnum;
  /**
   *
   * @type {string}
   * @memberof DUPLICATEINVOICEID1
   */
  description?: DUPLICATEINVOICEID1DescriptionEnum;
}

export const DUPLICATEINVOICEID1IssueEnum = {
  DuplicateInvoiceId: 'DUPLICATE_INVOICE_ID',
} as const;

export type DUPLICATEINVOICEID1IssueEnum =
  (typeof DUPLICATEINVOICEID1IssueEnum)[keyof typeof DUPLICATEINVOICEID1IssueEnum];
export const DUPLICATEINVOICEID1DescriptionEnum = {
  InvoiceIdWasPreviouslyUsedToRefundACapture:
    'Invoice ID was previously used to refund a capture.',
} as const;

export type DUPLICATEINVOICEID1DescriptionEnum =
  (typeof DUPLICATEINVOICEID1DescriptionEnum)[keyof typeof DUPLICATEINVOICEID1DescriptionEnum];

/**
 * The funds that are held on behalf of the merchant.
 * @export
 * @enum {string}
 */

export const DisbursementMode = {
  Instant: 'INSTANT',
  Delayed: 'DELAYED',
} as const;

export type DisbursementMode =
  (typeof DisbursementMode)[keyof typeof DisbursementMode];

/**
 * Error response for 400
 * @export
 * @interface Error400
 */
export interface Error400 {
  /**
   *
   * @type {string}
   * @memberof Error400
   */
  name?: Error400NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error400
   */
  message?: Error400MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error400
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error400
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error400
   */
  information_link?: string;
}

export const Error400NameEnum = {
  InvalidRequest: 'INVALID_REQUEST',
} as const;

export type Error400NameEnum =
  (typeof Error400NameEnum)[keyof typeof Error400NameEnum];
export const Error400MessageEnum = {
  RequestIsNotWellFormedSyntacticallyIncorrectOrViolatesSchema:
    'Request is not well-formed, syntactically incorrect, or violates schema.',
} as const;

export type Error400MessageEnum =
  (typeof Error400MessageEnum)[keyof typeof Error400MessageEnum];

/**
 * Error response for 401
 * @export
 * @interface Error401
 */
export interface Error401 {
  /**
   *
   * @type {string}
   * @memberof Error401
   */
  name?: Error401NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error401
   */
  message?: Error401MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error401
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error401
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error401
   */
  information_link?: string;
}

export const Error401NameEnum = {
  AuthenticationFailure: 'AUTHENTICATION_FAILURE',
} as const;

export type Error401NameEnum =
  (typeof Error401NameEnum)[keyof typeof Error401NameEnum];
export const Error401MessageEnum = {
  AuthenticationFailedDueToMissingAuthorizationHeaderOrInvalidAuthenticationCredentials:
    'Authentication failed due to missing authorization header, or invalid authentication credentials.',
} as const;

export type Error401MessageEnum =
  (typeof Error401MessageEnum)[keyof typeof Error401MessageEnum];

/**
 * Error response for 403
 * @export
 * @interface Error403
 */
export interface Error403 {
  /**
   *
   * @type {string}
   * @memberof Error403
   */
  name?: Error403NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error403
   */
  message?: Error403MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error403
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error403
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error403
   */
  information_link?: string;
}

export const Error403NameEnum = {
  NotAuthorized: 'NOT_AUTHORIZED',
} as const;

export type Error403NameEnum =
  (typeof Error403NameEnum)[keyof typeof Error403NameEnum];
export const Error403MessageEnum = {
  AuthorizationFailedDueToInsufficientPermissions:
    'Authorization failed due to insufficient permissions.',
} as const;

export type Error403MessageEnum =
  (typeof Error403MessageEnum)[keyof typeof Error403MessageEnum];

/**
 * Error response for 404
 * @export
 * @interface Error404
 */
export interface Error404 {
  /**
   *
   * @type {string}
   * @memberof Error404
   */
  name?: Error404NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error404
   */
  message?: Error404MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error404
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error404
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error404
   */
  information_link?: string;
}

export const Error404NameEnum = {
  ResourceNotFound: 'RESOURCE_NOT_FOUND',
} as const;

export type Error404NameEnum =
  (typeof Error404NameEnum)[keyof typeof Error404NameEnum];
export const Error404MessageEnum = {
  TheSpecifiedResourceDoesNotExist: 'The specified resource does not exist.',
} as const;

export type Error404MessageEnum =
  (typeof Error404MessageEnum)[keyof typeof Error404MessageEnum];

/**
 * Error response for 409
 * @export
 * @interface Error409
 */
export interface Error409 {
  /**
   *
   * @type {string}
   * @memberof Error409
   */
  name?: Error409NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error409
   */
  message?: Error409MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error409
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error409
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error409
   */
  information_link?: string;
}

export const Error409NameEnum = {
  ResourceConflict: 'RESOURCE_CONFLICT',
} as const;

export type Error409NameEnum =
  (typeof Error409NameEnum)[keyof typeof Error409NameEnum];
export const Error409MessageEnum = {
  TheServerHasDetectedAConflictWhileProcessingThisRequest:
    'The server has detected a conflict while processing this request.',
} as const;

export type Error409MessageEnum =
  (typeof Error409MessageEnum)[keyof typeof Error409MessageEnum];

/**
 * Error response for 415
 * @export
 * @interface Error415
 */
export interface Error415 {
  /**
   *
   * @type {string}
   * @memberof Error415
   */
  name?: Error415NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error415
   */
  message?: Error415MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error415
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error415
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error415
   */
  information_link?: string;
}

export const Error415NameEnum = {
  UnsupportedMediaType: 'UNSUPPORTED_MEDIA_TYPE',
} as const;

export type Error415NameEnum =
  (typeof Error415NameEnum)[keyof typeof Error415NameEnum];
export const Error415MessageEnum = {
  TheServerDoesNotSupportTheRequestPayloadsMediaType:
    "The server does not support the request payload's media type.",
} as const;

export type Error415MessageEnum =
  (typeof Error415MessageEnum)[keyof typeof Error415MessageEnum];

/**
 * Error response for 422
 * @export
 * @interface Error422
 */
export interface Error422 {
  /**
   *
   * @type {string}
   * @memberof Error422
   */
  name?: Error422NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error422
   */
  message?: Error422MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error422
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error422
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error422
   */
  information_link?: string;
}

export const Error422NameEnum = {
  UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
} as const;

export type Error422NameEnum =
  (typeof Error422NameEnum)[keyof typeof Error422NameEnum];
export const Error422MessageEnum = {
  TheRequestedActionCouldNotBePerformedSemanticallyIncorrectOrFailedBusinessValidation:
    'The requested action could not be performed, semantically incorrect, or failed business validation.',
} as const;

export type Error422MessageEnum =
  (typeof Error422MessageEnum)[keyof typeof Error422MessageEnum];

/**
 * Error response for 500
 * @export
 * @interface Error500
 */
export interface Error500 {
  /**
   *
   * @type {string}
   * @memberof Error500
   */
  name?: Error500NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error500
   */
  message?: Error500MessageEnum;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error500
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error500
   */
  information_link?: Error500InformationLinkEnum;
}

export const Error500NameEnum = {
  InternalServerError: 'INTERNAL_SERVER_ERROR',
} as const;

export type Error500NameEnum =
  (typeof Error500NameEnum)[keyof typeof Error500NameEnum];
export const Error500MessageEnum = {
  AnInternalServerErrorOccurred: 'An internal server error occurred.',
} as const;

export type Error500MessageEnum =
  (typeof Error500MessageEnum)[keyof typeof Error500MessageEnum];
export const Error500InformationLinkEnum = {
  HttpsDeveloperPaypalComApiOrdersV2ErrorInternalServerError:
    'https://developer.paypal.com/api/orders/v2/#error-INTERNAL_SERVER_ERROR',
} as const;

export type Error500InformationLinkEnum =
  (typeof Error500InformationLinkEnum)[keyof typeof Error500InformationLinkEnum];

/**
 * Error response for 503
 * @export
 * @interface Error503
 */
export interface Error503 {
  /**
   *
   * @type {string}
   * @memberof Error503
   */
  name?: Error503NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error503
   */
  message?: Error503MessageEnum;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error503
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error503
   */
  information_link?: string;
}

export const Error503NameEnum = {
  ServiceUnavailable: 'SERVICE_UNAVAILABLE',
} as const;

export type Error503NameEnum =
  (typeof Error503NameEnum)[keyof typeof Error503NameEnum];
export const Error503MessageEnum = {
  ServiceUnavailable: 'Service Unavailable.',
} as const;

export type Error503MessageEnum =
  (typeof Error503MessageEnum)[keyof typeof Error503MessageEnum];

/**
 * @type ErrorDefault
 * The default error response.
 * @export
 */
export type ErrorDefault =
  | Error400
  | Error401
  | Error403
  | Error404
  | Error409
  | Error415
  | Error422
  | Error500
  | Error503;

/**
 * The error details. Required for client-side `4XX` errors.
 * @export
 * @interface ErrorDetails
 */
export interface ErrorDetails {
  /**
   * The field that caused the error. If this field is in the body, set this value to the field\'s JSON pointer value. Required for client-side errors.
   * @type {string}
   * @memberof ErrorDetails
   */
  field?: string;
  /**
   * The value of the field that caused the error.
   * @type {string}
   * @memberof ErrorDetails
   */
  value?: string;
  /**
   * The location of the field that caused the error. Value is `body`, `path`, or `query`.
   * @type {string}
   * @memberof ErrorDetails
   */
  location?: string;
  /**
   * The unique, fine-grained application-level error code.
   * @type {string}
   * @memberof ErrorDetails
   */
  issue: string;
  /**
   * The human-readable description for an issue. The description can change over the lifetime of an API, so clients must not depend on this value.
   * @type {string}
   * @memberof ErrorDetails
   */
  description?: string;
}
/**
 * The exchange rate that determines the amount to convert from one currency to another currency.
 * @export
 * @interface ExchangeRate
 */
export interface ExchangeRate {
  /**
   * The [three-character ISO-4217 currency code](/api/rest/reference/currency-codes/) that identifies the currency.
   * @type {string}
   * @memberof ExchangeRate
   */
  source_currency?: string;
  /**
   * The [three-character ISO-4217 currency code](/api/rest/reference/currency-codes/) that identifies the currency.
   * @type {string}
   * @memberof ExchangeRate
   */
  target_currency?: string;
  /**
   * The target currency amount. Equivalent to one unit of the source currency. Formatted as integer or decimal value with one to 15 digits to the right of the decimal point.
   * @type {string}
   * @memberof ExchangeRate
   */
  value?: string;
}
/**
 *
 * @export
 * @interface INVALIDACCOUNTSTATUS
 */
export interface INVALIDACCOUNTSTATUS {
  /**
   *
   * @type {string}
   * @memberof INVALIDACCOUNTSTATUS
   */
  issue?: INVALIDACCOUNTSTATUSIssueEnum;
  /**
   *
   * @type {string}
   * @memberof INVALIDACCOUNTSTATUS
   */
  description?: INVALIDACCOUNTSTATUSDescriptionEnum;
}

export const INVALIDACCOUNTSTATUSIssueEnum = {
  InvalidAccountStatus: 'INVALID_ACCOUNT_STATUS',
} as const;

export type INVALIDACCOUNTSTATUSIssueEnum =
  (typeof INVALIDACCOUNTSTATUSIssueEnum)[keyof typeof INVALIDACCOUNTSTATUSIssueEnum];
export const INVALIDACCOUNTSTATUSDescriptionEnum = {
  AccountValidationsFailedForTheUser:
    'Account validations failed for the user.',
} as const;

export type INVALIDACCOUNTSTATUSDescriptionEnum =
  (typeof INVALIDACCOUNTSTATUSDescriptionEnum)[keyof typeof INVALIDACCOUNTSTATUSDescriptionEnum];

/**
 *
 * @export
 * @interface INVALIDCURRENCYCODE
 */
export interface INVALIDCURRENCYCODE {
  /**
   *
   * @type {string}
   * @memberof INVALIDCURRENCYCODE
   */
  issue?: INVALIDCURRENCYCODEIssueEnum;
  /**
   *
   * @type {string}
   * @memberof INVALIDCURRENCYCODE
   */
  description?: INVALIDCURRENCYCODEDescriptionEnum;
}

export const INVALIDCURRENCYCODEIssueEnum = {
  InvalidCurrencyCode: 'INVALID_CURRENCY_CODE',
} as const;

export type INVALIDCURRENCYCODEIssueEnum =
  (typeof INVALIDCURRENCYCODEIssueEnum)[keyof typeof INVALIDCURRENCYCODEIssueEnum];
export const INVALIDCURRENCYCODEDescriptionEnum = {
  CurrencyCodeIsInvalidOrIsNotCurrentlySupportedPleaseReferHttpsDeveloperPaypalComDocsApiReferenceCurrencyCodesForListOfSupportedCurrencyCodes:
    'Currency code is invalid or is not currently supported. Please refer https://developer.paypal.com/docs/api/reference/currency-codes/ for list of supported currency codes.',
} as const;

export type INVALIDCURRENCYCODEDescriptionEnum =
  (typeof INVALIDCURRENCYCODEDescriptionEnum)[keyof typeof INVALIDCURRENCYCODEDescriptionEnum];

/**
 *
 * @export
 * @interface INVALIDCURRENCYCODE1
 */
export interface INVALIDCURRENCYCODE1 {
  /**
   *
   * @type {string}
   * @memberof INVALIDCURRENCYCODE1
   */
  issue?: INVALIDCURRENCYCODE1IssueEnum;
  /**
   *
   * @type {string}
   * @memberof INVALIDCURRENCYCODE1
   */
  description?: string;
}

export const INVALIDCURRENCYCODE1IssueEnum = {
  InvalidCurrencyCode: 'INVALID_CURRENCY_CODE',
} as const;

export type INVALIDCURRENCYCODE1IssueEnum =
  (typeof INVALIDCURRENCYCODE1IssueEnum)[keyof typeof INVALIDCURRENCYCODE1IssueEnum];

/**
 *
 * @export
 * @interface INVALIDPARAMETERSYNTAX
 */
export interface INVALIDPARAMETERSYNTAX {
  /**
   *
   * @type {string}
   * @memberof INVALIDPARAMETERSYNTAX
   */
  issue?: INVALIDPARAMETERSYNTAXIssueEnum;
  /**
   *
   * @type {string}
   * @memberof INVALIDPARAMETERSYNTAX
   */
  description?: INVALIDPARAMETERSYNTAXDescriptionEnum;
}

export const INVALIDPARAMETERSYNTAXIssueEnum = {
  InvalidParameterSyntax: 'INVALID_PARAMETER_SYNTAX',
} as const;

export type INVALIDPARAMETERSYNTAXIssueEnum =
  (typeof INVALIDPARAMETERSYNTAXIssueEnum)[keyof typeof INVALIDPARAMETERSYNTAXIssueEnum];
export const INVALIDPARAMETERSYNTAXDescriptionEnum = {
  TheValueOfAFieldDoesNotConformToTheExpectedFormat:
    'The value of a field does not conform to the expected format.',
} as const;

export type INVALIDPARAMETERSYNTAXDescriptionEnum =
  (typeof INVALIDPARAMETERSYNTAXDescriptionEnum)[keyof typeof INVALIDPARAMETERSYNTAXDescriptionEnum];

/**
 *
 * @export
 * @interface INVALIDPARAMETERSYNTAX1
 */
export interface INVALIDPARAMETERSYNTAX1 {
  /**
   *
   * @type {string}
   * @memberof INVALIDPARAMETERSYNTAX1
   */
  issue?: INVALIDPARAMETERSYNTAX1IssueEnum;
  /**
   *
   * @type {string}
   * @memberof INVALIDPARAMETERSYNTAX1
   */
  description?: string;
}

export const INVALIDPARAMETERSYNTAX1IssueEnum = {
  InvalidParameterSyntax: 'INVALID_PARAMETER_SYNTAX',
} as const;

export type INVALIDPARAMETERSYNTAX1IssueEnum =
  (typeof INVALIDPARAMETERSYNTAX1IssueEnum)[keyof typeof INVALIDPARAMETERSYNTAX1IssueEnum];

/**
 *
 * @export
 * @interface INVALIDPARAMETERVALUE
 */
export interface INVALIDPARAMETERVALUE {
  /**
   *
   * @type {string}
   * @memberof INVALIDPARAMETERVALUE
   */
  issue?: INVALIDPARAMETERVALUEIssueEnum;
  /**
   *
   * @type {string}
   * @memberof INVALIDPARAMETERVALUE
   */
  description?: INVALIDPARAMETERVALUEDescriptionEnum;
}

export const INVALIDPARAMETERVALUEIssueEnum = {
  InvalidParameterValue: 'INVALID_PARAMETER_VALUE',
} as const;

export type INVALIDPARAMETERVALUEIssueEnum =
  (typeof INVALIDPARAMETERVALUEIssueEnum)[keyof typeof INVALIDPARAMETERVALUEIssueEnum];
export const INVALIDPARAMETERVALUEDescriptionEnum = {
  TheValueOfAFieldIsInvalid: 'The value of a field is invalid.',
} as const;

export type INVALIDPARAMETERVALUEDescriptionEnum =
  (typeof INVALIDPARAMETERVALUEDescriptionEnum)[keyof typeof INVALIDPARAMETERVALUEDescriptionEnum];

/**
 *
 * @export
 * @interface INVALIDRESOURCEID
 */
export interface INVALIDRESOURCEID {
  /**
   *
   * @type {string}
   * @memberof INVALIDRESOURCEID
   */
  issue?: INVALIDRESOURCEIDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof INVALIDRESOURCEID
   */
  description?: INVALIDRESOURCEIDDescriptionEnum;
}

export const INVALIDRESOURCEIDIssueEnum = {
  InvalidResourceId: 'INVALID_RESOURCE_ID',
} as const;

export type INVALIDRESOURCEIDIssueEnum =
  (typeof INVALIDRESOURCEIDIssueEnum)[keyof typeof INVALIDRESOURCEIDIssueEnum];
export const INVALIDRESOURCEIDDescriptionEnum = {
  SpecifiedResourceIdDoesNotExistPleaseCheckTheResourceIdAndTryAgain:
    'Specified resource ID does not exist. Please check the resource ID and try again.',
} as const;

export type INVALIDRESOURCEIDDescriptionEnum =
  (typeof INVALIDRESOURCEIDDescriptionEnum)[keyof typeof INVALIDRESOURCEIDDescriptionEnum];

/**
 *
 * @export
 * @interface INVALIDSTRINGLENGTH
 */
export interface INVALIDSTRINGLENGTH {
  /**
   *
   * @type {string}
   * @memberof INVALIDSTRINGLENGTH
   */
  issue?: INVALIDSTRINGLENGTHIssueEnum;
  /**
   *
   * @type {string}
   * @memberof INVALIDSTRINGLENGTH
   */
  description?: INVALIDSTRINGLENGTHDescriptionEnum;
}

export const INVALIDSTRINGLENGTHIssueEnum = {
  InvalidStringLength: 'INVALID_STRING_LENGTH',
} as const;

export type INVALIDSTRINGLENGTHIssueEnum =
  (typeof INVALIDSTRINGLENGTHIssueEnum)[keyof typeof INVALIDSTRINGLENGTHIssueEnum];
export const INVALIDSTRINGLENGTHDescriptionEnum = {
  TheValueOfAFieldIsEitherTooShortOrTooLong:
    'The value of a field is either too short or too long.',
} as const;

export type INVALIDSTRINGLENGTHDescriptionEnum =
  (typeof INVALIDSTRINGLENGTHDescriptionEnum)[keyof typeof INVALIDSTRINGLENGTHDescriptionEnum];

/**
 *
 * @export
 * @interface INVALIDSTRINGLENGTH1
 */
export interface INVALIDSTRINGLENGTH1 {
  /**
   *
   * @type {string}
   * @memberof INVALIDSTRINGLENGTH1
   */
  issue?: INVALIDSTRINGLENGTH1IssueEnum;
  /**
   *
   * @type {string}
   * @memberof INVALIDSTRINGLENGTH1
   */
  description?: string;
}

export const INVALIDSTRINGLENGTH1IssueEnum = {
  InvalidStringLength: 'INVALID_STRING_LENGTH',
} as const;

export type INVALIDSTRINGLENGTH1IssueEnum =
  (typeof INVALIDSTRINGLENGTH1IssueEnum)[keyof typeof INVALIDSTRINGLENGTH1IssueEnum];

/**
 *
 * @export
 * @interface INVALIDSTRINGMAXLENGTH
 */
export interface INVALIDSTRINGMAXLENGTH {
  /**
   *
   * @type {string}
   * @memberof INVALIDSTRINGMAXLENGTH
   */
  issue?: INVALIDSTRINGMAXLENGTHIssueEnum;
  /**
   *
   * @type {string}
   * @memberof INVALIDSTRINGMAXLENGTH
   */
  description?: INVALIDSTRINGMAXLENGTHDescriptionEnum;
}

export const INVALIDSTRINGMAXLENGTHIssueEnum = {
  InvalidStringMaxLength: 'INVALID_STRING_MAX_LENGTH',
} as const;

export type INVALIDSTRINGMAXLENGTHIssueEnum =
  (typeof INVALIDSTRINGMAXLENGTHIssueEnum)[keyof typeof INVALIDSTRINGMAXLENGTHIssueEnum];
export const INVALIDSTRINGMAXLENGTHDescriptionEnum = {
  TheValueOfAFieldIsTooLong: 'The value of a field is too long.',
} as const;

export type INVALIDSTRINGMAXLENGTHDescriptionEnum =
  (typeof INVALIDSTRINGMAXLENGTHDescriptionEnum)[keyof typeof INVALIDSTRINGMAXLENGTHDescriptionEnum];

/**
 * The request-related [HATEOAS link](/api/rest/responses/#hateoas-links) information.
 * @export
 * @interface LinkDescription
 */
export interface LinkDescription {
  /**
   * The complete target URL. To make the related call, combine the method with this [URI Template-formatted](https://tools.ietf.org/html/rfc6570) link. For pre-processing, include the `$`, `(`, and `)` characters. The `href` is the key HATEOAS component that links a completed call with a subsequent call.
   * @type {string}
   * @memberof LinkDescription
   */
  href: string;
  /**
   * The [link relation type](https://tools.ietf.org/html/rfc5988#section-4), which serves as an ID for a link that unambiguously describes the semantics of the link. See [Link Relations](https://www.iana.org/assignments/link-relations/link-relations.xhtml).
   * @type {string}
   * @memberof LinkDescription
   */
  rel: string;
  /**
   * The HTTP method required to make the related call.
   * @type {string}
   * @memberof LinkDescription
   */
  method?: LinkDescriptionMethodEnum;
}

export const LinkDescriptionMethodEnum = {
  Get: 'GET',
  Post: 'POST',
  Put: 'PUT',
  Delete: 'DELETE',
  Head: 'HEAD',
  Connect: 'CONNECT',
  Options: 'OPTIONS',
  Patch: 'PATCH',
} as const;

export type LinkDescriptionMethodEnum =
  (typeof LinkDescriptionMethodEnum)[keyof typeof LinkDescriptionMethodEnum];

/**
 *
 * @export
 * @interface MAXCAPTUREAMOUNTEXCEEDED
 */
export interface MAXCAPTUREAMOUNTEXCEEDED {
  /**
   *
   * @type {string}
   * @memberof MAXCAPTUREAMOUNTEXCEEDED
   */
  issue?: MAXCAPTUREAMOUNTEXCEEDEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof MAXCAPTUREAMOUNTEXCEEDED
   */
  description?: MAXCAPTUREAMOUNTEXCEEDEDDescriptionEnum;
}

export const MAXCAPTUREAMOUNTEXCEEDEDIssueEnum = {
  MaxCaptureAmountExceeded: 'MAX_CAPTURE_AMOUNT_EXCEEDED',
} as const;

export type MAXCAPTUREAMOUNTEXCEEDEDIssueEnum =
  (typeof MAXCAPTUREAMOUNTEXCEEDEDIssueEnum)[keyof typeof MAXCAPTUREAMOUNTEXCEEDEDIssueEnum];
export const MAXCAPTUREAMOUNTEXCEEDEDDescriptionEnum = {
  CaptureAmountExceedsAllowableLimitPleaseContactCustomerServiceOrYourAccountManagerToRequestTheChangeToYourOverageLimitTheDefaultOverageLimitIs115WhichAllowsTheSumOfAllCapturesToBeUpTo115OfTheOrderAmountTheAbilityToOverCaptureIsSubjectedToRegulatoryApprovals:
    'Capture amount exceeds allowable limit. Please contact customer service or your account manager to request the change to your overage limit. The default overage limit is 115%, which allows the sum of all captures to be up to 115% of the order amount. The ability to over capture is subjected to regulatory approvals.',
} as const;

export type MAXCAPTUREAMOUNTEXCEEDEDDescriptionEnum =
  (typeof MAXCAPTUREAMOUNTEXCEEDEDDescriptionEnum)[keyof typeof MAXCAPTUREAMOUNTEXCEEDEDDescriptionEnum];

/**
 *
 * @export
 * @interface MAXCAPTURECOUNTEXCEEDED
 */
export interface MAXCAPTURECOUNTEXCEEDED {
  /**
   *
   * @type {string}
   * @memberof MAXCAPTURECOUNTEXCEEDED
   */
  issue?: MAXCAPTURECOUNTEXCEEDEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof MAXCAPTURECOUNTEXCEEDED
   */
  description?: MAXCAPTURECOUNTEXCEEDEDDescriptionEnum;
}

export const MAXCAPTURECOUNTEXCEEDEDIssueEnum = {
  MaxCaptureCountExceeded: 'MAX_CAPTURE_COUNT_EXCEEDED',
} as const;

export type MAXCAPTURECOUNTEXCEEDEDIssueEnum =
  (typeof MAXCAPTURECOUNTEXCEEDEDIssueEnum)[keyof typeof MAXCAPTURECOUNTEXCEEDEDIssueEnum];
export const MAXCAPTURECOUNTEXCEEDEDDescriptionEnum = {
  MaxmimumNumberOfAllowableCapturesHasBeenReachedNoAdditionalCapturesArePossibleForThisAuthorizationContactCustomerServiceOrYourAccountManagerToChangeTheNumberOfCapturesForAGivenAuthorization:
    'Maxmimum number of allowable captures has been reached. No additional captures are possible for this authorization. Contact Customer Service or your account manager to change the number of captures for a given authorization.',
} as const;

export type MAXCAPTURECOUNTEXCEEDEDDescriptionEnum =
  (typeof MAXCAPTURECOUNTEXCEEDEDDescriptionEnum)[keyof typeof MAXCAPTURECOUNTEXCEEDEDDescriptionEnum];

/**
 *
 * @export
 * @interface MAXNUMBEROFREFUNDSEXCEEDED
 */
export interface MAXNUMBEROFREFUNDSEXCEEDED {
  /**
   *
   * @type {string}
   * @memberof MAXNUMBEROFREFUNDSEXCEEDED
   */
  issue?: MAXNUMBEROFREFUNDSEXCEEDEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof MAXNUMBEROFREFUNDSEXCEEDED
   */
  description?: MAXNUMBEROFREFUNDSEXCEEDEDDescriptionEnum;
}

export const MAXNUMBEROFREFUNDSEXCEEDEDIssueEnum = {
  MaxNumberOfRefundsExceeded: 'MAX_NUMBER_OF_REFUNDS_EXCEEDED',
} as const;

export type MAXNUMBEROFREFUNDSEXCEEDEDIssueEnum =
  (typeof MAXNUMBEROFREFUNDSEXCEEDEDIssueEnum)[keyof typeof MAXNUMBEROFREFUNDSEXCEEDEDIssueEnum];
export const MAXNUMBEROFREFUNDSEXCEEDEDDescriptionEnum = {
  YouHaveExceededTheMaximumNumberOfRefundAttemptsForThisCapture:
    'You have exceeded the maximum number of refund attempts for this capture.',
} as const;

export type MAXNUMBEROFREFUNDSEXCEEDEDDescriptionEnum =
  (typeof MAXNUMBEROFREFUNDSEXCEEDEDDescriptionEnum)[keyof typeof MAXNUMBEROFREFUNDSEXCEEDEDDescriptionEnum];

/**
 *
 * @export
 * @interface MISSINGREQUIREDPARAMETER
 */
export interface MISSINGREQUIREDPARAMETER {
  /**
   *
   * @type {string}
   * @memberof MISSINGREQUIREDPARAMETER
   */
  issue?: MISSINGREQUIREDPARAMETERIssueEnum;
  /**
   *
   * @type {string}
   * @memberof MISSINGREQUIREDPARAMETER
   */
  description?: MISSINGREQUIREDPARAMETERDescriptionEnum;
}

export const MISSINGREQUIREDPARAMETERIssueEnum = {
  MissingRequiredParameter: 'MISSING_REQUIRED_PARAMETER',
} as const;

export type MISSINGREQUIREDPARAMETERIssueEnum =
  (typeof MISSINGREQUIREDPARAMETERIssueEnum)[keyof typeof MISSINGREQUIREDPARAMETERIssueEnum];
export const MISSINGREQUIREDPARAMETERDescriptionEnum = {
  ARequiredFieldParameterIsMissing: 'A required field / parameter is missing.',
} as const;

export type MISSINGREQUIREDPARAMETERDescriptionEnum =
  (typeof MISSINGREQUIREDPARAMETERDescriptionEnum)[keyof typeof MISSINGREQUIREDPARAMETERDescriptionEnum];

/**
 *
 * @export
 * @interface MISSINGREQUIREDPARAMETER1
 */
export interface MISSINGREQUIREDPARAMETER1 {
  /**
   *
   * @type {string}
   * @memberof MISSINGREQUIREDPARAMETER1
   */
  issue?: MISSINGREQUIREDPARAMETER1IssueEnum;
  /**
   *
   * @type {string}
   * @memberof MISSINGREQUIREDPARAMETER1
   */
  description?: string;
}

export const MISSINGREQUIREDPARAMETER1IssueEnum = {
  MissingRequiredParameter: 'MISSING_REQUIRED_PARAMETER',
} as const;

export type MISSINGREQUIREDPARAMETER1IssueEnum =
  (typeof MISSINGREQUIREDPARAMETER1IssueEnum)[keyof typeof MISSINGREQUIREDPARAMETER1IssueEnum];

/**
 * The breakdown of the refund.
 * @export
 * @interface MerchantPayableBreakdown
 */
export interface MerchantPayableBreakdown {
  /**
   *
   * @type {Money}
   * @memberof MerchantPayableBreakdown
   */
  gross_amount?: Money;
  /**
   *
   * @type {Money}
   * @memberof MerchantPayableBreakdown
   */
  paypal_fee?: Money;
  /**
   *
   * @type {Money}
   * @memberof MerchantPayableBreakdown
   */
  paypal_fee_in_receivable_currency?: Money;
  /**
   *
   * @type {Money}
   * @memberof MerchantPayableBreakdown
   */
  net_amount?: Money;
  /**
   *
   * @type {Money}
   * @memberof MerchantPayableBreakdown
   */
  net_amount_in_receivable_currency?: Money;
  /**
   * An array of platform or partner fees, commissions, or brokerage fees for the refund.
   * @type {Array<PlatformFee>}
   * @memberof MerchantPayableBreakdown
   */
  platform_fees?: Array<PlatformFee>;
  /**
   * An array of breakdown values for the net amount. Returned when the currency of the refund is different from the currency of the PayPal account where the payee holds their funds.
   * @type {Array<NetAmountBreakdownItem>}
   * @memberof MerchantPayableBreakdown
   */
  net_amount_breakdown?: Array<NetAmountBreakdownItem>;
  /**
   *
   * @type {Money}
   * @memberof MerchantPayableBreakdown
   */
  total_refunded_amount?: Money;
}
/**
 *
 * @export
 * @interface Model400
 */
export interface Model400 {
  /**
   *
   * @type {Array<Model400IssuesInner>}
   * @memberof Model400
   */
  issues?: Array<Model400IssuesInner>;
}
/**
 *
 * @export
 * @interface Model400IssuesInner
 */
export interface Model400IssuesInner {
  /**
   *
   * @type {string}
   * @memberof Model400IssuesInner
   */
  issue?: Model400IssuesInnerIssueEnum;
  /**
   *
   * @type {string}
   * @memberof Model400IssuesInner
   */
  description?: Model400IssuesInnerDescriptionEnum;
}

export const Model400IssuesInnerIssueEnum = {
  InvalidParameterSyntax: 'INVALID_PARAMETER_SYNTAX',
} as const;

export type Model400IssuesInnerIssueEnum =
  (typeof Model400IssuesInnerIssueEnum)[keyof typeof Model400IssuesInnerIssueEnum];
export const Model400IssuesInnerDescriptionEnum = {
  TheValueOfAFieldDoesNotConformToTheExpectedFormat:
    'The value of a field does not conform to the expected format.',
} as const;

export type Model400IssuesInnerDescriptionEnum =
  (typeof Model400IssuesInnerDescriptionEnum)[keyof typeof Model400IssuesInnerDescriptionEnum];

/**
 *
 * @export
 * @interface Model401
 */
export interface Model401 {
  /**
   *
   * @type {Array<Model401IssuesInner>}
   * @memberof Model401
   */
  issues?: Array<Model401IssuesInner>;
}
/**
 *
 * @export
 * @interface Model401IssuesInner
 */
export interface Model401IssuesInner {
  /**
   *
   * @type {string}
   * @memberof Model401IssuesInner
   */
  issue?: Model401IssuesInnerIssueEnum;
  /**
   *
   * @type {string}
   * @memberof Model401IssuesInner
   */
  description?: Model401IssuesInnerDescriptionEnum;
}

export const Model401IssuesInnerIssueEnum = {
  InvalidAccountStatus: 'INVALID_ACCOUNT_STATUS',
} as const;

export type Model401IssuesInnerIssueEnum =
  (typeof Model401IssuesInnerIssueEnum)[keyof typeof Model401IssuesInnerIssueEnum];
export const Model401IssuesInnerDescriptionEnum = {
  AccountValidationsFailedForTheUser:
    'Account validations failed for the user.',
} as const;

export type Model401IssuesInnerDescriptionEnum =
  (typeof Model401IssuesInnerDescriptionEnum)[keyof typeof Model401IssuesInnerDescriptionEnum];

/**
 *
 * @export
 * @interface Model403
 */
export interface Model403 {
  /**
   *
   * @type {Array<Model403IssuesInner>}
   * @memberof Model403
   */
  issues?: Array<Model403IssuesInner>;
}
/**
 *
 * @export
 * @interface Model403IssuesInner
 */
export interface Model403IssuesInner {
  /**
   *
   * @type {string}
   * @memberof Model403IssuesInner
   */
  issue?: Model403IssuesInnerIssueEnum;
  /**
   *
   * @type {string}
   * @memberof Model403IssuesInner
   */
  description?: Model403IssuesInnerDescriptionEnum;
}

export const Model403IssuesInnerIssueEnum = {
  PermissionDenied: 'PERMISSION_DENIED',
} as const;

export type Model403IssuesInnerIssueEnum =
  (typeof Model403IssuesInnerIssueEnum)[keyof typeof Model403IssuesInnerIssueEnum];
export const Model403IssuesInnerDescriptionEnum = {
  YouDoNotHavePermissionToAccessOrPerformOperationsOnThisResource:
    'You do not have permission to access or perform operations on this resource.',
} as const;

export type Model403IssuesInnerDescriptionEnum =
  (typeof Model403IssuesInnerDescriptionEnum)[keyof typeof Model403IssuesInnerDescriptionEnum];

/**
 *
 * @export
 * @interface Model404
 */
export interface Model404 {
  /**
   *
   * @type {Array<Model404IssuesInner>}
   * @memberof Model404
   */
  issues?: Array<Model404IssuesInner>;
}
/**
 *
 * @export
 * @interface Model404IssuesInner
 */
export interface Model404IssuesInner {
  /**
   *
   * @type {string}
   * @memberof Model404IssuesInner
   */
  issue?: Model404IssuesInnerIssueEnum;
  /**
   *
   * @type {string}
   * @memberof Model404IssuesInner
   */
  description?: Model404IssuesInnerDescriptionEnum;
}

export const Model404IssuesInnerIssueEnum = {
  InvalidResourceId: 'INVALID_RESOURCE_ID',
} as const;

export type Model404IssuesInnerIssueEnum =
  (typeof Model404IssuesInnerIssueEnum)[keyof typeof Model404IssuesInnerIssueEnum];
export const Model404IssuesInnerDescriptionEnum = {
  SpecifiedResourceIdDoesNotExistPleaseCheckTheResourceIdAndTryAgain:
    'Specified resource ID does not exist. Please check the resource ID and try again.',
} as const;

export type Model404IssuesInnerDescriptionEnum =
  (typeof Model404IssuesInnerDescriptionEnum)[keyof typeof Model404IssuesInnerDescriptionEnum];

/**
 *
 * @export
 * @interface Model409
 */
export interface Model409 {
  /**
   *
   * @type {Array<Model409IssuesInner>}
   * @memberof Model409
   */
  issues?: Array<Model409IssuesInner>;
}
/**
 *
 * @export
 * @interface Model409IssuesInner
 */
export interface Model409IssuesInner {
  /**
   *
   * @type {string}
   * @memberof Model409IssuesInner
   */
  issue?: Model409IssuesInnerIssueEnum;
  /**
   *
   * @type {string}
   * @memberof Model409IssuesInner
   */
  description?: Model409IssuesInnerDescriptionEnum;
}

export const Model409IssuesInnerIssueEnum = {
  PreviousRequestInProgress: 'PREVIOUS_REQUEST_IN_PROGRESS',
} as const;

export type Model409IssuesInnerIssueEnum =
  (typeof Model409IssuesInnerIssueEnum)[keyof typeof Model409IssuesInnerIssueEnum];
export const Model409IssuesInnerDescriptionEnum = {
  APreviousRequestOnThisResourceIsCurrentlyInProgressPleaseWaitForSometimeAndTryAgainItIsBestToSpaceOutTheInitialAndTheSubsequentRequestSToAvoidReceivingThisError:
    'A previous request on this resource is currently in progress. Please wait for sometime and try again. It is best to space out the initial and the subsequent request(s) to avoid receiving this error.',
} as const;

export type Model409IssuesInnerDescriptionEnum =
  (typeof Model409IssuesInnerDescriptionEnum)[keyof typeof Model409IssuesInnerDescriptionEnum];

/**
 *
 * @export
 * @interface Model422
 */
export interface Model422 {
  /**
   *
   * @type {Array<Model422IssuesInner>}
   * @memberof Model422
   */
  issues?: Array<Model422IssuesInner>;
}
/**
 *
 * @export
 * @interface Model422IssuesInner
 */
export interface Model422IssuesInner {
  /**
   *
   * @type {string}
   * @memberof Model422IssuesInner
   */
  issue?: Model422IssuesInnerIssueEnum;
  /**
   *
   * @type {string}
   * @memberof Model422IssuesInner
   */
  description?: Model422IssuesInnerDescriptionEnum;
}

export const Model422IssuesInnerIssueEnum = {
  PayeeAccountRestricted: 'PAYEE_ACCOUNT_RESTRICTED',
} as const;

export type Model422IssuesInnerIssueEnum =
  (typeof Model422IssuesInnerIssueEnum)[keyof typeof Model422IssuesInnerIssueEnum];
export const Model422IssuesInnerDescriptionEnum = {
  PayeeAccountIsRestricted: 'Payee account is restricted.',
} as const;

export type Model422IssuesInnerDescriptionEnum =
  (typeof Model422IssuesInnerDescriptionEnum)[keyof typeof Model422IssuesInnerDescriptionEnum];

/**
 * The currency and amount for a financial transaction, such as a balance or payment due.
 * @export
 * @interface Money
 */
export interface Money {
  /**
   * The [three-character ISO-4217 currency code](/api/rest/reference/currency-codes/) that identifies the currency.
   * @type {string}
   * @memberof Money
   */
  currency_code: string;
  /**
   * The value, which might be:<ul><li>An integer for currencies like `JPY` that are not typically fractional.</li><li>A decimal fraction for currencies like `TND` that are subdivided into thousandths.</li></ul>For the required number of decimal places for a currency code, see [Currency Codes](/api/rest/reference/currency-codes/).
   * @type {string}
   * @memberof Money
   */
  value: string;
}
/**
 * The net amount. Returned when the currency of the refund is different from the currency of the PayPal account where the merchant holds their funds.
 * @export
 * @interface NetAmountBreakdownItem
 */
export interface NetAmountBreakdownItem {
  /**
   *
   * @type {Money}
   * @memberof NetAmountBreakdownItem
   */
  payable_amount?: Money;
  /**
   *
   * @type {Money}
   * @memberof NetAmountBreakdownItem
   */
  converted_amount?: Money;
  /**
   *
   * @type {ExchangeRate}
   * @memberof NetAmountBreakdownItem
   */
  exchange_rate?: ExchangeRate;
}
/**
 * Reference values used by the card network to identify a transaction.
 * @export
 * @interface NetworkTransactionReference
 */
export interface NetworkTransactionReference {
  /**
   * Transaction reference id returned by the scheme. For Visa and Amex, this is the \"Tran id\" field in response. For MasterCard, this is the \"BankNet reference id\" field in response. For Discover, this is the \"NRID\" field in response. The pattern we expect for this field from Visa/Amex/CB/Discover is numeric, Mastercard/BNPP is alphanumeric and Paysecure is alphanumeric with special character -.
   * @type {string}
   * @memberof NetworkTransactionReference
   */
  id: string;
  /**
   * The date that the transaction was authorized by the scheme. This field may not be returned for all networks. MasterCard refers to this field as \"BankNet reference date.
   * @type {string}
   * @memberof NetworkTransactionReference
   */
  date?: string;
  /**
   *
   * @type {CardBrand}
   * @memberof NetworkTransactionReference
   */
  network?: CardBrand;
  /**
   * Reference ID issued for the card transaction. This ID can be used to track the transaction across processors, card brands and issuing banks.
   * @type {string}
   * @memberof NetworkTransactionReference
   */
  acquirer_reference_number?: string;
}

/**
 *
 * @export
 * @interface PARTIALREFUNDNOTALLOWED
 */
export interface PARTIALREFUNDNOTALLOWED {
  /**
   *
   * @type {string}
   * @memberof PARTIALREFUNDNOTALLOWED
   */
  issue?: PARTIALREFUNDNOTALLOWEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof PARTIALREFUNDNOTALLOWED
   */
  description?: PARTIALREFUNDNOTALLOWEDDescriptionEnum;
}

export const PARTIALREFUNDNOTALLOWEDIssueEnum = {
  PartialRefundNotAllowed: 'PARTIAL_REFUND_NOT_ALLOWED',
} as const;

export type PARTIALREFUNDNOTALLOWEDIssueEnum =
  (typeof PARTIALREFUNDNOTALLOWEDIssueEnum)[keyof typeof PARTIALREFUNDNOTALLOWEDIssueEnum];
export const PARTIALREFUNDNOTALLOWEDDescriptionEnum = {
  YouCannotDoARefundLessThanTheOriginalCaptureAmount:
    'You cannot do a refund less than the original capture amount.',
} as const;

export type PARTIALREFUNDNOTALLOWEDDescriptionEnum =
  (typeof PARTIALREFUNDNOTALLOWEDDescriptionEnum)[keyof typeof PARTIALREFUNDNOTALLOWEDDescriptionEnum];

/**
 *
 * @export
 * @interface PAYEEACCOUNTLOCKEDORCLOSED
 */
export interface PAYEEACCOUNTLOCKEDORCLOSED {
  /**
   *
   * @type {string}
   * @memberof PAYEEACCOUNTLOCKEDORCLOSED
   */
  issue?: PAYEEACCOUNTLOCKEDORCLOSEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof PAYEEACCOUNTLOCKEDORCLOSED
   */
  description?: PAYEEACCOUNTLOCKEDORCLOSEDDescriptionEnum;
}

export const PAYEEACCOUNTLOCKEDORCLOSEDIssueEnum = {
  PayeeAccountLockedOrClosed: 'PAYEE_ACCOUNT_LOCKED_OR_CLOSED',
} as const;

export type PAYEEACCOUNTLOCKEDORCLOSEDIssueEnum =
  (typeof PAYEEACCOUNTLOCKEDORCLOSEDIssueEnum)[keyof typeof PAYEEACCOUNTLOCKEDORCLOSEDIssueEnum];
export const PAYEEACCOUNTLOCKEDORCLOSEDDescriptionEnum = {
  TransactionCouldNotCompleteBecausePayeeAccountIsLockedOrClosed:
    'Transaction could not complete because payee account is locked or closed.',
} as const;

export type PAYEEACCOUNTLOCKEDORCLOSEDDescriptionEnum =
  (typeof PAYEEACCOUNTLOCKEDORCLOSEDDescriptionEnum)[keyof typeof PAYEEACCOUNTLOCKEDORCLOSEDDescriptionEnum];

/**
 *
 * @export
 * @interface PAYEEACCOUNTRESTRICTED
 */
export interface PAYEEACCOUNTRESTRICTED {
  /**
   *
   * @type {string}
   * @memberof PAYEEACCOUNTRESTRICTED
   */
  issue?: PAYEEACCOUNTRESTRICTEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof PAYEEACCOUNTRESTRICTED
   */
  description?: PAYEEACCOUNTRESTRICTEDDescriptionEnum;
}

export const PAYEEACCOUNTRESTRICTEDIssueEnum = {
  PayeeAccountRestricted: 'PAYEE_ACCOUNT_RESTRICTED',
} as const;

export type PAYEEACCOUNTRESTRICTEDIssueEnum =
  (typeof PAYEEACCOUNTRESTRICTEDIssueEnum)[keyof typeof PAYEEACCOUNTRESTRICTEDIssueEnum];
export const PAYEEACCOUNTRESTRICTEDDescriptionEnum = {
  PayeeAccountIsRestricted: 'Payee account is restricted.',
} as const;

export type PAYEEACCOUNTRESTRICTEDDescriptionEnum =
  (typeof PAYEEACCOUNTRESTRICTEDDescriptionEnum)[keyof typeof PAYEEACCOUNTRESTRICTEDDescriptionEnum];

/**
 *
 * @export
 * @interface PAYERACCOUNTLOCKEDORCLOSED
 */
export interface PAYERACCOUNTLOCKEDORCLOSED {
  /**
   *
   * @type {string}
   * @memberof PAYERACCOUNTLOCKEDORCLOSED
   */
  issue?: PAYERACCOUNTLOCKEDORCLOSEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof PAYERACCOUNTLOCKEDORCLOSED
   */
  description?: PAYERACCOUNTLOCKEDORCLOSEDDescriptionEnum;
}

export const PAYERACCOUNTLOCKEDORCLOSEDIssueEnum = {
  PayerAccountLockedOrClosed: 'PAYER_ACCOUNT_LOCKED_OR_CLOSED',
} as const;

export type PAYERACCOUNTLOCKEDORCLOSEDIssueEnum =
  (typeof PAYERACCOUNTLOCKEDORCLOSEDIssueEnum)[keyof typeof PAYERACCOUNTLOCKEDORCLOSEDIssueEnum];
export const PAYERACCOUNTLOCKEDORCLOSEDDescriptionEnum = {
  ThePayerAccountCannotBeUsedForThisTransaction:
    'The payer account cannot be used for this transaction.',
} as const;

export type PAYERACCOUNTLOCKEDORCLOSEDDescriptionEnum =
  (typeof PAYERACCOUNTLOCKEDORCLOSEDDescriptionEnum)[keyof typeof PAYERACCOUNTLOCKEDORCLOSEDDescriptionEnum];

/**
 *
 * @export
 * @interface PAYERCANNOTPAY
 */
export interface PAYERCANNOTPAY {
  /**
   *
   * @type {string}
   * @memberof PAYERCANNOTPAY
   */
  issue?: PAYERCANNOTPAYIssueEnum;
  /**
   *
   * @type {string}
   * @memberof PAYERCANNOTPAY
   */
  description?: PAYERCANNOTPAYDescriptionEnum;
}

export const PAYERCANNOTPAYIssueEnum = {
  PayerCannotPay: 'PAYER_CANNOT_PAY',
} as const;

export type PAYERCANNOTPAYIssueEnum =
  (typeof PAYERCANNOTPAYIssueEnum)[keyof typeof PAYERCANNOTPAYIssueEnum];
export const PAYERCANNOTPAYDescriptionEnum = {
  PayerCannotPayForThisTransactionPleaseContactThePayerToFindOtherWaysToPayForThisTransaction:
    'Payer cannot pay for this transaction. Please contact the payer to find other ways to pay for this transaction.',
} as const;

export type PAYERCANNOTPAYDescriptionEnum =
  (typeof PAYERCANNOTPAYDescriptionEnum)[keyof typeof PAYERCANNOTPAYDescriptionEnum];

/**
 *
 * @export
 * @interface PENDINGCAPTURE
 */
export interface PENDINGCAPTURE {
  /**
   *
   * @type {string}
   * @memberof PENDINGCAPTURE
   */
  issue?: PENDINGCAPTUREIssueEnum;
  /**
   *
   * @type {string}
   * @memberof PENDINGCAPTURE
   */
  description?: PENDINGCAPTUREDescriptionEnum;
}

export const PENDINGCAPTUREIssueEnum = {
  PendingCapture: 'PENDING_CAPTURE',
} as const;

export type PENDINGCAPTUREIssueEnum =
  (typeof PENDINGCAPTUREIssueEnum)[keyof typeof PENDINGCAPTUREIssueEnum];
export const PENDINGCAPTUREDescriptionEnum = {
  CannotInitiateARefundAsTheCaptureIsPendingCaptureIsTypicallyPendingWhenThePayerHasFundedTheTransactionUsingECheckBankFunded:
    'Cannot initiate a refund as the capture is pending. Capture is typically pending when the payer has funded the transaction using e-check/bank funded.',
} as const;

export type PENDINGCAPTUREDescriptionEnum =
  (typeof PENDINGCAPTUREDescriptionEnum)[keyof typeof PENDINGCAPTUREDescriptionEnum];

/**
 *
 * @export
 * @interface PERMISSIONDENIED
 */
export interface PERMISSIONDENIED {
  /**
   *
   * @type {string}
   * @memberof PERMISSIONDENIED
   */
  issue?: PERMISSIONDENIEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof PERMISSIONDENIED
   */
  description?: PERMISSIONDENIEDDescriptionEnum;
}

export const PERMISSIONDENIEDIssueEnum = {
  PermissionDenied: 'PERMISSION_DENIED',
} as const;

export type PERMISSIONDENIEDIssueEnum =
  (typeof PERMISSIONDENIEDIssueEnum)[keyof typeof PERMISSIONDENIEDIssueEnum];
export const PERMISSIONDENIEDDescriptionEnum = {
  YouDoNotHavePermissionToAccessOrPerformOperationsOnThisResource:
    'You do not have permission to access or perform operations on this resource.',
} as const;

export type PERMISSIONDENIEDDescriptionEnum =
  (typeof PERMISSIONDENIEDDescriptionEnum)[keyof typeof PERMISSIONDENIEDDescriptionEnum];

/**
 *
 * @export
 * @interface PLATFORMFEEEXCEEDED
 */
export interface PLATFORMFEEEXCEEDED {
  /**
   *
   * @type {string}
   * @memberof PLATFORMFEEEXCEEDED
   */
  issue?: PLATFORMFEEEXCEEDEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof PLATFORMFEEEXCEEDED
   */
  description?: PLATFORMFEEEXCEEDEDDescriptionEnum;
}

export const PLATFORMFEEEXCEEDEDIssueEnum = {
  PlatformFeeExceeded: 'PLATFORM_FEE_EXCEEDED',
} as const;

export type PLATFORMFEEEXCEEDEDIssueEnum =
  (typeof PLATFORMFEEEXCEEDEDIssueEnum)[keyof typeof PLATFORMFEEEXCEEDEDIssueEnum];
export const PLATFORMFEEEXCEEDEDDescriptionEnum = {
  PlatformFeeAmountSpecifiedExceedsTheAmountThatIsAvailableForRefundYouCanOnlyRefundUpToTheAvailablePlatformFeeAmountThisErrorIsAlsoReturnedWhenNoPlatformFeeWasSpecifiedOrWasZeroWhenThePaymentWasCaptured:
    'Platform fee amount specified exceeds the amount that is available for refund. You can only refund up to the available platform fee amount. This error is also returned when no platform_fee was specified or was zero when the payment was captured.',
} as const;

export type PLATFORMFEEEXCEEDEDDescriptionEnum =
  (typeof PLATFORMFEEEXCEEDEDDescriptionEnum)[keyof typeof PLATFORMFEEEXCEEDEDDescriptionEnum];

/**
 *
 * @export
 * @interface PLATFORMFEENOTENABLED
 */
export interface PLATFORMFEENOTENABLED {
  /**
   *
   * @type {string}
   * @memberof PLATFORMFEENOTENABLED
   */
  issue?: PLATFORMFEENOTENABLEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof PLATFORMFEENOTENABLED
   */
  description?: PLATFORMFEENOTENABLEDDescriptionEnum;
}

export const PLATFORMFEENOTENABLEDIssueEnum = {
  PlatformFeeNotEnabled: 'PLATFORM_FEE_NOT_ENABLED',
} as const;

export type PLATFORMFEENOTENABLEDIssueEnum =
  (typeof PLATFORMFEENOTENABLEDIssueEnum)[keyof typeof PLATFORMFEENOTENABLEDIssueEnum];
export const PLATFORMFEENOTENABLEDDescriptionEnum = {
  TheApiCallerAccountIsNotSetupToBeAbleToProcessRefundsWithPlatformFeesPleaseContactYourAccountManagerThisFeatureIsUsefulWhenYouWantToContributeAPortionOfThePlatformFeesYouHadCaptureAsPartOfTheRefundBeingProcessed:
    "The API Caller account is not setup to be able to process refunds with 'platform_fees'. Please contact your Account Manager. This feature is useful when you want to contribute a portion of the 'platform_fees' you had capture as part of the refund being processed.",
} as const;

export type PLATFORMFEENOTENABLEDDescriptionEnum =
  (typeof PLATFORMFEENOTENABLEDDescriptionEnum)[keyof typeof PLATFORMFEENOTENABLEDDescriptionEnum];

/**
 *
 * @export
 * @interface PREVIOUSLYCAPTURED
 */
export interface PREVIOUSLYCAPTURED {
  /**
   *
   * @type {string}
   * @memberof PREVIOUSLYCAPTURED
   */
  issue?: PREVIOUSLYCAPTUREDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof PREVIOUSLYCAPTURED
   */
  description?: PREVIOUSLYCAPTUREDDescriptionEnum;
}

export const PREVIOUSLYCAPTUREDIssueEnum = {
  PreviouslyCaptured: 'PREVIOUSLY_CAPTURED',
} as const;

export type PREVIOUSLYCAPTUREDIssueEnum =
  (typeof PREVIOUSLYCAPTUREDIssueEnum)[keyof typeof PREVIOUSLYCAPTUREDIssueEnum];
export const PREVIOUSLYCAPTUREDDescriptionEnum = {
  AuthorizationHasBeenPreviouslyCapturedAndHenceCannotBeVoided:
    'Authorization has been previously captured and hence cannot be voided.',
} as const;

export type PREVIOUSLYCAPTUREDDescriptionEnum =
  (typeof PREVIOUSLYCAPTUREDDescriptionEnum)[keyof typeof PREVIOUSLYCAPTUREDDescriptionEnum];

/**
 *
 * @export
 * @interface PREVIOUSLYVOIDED
 */
export interface PREVIOUSLYVOIDED {
  /**
   *
   * @type {string}
   * @memberof PREVIOUSLYVOIDED
   */
  issue?: PREVIOUSLYVOIDEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof PREVIOUSLYVOIDED
   */
  description?: PREVIOUSLYVOIDEDDescriptionEnum;
}

export const PREVIOUSLYVOIDEDIssueEnum = {
  PreviouslyVoided: 'PREVIOUSLY_VOIDED',
} as const;

export type PREVIOUSLYVOIDEDIssueEnum =
  (typeof PREVIOUSLYVOIDEDIssueEnum)[keyof typeof PREVIOUSLYVOIDEDIssueEnum];
export const PREVIOUSLYVOIDEDDescriptionEnum = {
  AuthorizationHasBeenPreviouslyVoidedAndHenceCannotBeVoidedAgain:
    'Authorization has been previously voided and hence cannot be voided again.',
} as const;

export type PREVIOUSLYVOIDEDDescriptionEnum =
  (typeof PREVIOUSLYVOIDEDDescriptionEnum)[keyof typeof PREVIOUSLYVOIDEDDescriptionEnum];

/**
 *
 * @export
 * @interface PREVIOUSREQUESTINPROGRESS
 */
export interface PREVIOUSREQUESTINPROGRESS {
  /**
   *
   * @type {string}
   * @memberof PREVIOUSREQUESTINPROGRESS
   */
  issue?: PREVIOUSREQUESTINPROGRESSIssueEnum;
  /**
   *
   * @type {string}
   * @memberof PREVIOUSREQUESTINPROGRESS
   */
  description?: PREVIOUSREQUESTINPROGRESSDescriptionEnum;
}

export const PREVIOUSREQUESTINPROGRESSIssueEnum = {
  PreviousRequestInProgress: 'PREVIOUS_REQUEST_IN_PROGRESS',
} as const;

export type PREVIOUSREQUESTINPROGRESSIssueEnum =
  (typeof PREVIOUSREQUESTINPROGRESSIssueEnum)[keyof typeof PREVIOUSREQUESTINPROGRESSIssueEnum];
export const PREVIOUSREQUESTINPROGRESSDescriptionEnum = {
  APreviousRequestOnThisResourceIsCurrentlyInProgressPleaseWaitForSometimeAndTryAgainItIsBestToSpaceOutTheInitialAndTheSubsequentRequestSToAvoidReceivingThisError:
    'A previous request on this resource is currently in progress. Please wait for sometime and try again. It is best to space out the initial and the subsequent request(s) to avoid receiving this error.',
} as const;

export type PREVIOUSREQUESTINPROGRESSDescriptionEnum =
  (typeof PREVIOUSREQUESTINPROGRESSDescriptionEnum)[keyof typeof PREVIOUSREQUESTINPROGRESSDescriptionEnum];

/**
 * The details for the merchant who receives the funds and fulfills the order. The merchant is also known as the payee.
 * @export
 * @interface PayeeBase
 */
export interface PayeeBase {
  /**
   * The internationalized email address.<blockquote><strong>Note:</strong> Up to 64 characters are allowed before and 255 characters are allowed after the <code>@</code> sign. However, the generally accepted maximum length for an email address is 254 characters. The pattern verifies that an unquoted <code>@</code> sign exists.</blockquote>
   * @type {string}
   * @memberof PayeeBase
   */
  email_address?: string;
  /**
   * The account identifier for a PayPal account.
   * @type {string}
   * @memberof PayeeBase
   */
  merchant_id?: string;
}
/**
 * Any additional payment instructions to be consider during payment processing. This processing instruction is applicable for Capturing an order or Authorizing an Order.
 * @export
 * @interface PaymentInstruction
 */
export interface PaymentInstruction {
  /**
   * An array of various fees, commissions, tips, or donations. This field is only applicable to merchants that been enabled for PayPal Commerce Platform for Marketplaces and Platforms capability.
   * @type {Array<PlatformFee>}
   * @memberof PaymentInstruction
   */
  platform_fees?: Array<PlatformFee>;
  /**
   *
   * @type {DisbursementMode}
   * @memberof PaymentInstruction
   */
  disbursement_mode?: DisbursementMode;
  /**
   * This field is only enabled for selected merchants/partners to use and provides the ability to trigger a specific pricing rate/plan for a payment transaction. The list of eligible \'payee_pricing_tier_id\' would be provided to you by your Account Manager. Specifying values other than the one provided to you by your account manager would result in an error.
   * @type {string}
   * @memberof PaymentInstruction
   */
  payee_pricing_tier_id?: string;
  /**
   * FX identifier generated returned by PayPal to be used for payment processing in order to honor FX rate (for eligible integrations) to be used when amount is settled/received into the payee account.
   * @type {string}
   * @memberof PaymentInstruction
   */
  payee_receivable_fx_rate_id?: string;
}

/**
 * Any additional payments instructions during refund payment processing. This object is only applicable to merchants that have been enabled for PayPal Commerce Platform for Marketplaces and Platforms capability. Please speak to your account manager if you want to use this capability.
 * @export
 * @interface PaymentInstruction2
 */
export interface PaymentInstruction2 {
  /**
   * Specifies the amount that the API caller will contribute to the refund being processed. The amount needs to be lower than platform_fees amount originally captured or the amount that is remaining if multiple refunds have been processed. This field is only applicable to merchants that have been enabled for PayPal Commerce Platform for Marketplaces and Platforms capability. Please speak to your account manager if you want to use this capability.
   * @type {Array<PlatformFee>}
   * @memberof PaymentInstruction2
   */
  platform_fees?: Array<PlatformFee>;
}
/**
 * The platform or partner fee, commission, or brokerage fee that is associated with the transaction. Not a separate or isolated transaction leg from the external perspective. The platform fee is limited in scope and is always associated with the original payment for the purchase unit.
 * @export
 * @interface PlatformFee
 */
export interface PlatformFee {
  /**
   *
   * @type {Money}
   * @memberof PlatformFee
   */
  amount: Money;
  /**
   *
   * @type {PayeeBase}
   * @memberof PlatformFee
   */
  payee?: PayeeBase;
}
/**
 * The processor response information for payment requests, such as direct credit card transactions.
 * @export
 * @interface ProcessorResponse
 */
export interface ProcessorResponse {
  /**
   * The address verification code for Visa, Discover, Mastercard, or American Express transactions.
   * @type {string}
   * @memberof ProcessorResponse
   */
  avs_code?: ProcessorResponseAvsCodeEnum;
  /**
   * The card verification value code for for Visa, Discover, Mastercard, or American Express.
   * @type {string}
   * @memberof ProcessorResponse
   */
  cvv_code?: ProcessorResponseCvvCodeEnum;
  /**
   * Processor response code for the non-PayPal payment processor errors.
   * @type {string}
   * @memberof ProcessorResponse
   */
  response_code?: ProcessorResponseResponseCodeEnum;
  /**
   * The declined payment transactions might have payment advice codes. The card networks, like Visa and Mastercard, return payment advice codes.
   * @type {string}
   * @memberof ProcessorResponse
   */
  payment_advice_code?: ProcessorResponsePaymentAdviceCodeEnum;
}

export const ProcessorResponseAvsCodeEnum = {
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  E: 'E',
  F: 'F',
  G: 'G',
  I: 'I',
  M: 'M',
  N: 'N',
  P: 'P',
  R: 'R',
  S: 'S',
  U: 'U',
  W: 'W',
  X: 'X',
  Y: 'Y',
  Z: 'Z',
  Null: 'Null',
  _0: '0',
  _1: '1',
  _2: '2',
  _3: '3',
  _4: '4',
} as const;

export type ProcessorResponseAvsCodeEnum =
  (typeof ProcessorResponseAvsCodeEnum)[keyof typeof ProcessorResponseAvsCodeEnum];
export const ProcessorResponseCvvCodeEnum = {
  E: 'E',
  I: 'I',
  M: 'M',
  N: 'N',
  P: 'P',
  S: 'S',
  U: 'U',
  X: 'X',
  AllOthers: 'All others',
  _0: '0',
  _1: '1',
  _2: '2',
  _3: '3',
  _4: '4',
} as const;

export type ProcessorResponseCvvCodeEnum =
  (typeof ProcessorResponseCvvCodeEnum)[keyof typeof ProcessorResponseCvvCodeEnum];
export const ProcessorResponseResponseCodeEnum = {
  _0000: '0000',
  _00N7: '00N7',
  _0100: '0100',
  _0390: '0390',
  _0500: '0500',
  _0580: '0580',
  _0800: '0800',
  _0880: '0880',
  _0890: '0890',
  _0960: '0960',
  _0R00: '0R00',
  _1000: '1000',
  _10Br: '10BR',
  _1300: '1300',
  _1310: '1310',
  _1312: '1312',
  _1317: '1317',
  _1320: '1320',
  _1330: '1330',
  _1335: '1335',
  _1340: '1340',
  _1350: '1350',
  _1352: '1352',
  _1360: '1360',
  _1370: '1370',
  _1380: '1380',
  _1382: '1382',
  _1384: '1384',
  _1390: '1390',
  _1393: '1393',
  _5100: '5100',
  _5110: '5110',
  _5120: '5120',
  _5130: '5130',
  _5135: '5135',
  _5140: '5140',
  _5150: '5150',
  _5160: '5160',
  _5170: '5170',
  _5180: '5180',
  _5190: '5190',
  _5200: '5200',
  _5210: '5210',
  _5400: '5400',
  _5500: '5500',
  _5650: '5650',
  _5700: '5700',
  _5710: '5710',
  _5800: '5800',
  _5900: '5900',
  _5910: '5910',
  _5920: '5920',
  _5930: '5930',
  _5950: '5950',
  _6300: '6300',
  _7600: '7600',
  _7700: '7700',
  _7710: '7710',
  _7800: '7800',
  _7900: '7900',
  _8000: '8000',
  _8010: '8010',
  _8020: '8020',
  _8030: '8030',
  _8100: '8100',
  _8110: '8110',
  _8220: '8220',
  _9100: '9100',
  _9500: '9500',
  _9510: '9510',
  _9520: '9520',
  _9530: '9530',
  _9540: '9540',
  _9600: '9600',
  Pcnr: 'PCNR',
  Pcvv: 'PCVV',
  Pp06: 'PP06',
  Pprn: 'PPRN',
  Ppad: 'PPAD',
  Ppab: 'PPAB',
  Ppae: 'PPAE',
  Ppag: 'PPAG',
  Ppai: 'PPAI',
  Ppar: 'PPAR',
  Ppau: 'PPAU',
  Ppav: 'PPAV',
  Ppax: 'PPAX',
  Ppbg: 'PPBG',
  Ppc2: 'PPC2',
  Ppce: 'PPCE',
  Ppco: 'PPCO',
  Ppcr: 'PPCR',
  Ppct: 'PPCT',
  Ppcu: 'PPCU',
  Ppd3: 'PPD3',
  Ppdc: 'PPDC',
  Ppdi: 'PPDI',
  Ppdv: 'PPDV',
  Ppdt: 'PPDT',
  Ppef: 'PPEF',
  Ppel: 'PPEL',
  Pper: 'PPER',
  Ppex: 'PPEX',
  Ppfe: 'PPFE',
  Ppfi: 'PPFI',
  Ppfr: 'PPFR',
  Ppfv: 'PPFV',
  Ppgr: 'PPGR',
  Pph1: 'PPH1',
  Ppif: 'PPIF',
  Ppii: 'PPII',
  Ppim: 'PPIM',
  Ppit: 'PPIT',
  Pplr: 'PPLR',
  Ppls: 'PPLS',
  Ppmb: 'PPMB',
  Ppmc: 'PPMC',
  Ppmd: 'PPMD',
  Ppnc: 'PPNC',
  Ppnl: 'PPNL',
  Ppnm: 'PPNM',
  Ppnt: 'PPNT',
  Ppph: 'PPPH',
  Pppi: 'PPPI',
  Pppm: 'PPPM',
  Ppqc: 'PPQC',
  Ppre: 'PPRE',
  Pprf: 'PPRF',
  Pprr: 'PPRR',
  Pps0: 'PPS0',
  Pps1: 'PPS1',
  Pps2: 'PPS2',
  Pps3: 'PPS3',
  Pps4: 'PPS4',
  Pps5: 'PPS5',
  Pps6: 'PPS6',
  Ppsc: 'PPSC',
  Ppsd: 'PPSD',
  Ppse: 'PPSE',
  Ppte: 'PPTE',
  Pptf: 'PPTF',
  Ppti: 'PPTI',
  Pptr: 'PPTR',
  Pptt: 'PPTT',
  Pptv: 'PPTV',
  Ppua: 'PPUA',
  Ppuc: 'PPUC',
  Ppue: 'PPUE',
  Ppui: 'PPUI',
  Ppup: 'PPUP',
  Ppur: 'PPUR',
  Ppvc: 'PPVC',
  Ppve: 'PPVE',
  Ppvt: 'PPVT',
} as const;

export type ProcessorResponseResponseCodeEnum =
  (typeof ProcessorResponseResponseCodeEnum)[keyof typeof ProcessorResponseResponseCodeEnum];
export const ProcessorResponsePaymentAdviceCodeEnum = {
  _01: '01',
  _02: '02',
  _03: '03',
  _21: '21',
} as const;

export type ProcessorResponsePaymentAdviceCodeEnum =
  (typeof ProcessorResponsePaymentAdviceCodeEnum)[keyof typeof ProcessorResponsePaymentAdviceCodeEnum];

/**
 *
 * @export
 * @interface REAUTHORIZATIONNOTSUPPORTED
 */
export interface REAUTHORIZATIONNOTSUPPORTED {
  /**
   *
   * @type {string}
   * @memberof REAUTHORIZATIONNOTSUPPORTED
   */
  issue?: REAUTHORIZATIONNOTSUPPORTEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof REAUTHORIZATIONNOTSUPPORTED
   */
  description?: REAUTHORIZATIONNOTSUPPORTEDDescriptionEnum;
}

export const REAUTHORIZATIONNOTSUPPORTEDIssueEnum = {
  ReauthorizationNotSupported: 'REAUTHORIZATION_NOT_SUPPORTED',
} as const;

export type REAUTHORIZATIONNOTSUPPORTEDIssueEnum =
  (typeof REAUTHORIZATIONNOTSUPPORTEDIssueEnum)[keyof typeof REAUTHORIZATIONNOTSUPPORTEDIssueEnum];
export const REAUTHORIZATIONNOTSUPPORTEDDescriptionEnum = {
  AReauthorizeCannotBeAttemptedOnAnAuthorizationIdThatIsTheResultOfAPriorReauthorizationOrOnAnAuthorizationMadeOnAnOrderSavedUsingTheV2OrdersIdSaveApi:
    'A reauthorize cannot be attempted on an authorization_id that is the result of a prior reauthorization or on an authorization made on an Order saved using the `v2/orders/id/save` API.',
} as const;

export type REAUTHORIZATIONNOTSUPPORTEDDescriptionEnum =
  (typeof REAUTHORIZATIONNOTSUPPORTEDDescriptionEnum)[keyof typeof REAUTHORIZATIONNOTSUPPORTEDDescriptionEnum];

/**
 *
 * @export
 * @interface REFUNDAMOUNTEXCEEDED
 */
export interface REFUNDAMOUNTEXCEEDED {
  /**
   *
   * @type {string}
   * @memberof REFUNDAMOUNTEXCEEDED
   */
  issue?: REFUNDAMOUNTEXCEEDEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof REFUNDAMOUNTEXCEEDED
   */
  description?: REFUNDAMOUNTEXCEEDEDDescriptionEnum;
}

export const REFUNDAMOUNTEXCEEDEDIssueEnum = {
  RefundAmountExceeded: 'REFUND_AMOUNT_EXCEEDED',
} as const;

export type REFUNDAMOUNTEXCEEDEDIssueEnum =
  (typeof REFUNDAMOUNTEXCEEDEDIssueEnum)[keyof typeof REFUNDAMOUNTEXCEEDEDIssueEnum];
export const REFUNDAMOUNTEXCEEDEDDescriptionEnum = {
  TheRefundAmountMustBeLessThanOrEqualToTheCaptureAmountThatHasNotYetBeenRefunded:
    'The refund amount must be less than or equal to the capture amount that has not yet been refunded.',
} as const;

export type REFUNDAMOUNTEXCEEDEDDescriptionEnum =
  (typeof REFUNDAMOUNTEXCEEDEDDescriptionEnum)[keyof typeof REFUNDAMOUNTEXCEEDEDDescriptionEnum];

/**
 *
 * @export
 * @interface REFUNDAMOUNTTOOLOW
 */
export interface REFUNDAMOUNTTOOLOW {
  /**
   *
   * @type {string}
   * @memberof REFUNDAMOUNTTOOLOW
   */
  issue?: REFUNDAMOUNTTOOLOWIssueEnum;
  /**
   *
   * @type {string}
   * @memberof REFUNDAMOUNTTOOLOW
   */
  description?: REFUNDAMOUNTTOOLOWDescriptionEnum;
}

export const REFUNDAMOUNTTOOLOWIssueEnum = {
  RefundAmountTooLow: 'REFUND_AMOUNT_TOO_LOW',
} as const;

export type REFUNDAMOUNTTOOLOWIssueEnum =
  (typeof REFUNDAMOUNTTOOLOWIssueEnum)[keyof typeof REFUNDAMOUNTTOOLOWIssueEnum];
export const REFUNDAMOUNTTOOLOWDescriptionEnum = {
  TheAmountAfterApplyingCurrencyConversionIsZeroAndHenceTheCaptureCannotBeRefundedTheCurrencyConversionIsRequiredBecauseTheCurrencyOfTheCaptureIsDifferentThanTheCurrencyInWhichTheAmountWasSettledIntoThePayeeAccount:
    'The amount after applying currency conversion is zero and hence the capture cannot be refunded. The currency conversion is required because the currency of the capture is different than the currency in which the amount was settled into the payee account.',
} as const;

export type REFUNDAMOUNTTOOLOWDescriptionEnum =
  (typeof REFUNDAMOUNTTOOLOWDescriptionEnum)[keyof typeof REFUNDAMOUNTTOOLOWDescriptionEnum];

/**
 *
 * @export
 * @interface REFUNDCAPTURECURRENCYMISMATCH
 */
export interface REFUNDCAPTURECURRENCYMISMATCH {
  /**
   *
   * @type {string}
   * @memberof REFUNDCAPTURECURRENCYMISMATCH
   */
  issue?: REFUNDCAPTURECURRENCYMISMATCHIssueEnum;
  /**
   *
   * @type {string}
   * @memberof REFUNDCAPTURECURRENCYMISMATCH
   */
  description?: REFUNDCAPTURECURRENCYMISMATCHDescriptionEnum;
}

export const REFUNDCAPTURECURRENCYMISMATCHIssueEnum = {
  RefundCaptureCurrencyMismatch: 'REFUND_CAPTURE_CURRENCY_MISMATCH',
} as const;

export type REFUNDCAPTURECURRENCYMISMATCHIssueEnum =
  (typeof REFUNDCAPTURECURRENCYMISMATCHIssueEnum)[keyof typeof REFUNDCAPTURECURRENCYMISMATCHIssueEnum];
export const REFUNDCAPTURECURRENCYMISMATCHDescriptionEnum = {
  RefundMustBeInTheSameCurrencyAsTheCapture:
    'Refund must be in the same currency as the capture',
} as const;

export type REFUNDCAPTURECURRENCYMISMATCHDescriptionEnum =
  (typeof REFUNDCAPTURECURRENCYMISMATCHDescriptionEnum)[keyof typeof REFUNDCAPTURECURRENCYMISMATCHDescriptionEnum];

/**
 *
 * @export
 * @interface REFUNDFAILEDINSUFFICIENTFUNDS
 */
export interface REFUNDFAILEDINSUFFICIENTFUNDS {
  /**
   *
   * @type {string}
   * @memberof REFUNDFAILEDINSUFFICIENTFUNDS
   */
  issue?: REFUNDFAILEDINSUFFICIENTFUNDSIssueEnum;
  /**
   *
   * @type {string}
   * @memberof REFUNDFAILEDINSUFFICIENTFUNDS
   */
  description?: REFUNDFAILEDINSUFFICIENTFUNDSDescriptionEnum;
}

export const REFUNDFAILEDINSUFFICIENTFUNDSIssueEnum = {
  RefundFailedInsufficientFunds: 'REFUND_FAILED_INSUFFICIENT_FUNDS',
} as const;

export type REFUNDFAILEDINSUFFICIENTFUNDSIssueEnum =
  (typeof REFUNDFAILEDINSUFFICIENTFUNDSIssueEnum)[keyof typeof REFUNDFAILEDINSUFFICIENTFUNDSIssueEnum];
export const REFUNDFAILEDINSUFFICIENTFUNDSDescriptionEnum = {
  CaptureCouldNotBeRefundedDueToInsufficientFundsPleaseCheckToSeeIfYouHaveSufficientFundsInYourPayPalAccountOrIfTheBankAccountLinkedToYourPayPalAccountIsVerifiedAndHasSufficientFunds:
    'Capture could not be refunded due to insufficient funds. Please check to see if you have sufficient funds in your PayPal account or if the bank account linked to your PayPal account is verified and has sufficient funds.',
} as const;

export type REFUNDFAILEDINSUFFICIENTFUNDSDescriptionEnum =
  (typeof REFUNDFAILEDINSUFFICIENTFUNDSDescriptionEnum)[keyof typeof REFUNDFAILEDINSUFFICIENTFUNDSDescriptionEnum];

/**
 *
 * @export
 * @interface REFUNDISRESTRICTED
 */
export interface REFUNDISRESTRICTED {
  /**
   *
   * @type {string}
   * @memberof REFUNDISRESTRICTED
   */
  issue?: REFUNDISRESTRICTEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof REFUNDISRESTRICTED
   */
  description?: REFUNDISRESTRICTEDDescriptionEnum;
}

export const REFUNDISRESTRICTEDIssueEnum = {
  RefundIsRestricted: 'REFUND_IS_RESTRICTED',
} as const;

export type REFUNDISRESTRICTEDIssueEnum =
  (typeof REFUNDISRESTRICTEDIssueEnum)[keyof typeof REFUNDISRESTRICTEDIssueEnum];
export const REFUNDISRESTRICTEDDescriptionEnum = {
  ThisRefundCanOnlyBeProcessedByTheApiCallerThatHadCapturedTheTransactionIfYouFacilitateYourTransactionsViaAPlatformPartnerPleaseInitiateARefundThroughThem:
    "This refund can only be processed by the API caller that had 'captured' the transaction. If you facilitate your transactions via a platform/partner, please initiate a refund through them.",
} as const;

export type REFUNDISRESTRICTEDDescriptionEnum =
  (typeof REFUNDISRESTRICTEDDescriptionEnum)[keyof typeof REFUNDISRESTRICTEDDescriptionEnum];

/**
 *
 * @export
 * @interface REFUNDNOTALLOWED
 */
export interface REFUNDNOTALLOWED {
  /**
   *
   * @type {string}
   * @memberof REFUNDNOTALLOWED
   */
  issue?: REFUNDNOTALLOWEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof REFUNDNOTALLOWED
   */
  description?: REFUNDNOTALLOWEDDescriptionEnum;
}

export const REFUNDNOTALLOWEDIssueEnum = {
  RefundNotAllowed: 'REFUND_NOT_ALLOWED',
} as const;

export type REFUNDNOTALLOWEDIssueEnum =
  (typeof REFUNDNOTALLOWEDIssueEnum)[keyof typeof REFUNDNOTALLOWEDIssueEnum];
export const REFUNDNOTALLOWEDDescriptionEnum = {
  CaptureCannotBeRefunded: 'Capture cannot be refunded.',
} as const;

export type REFUNDNOTALLOWEDDescriptionEnum =
  (typeof REFUNDNOTALLOWEDDescriptionEnum)[keyof typeof REFUNDNOTALLOWEDDescriptionEnum];

/**
 *
 * @export
 * @interface REFUNDNOTPERMITTEDDUETOCHARGEBACK
 */
export interface REFUNDNOTPERMITTEDDUETOCHARGEBACK {
  /**
   *
   * @type {string}
   * @memberof REFUNDNOTPERMITTEDDUETOCHARGEBACK
   */
  issue?: REFUNDNOTPERMITTEDDUETOCHARGEBACKIssueEnum;
  /**
   *
   * @type {string}
   * @memberof REFUNDNOTPERMITTEDDUETOCHARGEBACK
   */
  description?: REFUNDNOTPERMITTEDDUETOCHARGEBACKDescriptionEnum;
}

export const REFUNDNOTPERMITTEDDUETOCHARGEBACKIssueEnum = {
  RefundNotPermittedDueToChargeback: 'REFUND_NOT_PERMITTED_DUE_TO_CHARGEBACK',
} as const;

export type REFUNDNOTPERMITTEDDUETOCHARGEBACKIssueEnum =
  (typeof REFUNDNOTPERMITTEDDUETOCHARGEBACKIssueEnum)[keyof typeof REFUNDNOTPERMITTEDDUETOCHARGEBACKIssueEnum];
export const REFUNDNOTPERMITTEDDUETOCHARGEBACKDescriptionEnum = {
  RefundsAreNotAllowedOnThisCaptureDueToAChargebackOnTheCardOrBankPleaseContactThePayeeToResolveTheChargeback:
    'Refunds are not allowed on this capture due to a chargeback on the card or bank. Please contact the payee to resolve the chargeback.',
} as const;

export type REFUNDNOTPERMITTEDDUETOCHARGEBACKDescriptionEnum =
  (typeof REFUNDNOTPERMITTEDDUETOCHARGEBACKDescriptionEnum)[keyof typeof REFUNDNOTPERMITTEDDUETOCHARGEBACKDescriptionEnum];

/**
 *
 * @export
 * @interface REFUNDTIMELIMITEXCEEDED
 */
export interface REFUNDTIMELIMITEXCEEDED {
  /**
   *
   * @type {string}
   * @memberof REFUNDTIMELIMITEXCEEDED
   */
  issue?: REFUNDTIMELIMITEXCEEDEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof REFUNDTIMELIMITEXCEEDED
   */
  description?: REFUNDTIMELIMITEXCEEDEDDescriptionEnum;
}

export const REFUNDTIMELIMITEXCEEDEDIssueEnum = {
  RefundTimeLimitExceeded: 'REFUND_TIME_LIMIT_EXCEEDED',
} as const;

export type REFUNDTIMELIMITEXCEEDEDIssueEnum =
  (typeof REFUNDTIMELIMITEXCEEDEDIssueEnum)[keyof typeof REFUNDTIMELIMITEXCEEDEDIssueEnum];
export const REFUNDTIMELIMITEXCEEDEDDescriptionEnum = {
  YouAreOverTheTimeLimitToPerformARefundOnThisCapture:
    'You are over the time limit to perform a refund on this capture',
} as const;

export type REFUNDTIMELIMITEXCEEDEDDescriptionEnum =
  (typeof REFUNDTIMELIMITEXCEEDEDDescriptionEnum)[keyof typeof REFUNDTIMELIMITEXCEEDEDDescriptionEnum];

/**
 * Reauthorizes an authorized PayPal account payment, by ID. To ensure that funds are still available, reauthorize a payment after its initial three-day honor period expires. You can reauthorize a payment only once from days four to 29.<br/><br/>If 30 days have transpired since the date of the original authorization, you must create an authorized payment instead of reauthorizing the original authorized payment.<br/><br/>A reauthorized payment itself has a new honor period of three days.<br/><br/>You can reauthorize an authorized payment once for up to 115% of the original authorized amount, not to exceed an increase of $75 USD.<br/><br/>Supports only the `amount` request parameter.<blockquote><strong>Note:</strong> This request is currently not supported for Partner use cases.</blockquote>
 * @export
 * @interface ReauthorizeRequest
 */
export interface ReauthorizeRequest {
  /**
   *
   * @type {Money}
   * @memberof ReauthorizeRequest
   */
  amount?: Money;
}
/**
 * The refund information.
 * @export
 * @interface Refund
 */
export interface Refund {
  /**
   * The status of the refund.
   * @type {string}
   * @memberof Refund
   */
  status?: RefundStatusEnum;
  /**
   *
   * @type {RefundStatusDetails}
   * @memberof Refund
   */
  status_details?: RefundStatusDetails;
  /**
   * The PayPal-generated ID for the refund.
   * @type {string}
   * @memberof Refund
   */
  id?: string;
  /**
   *
   * @type {Money}
   * @memberof Refund
   */
  amount?: Money;
  /**
   * The API caller-provided external invoice number for this order. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof Refund
   */
  invoice_id?: string;
  /**
   * The API caller-provided external ID. Used to reconcile API caller-initiated transactions with PayPal transactions. Appears in transaction and settlement reports.
   * @type {string}
   * @memberof Refund
   */
  custom_id?: string;
  /**
   * Reference ID issued for the card transaction. This ID can be used to track the transaction across processors, card brands and issuing banks.
   * @type {string}
   * @memberof Refund
   */
  acquirer_reference_number?: string;
  /**
   * The reason for the refund. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof Refund
   */
  note_to_payer?: string;
  /**
   *
   * @type {MerchantPayableBreakdown}
   * @memberof Refund
   */
  seller_payable_breakdown?: MerchantPayableBreakdown;
  /**
   *
   * @type {PayeeBase}
   * @memberof Refund
   */
  payer?: PayeeBase;
  /**
   * An array of related [HATEOAS links](/docs/api/reference/api-responses/#hateoas-links).
   * @type {Array<LinkDescription>}
   * @memberof Refund
   */
  links?: Array<LinkDescription>;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof Refund
   */
  create_time?: string;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof Refund
   */
  update_time?: string;
}

export const RefundStatusEnum = {
  Cancelled: 'CANCELLED',
  Failed: 'FAILED',
  Pending: 'PENDING',
  Completed: 'COMPLETED',
} as const;

export type RefundStatusEnum =
  (typeof RefundStatusEnum)[keyof typeof RefundStatusEnum];

/**
 *
 * @export
 * @interface RefundAllOf
 */
export interface RefundAllOf {
  /**
   * The PayPal-generated ID for the refund.
   * @type {string}
   * @memberof RefundAllOf
   */
  id?: string;
  /**
   *
   * @type {Money}
   * @memberof RefundAllOf
   */
  amount?: Money;
  /**
   * The API caller-provided external invoice number for this order. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof RefundAllOf
   */
  invoice_id?: string;
  /**
   * The API caller-provided external ID. Used to reconcile API caller-initiated transactions with PayPal transactions. Appears in transaction and settlement reports.
   * @type {string}
   * @memberof RefundAllOf
   */
  custom_id?: string;
  /**
   * Reference ID issued for the card transaction. This ID can be used to track the transaction across processors, card brands and issuing banks.
   * @type {string}
   * @memberof RefundAllOf
   */
  acquirer_reference_number?: string;
  /**
   * The reason for the refund. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof RefundAllOf
   */
  note_to_payer?: string;
  /**
   *
   * @type {MerchantPayableBreakdown}
   * @memberof RefundAllOf
   */
  seller_payable_breakdown?: MerchantPayableBreakdown;
  /**
   *
   * @type {PayeeBase}
   * @memberof RefundAllOf
   */
  payer?: PayeeBase;
  /**
   * An array of related [HATEOAS links](/docs/api/reference/api-responses/#hateoas-links).
   * @type {Array<LinkDescription>}
   * @memberof RefundAllOf
   */
  links?: Array<LinkDescription>;
}
/**
 * Refunds a captured payment, by ID. For a full refund, include an empty request body. For a partial refund, include an <code>amount</code> object in the request body.
 * @export
 * @interface RefundRequest
 */
export interface RefundRequest {
  /**
   *
   * @type {Money}
   * @memberof RefundRequest
   */
  amount?: Money;
  /**
   * The API caller-provided external ID. Used to reconcile API caller-initiated transactions with PayPal transactions. Appears in transaction and settlement reports. The pattern is defined by an external party and supports Unicode.
   * @type {string}
   * @memberof RefundRequest
   */
  custom_id?: string;
  /**
   * The API caller-provided external invoice ID for this order. The pattern is defined by an external party and supports Unicode.
   * @type {string}
   * @memberof RefundRequest
   */
  invoice_id?: string;
  /**
   * The reason for the refund. Appears in both the payer\'s transaction history and the emails that the payer receives. The pattern is defined by an external party and supports Unicode.
   * @type {string}
   * @memberof RefundRequest
   */
  note_to_payer?: string;
  /**
   *
   * @type {PaymentInstruction2}
   * @memberof RefundRequest
   */
  payment_instruction?: PaymentInstruction2;
}
/**
 * The refund status.
 * @export
 * @interface RefundStatus
 */
export interface RefundStatus {
  /**
   * The status of the refund.
   * @type {string}
   * @memberof RefundStatus
   */
  status?: RefundStatusStatusEnum;
  /**
   *
   * @type {RefundStatusDetails}
   * @memberof RefundStatus
   */
  status_details?: RefundStatusDetails;
}

export const RefundStatusStatusEnum = {
  Cancelled: 'CANCELLED',
  Failed: 'FAILED',
  Pending: 'PENDING',
  Completed: 'COMPLETED',
} as const;

export type RefundStatusStatusEnum =
  (typeof RefundStatusStatusEnum)[keyof typeof RefundStatusStatusEnum];

/**
 * The details of the refund status.
 * @export
 * @interface RefundStatusDetails
 */
export interface RefundStatusDetails {
  /**
   * The reason why the refund has the `PENDING` or `FAILED` status.
   * @type {string}
   * @memberof RefundStatusDetails
   */
  reason?: RefundStatusDetailsReasonEnum;
}

export const RefundStatusDetailsReasonEnum = {
  Echeck: 'ECHECK',
} as const;

export type RefundStatusDetailsReasonEnum =
  (typeof RefundStatusDetailsReasonEnum)[keyof typeof RefundStatusDetailsReasonEnum];

/**
 * Identifiers related to a specific resource.
 * @export
 * @interface RelatedIds
 */
export interface RelatedIds {
  /**
   * Order ID related to the resource.
   * @type {string}
   * @memberof RelatedIds
   */
  order_id?: string;
  /**
   * Authorization ID related to the resource.
   * @type {string}
   * @memberof RelatedIds
   */
  authorization_id?: string;
  /**
   * Capture ID related to the resource.
   * @type {string}
   * @memberof RelatedIds
   */
  capture_id?: string;
}
/**
 * The level of protection offered as defined by [PayPal Seller Protection for Merchants](https://www.paypal.com/us/webapps/mpp/security/seller-protection).
 * @export
 * @interface SellerProtection
 */
export interface SellerProtection {
  /**
   * Indicates whether the transaction is eligible for seller protection. For information, see [PayPal Seller Protection for Merchants](https://www.paypal.com/us/webapps/mpp/security/seller-protection).
   * @type {string}
   * @memberof SellerProtection
   */
  status?: SellerProtectionStatusEnum;
  /**
   * An array of conditions that are covered for the transaction.
   * @type {Array<string>}
   * @memberof SellerProtection
   */
  dispute_categories?: Array<SellerProtectionDisputeCategoriesEnum>;
}

export const SellerProtectionStatusEnum = {
  Eligible: 'ELIGIBLE',
  PartiallyEligible: 'PARTIALLY_ELIGIBLE',
  NotEligible: 'NOT_ELIGIBLE',
} as const;

export type SellerProtectionStatusEnum =
  (typeof SellerProtectionStatusEnum)[keyof typeof SellerProtectionStatusEnum];
export const SellerProtectionDisputeCategoriesEnum = {
  ItemNotReceived: 'ITEM_NOT_RECEIVED',
  UnauthorizedTransaction: 'UNAUTHORIZED_TRANSACTION',
} as const;

export type SellerProtectionDisputeCategoriesEnum =
  (typeof SellerProtectionDisputeCategoriesEnum)[keyof typeof SellerProtectionDisputeCategoriesEnum];

/**
 * The detailed breakdown of the capture activity. This is not available for transactions that are in pending state.
 * @export
 * @interface SellerReceivableBreakdown
 */
export interface SellerReceivableBreakdown {
  /**
   *
   * @type {Money}
   * @memberof SellerReceivableBreakdown
   */
  gross_amount: Money;
  /**
   *
   * @type {Money}
   * @memberof SellerReceivableBreakdown
   */
  paypal_fee?: Money;
  /**
   *
   * @type {Money}
   * @memberof SellerReceivableBreakdown
   */
  paypal_fee_in_receivable_currency?: Money;
  /**
   *
   * @type {Money}
   * @memberof SellerReceivableBreakdown
   */
  net_amount?: Money;
  /**
   *
   * @type {Money}
   * @memberof SellerReceivableBreakdown
   */
  receivable_amount?: Money;
  /**
   *
   * @type {ExchangeRate}
   * @memberof SellerReceivableBreakdown
   */
  exchange_rate?: ExchangeRate;
  /**
   * An array of platform or partner fees, commissions, or brokerage fees that associated with the captured payment.
   * @type {Array<PlatformFee>}
   * @memberof SellerReceivableBreakdown
   */
  platform_fees?: Array<PlatformFee>;
}
/**
 * The supplementary data.
 * @export
 * @interface SupplementaryData
 */
export interface SupplementaryData {
  /**
   *
   * @type {RelatedIds}
   * @memberof SupplementaryData
   */
  related_ids?: RelatedIds;
}
/**
 * The capture identification-related fields. Includes the invoice ID, custom ID, note to payer, and soft descriptor.
 * @export
 * @interface SupplementaryPurchaseData
 */
export interface SupplementaryPurchaseData {
  /**
   * The API caller-provided external invoice number for this order. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof SupplementaryPurchaseData
   */
  invoice_id?: string;
  /**
   * An informational note about this settlement. Appears in both the payer\'s transaction history and the emails that the payer receives.
   * @type {string}
   * @memberof SupplementaryPurchaseData
   */
  note_to_payer?: string;
}
/**
 *
 * @export
 * @interface TRANSACTIONDISPUTED
 */
export interface TRANSACTIONDISPUTED {
  /**
   *
   * @type {string}
   * @memberof TRANSACTIONDISPUTED
   */
  issue?: TRANSACTIONDISPUTEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof TRANSACTIONDISPUTED
   */
  description?: TRANSACTIONDISPUTEDDescriptionEnum;
}

export const TRANSACTIONDISPUTEDIssueEnum = {
  TransactionDisputed: 'TRANSACTION_DISPUTED',
} as const;

export type TRANSACTIONDISPUTEDIssueEnum =
  (typeof TRANSACTIONDISPUTEDIssueEnum)[keyof typeof TRANSACTIONDISPUTEDIssueEnum];
export const TRANSACTIONDISPUTEDDescriptionEnum = {
  PartialRefundsCannotBeOfferedAtThisTimeBecauseThereIsAnOpenCaseOnThisTransactionVisitThePayPalResolutionCenterToReviewThisCase:
    'Partial refunds cannot be offered at this time because there is an open case on this transaction. Visit the PayPal Resolution Center to review this case.',
} as const;

export type TRANSACTIONDISPUTEDDescriptionEnum =
  (typeof TRANSACTIONDISPUTEDDescriptionEnum)[keyof typeof TRANSACTIONDISPUTEDDescriptionEnum];

/**
 *
 * @export
 * @interface TRANSACTIONREFUSED
 */
export interface TRANSACTIONREFUSED {
  /**
   *
   * @type {string}
   * @memberof TRANSACTIONREFUSED
   */
  issue?: TRANSACTIONREFUSEDIssueEnum;
  /**
   *
   * @type {string}
   * @memberof TRANSACTIONREFUSED
   */
  description?: TRANSACTIONREFUSEDDescriptionEnum;
}

export const TRANSACTIONREFUSEDIssueEnum = {
  TransactionRefused: 'TRANSACTION_REFUSED',
} as const;

export type TRANSACTIONREFUSEDIssueEnum =
  (typeof TRANSACTIONREFUSEDIssueEnum)[keyof typeof TRANSACTIONREFUSEDIssueEnum];
export const TRANSACTIONREFUSEDDescriptionEnum = {
  PayPalsInternalControlsPreventAuthorizationFromBeingCaptured:
    "PayPal's internal controls prevent authorization from being captured.",
} as const;

export type TRANSACTIONREFUSEDDescriptionEnum =
  (typeof TRANSACTIONREFUSEDDescriptionEnum)[keyof typeof TRANSACTIONREFUSEDDescriptionEnum];

/**
 * AuthorizationsApi - axios parameter creator
 * @export
 */
export const AuthorizationsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Captures an authorized payment, by ID.
     * @summary Capture authorized payment
     * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
     * @param {string} payPalRequestId The server stores keys for 45 days.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
     * @param {CaptureRequest} [captureRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsCapture: async (
      authorizationId: string,
      payPalRequestId: string,
      contentType: string,
      prefer?: string,
      captureRequest?: CaptureRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorizationId' is not null or undefined
      assertParamExists(
        'authorizationsCapture',
        'authorizationId',
        authorizationId
      );
      // verify required parameter 'payPalRequestId' is not null or undefined
      assertParamExists(
        'authorizationsCapture',
        'payPalRequestId',
        payPalRequestId
      );
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists('authorizationsCapture', 'contentType', contentType);
      const localVarPath =
        `/v2/payments/authorizations/{authorization_id}/capture`.replace(
          `{${'authorization_id'}}`,
          encodeURIComponent(String(authorizationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/payments/payment/authcapture'],
        configuration
      );

      if (payPalRequestId != null) {
        localVarHeaderParameter['PayPal-Request-Id'] = String(payPalRequestId);
      }

      if (prefer != null) {
        localVarHeaderParameter['Prefer'] = String(prefer);
      }

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        captureRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Shows details for an authorized payment, by ID.
     * @summary Show details for authorized payment
     * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsGet: async (
      authorizationId: string,
      contentType: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorizationId' is not null or undefined
      assertParamExists(
        'authorizationsGet',
        'authorizationId',
        authorizationId
      );
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists('authorizationsGet', 'contentType', contentType);
      const localVarPath =
        `/v2/payments/authorizations/{authorization_id}`.replace(
          `{${'authorization_id'}}`,
          encodeURIComponent(String(authorizationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/payments/payment/authcapture'],
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Reauthorizes an authorized PayPal account payment, by ID. To ensure that funds are still available, reauthorize a payment after its initial three-day honor period expires. Within the 29-day authorization period, you can issue multiple re-authorizations after the honor period expires.<br/><br/>If 30 days have transpired since the date of the original authorization, you must create an authorized payment instead of reauthorizing the original authorized payment.<br/><br/>A reauthorized payment itself has a new honor period of three days.<br/><br/>You can reauthorize an authorized payment once for up to 115% of the original authorized amount, not to exceed an increase of $75 USD.<br/><br/>Supports only the `amount` request parameter.<blockquote><strong>Note:</strong> This request is currently not supported for Partner use cases.</blockquote>
     * @summary Reauthorize authorized payment
     * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
     * @param {string} payPalRequestId The server stores keys for 45 days.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
     * @param {ReauthorizeRequest} [reauthorizeRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsReauthorize: async (
      authorizationId: string,
      payPalRequestId: string,
      contentType: string,
      prefer?: string,
      reauthorizeRequest?: ReauthorizeRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorizationId' is not null or undefined
      assertParamExists(
        'authorizationsReauthorize',
        'authorizationId',
        authorizationId
      );
      // verify required parameter 'payPalRequestId' is not null or undefined
      assertParamExists(
        'authorizationsReauthorize',
        'payPalRequestId',
        payPalRequestId
      );
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists(
        'authorizationsReauthorize',
        'contentType',
        contentType
      );
      const localVarPath =
        `/v2/payments/authorizations/{authorization_id}/reauthorize`.replace(
          `{${'authorization_id'}}`,
          encodeURIComponent(String(authorizationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/payments/payment/authcapture'],
        configuration
      );

      if (payPalRequestId != null) {
        localVarHeaderParameter['PayPal-Request-Id'] = String(payPalRequestId);
      }

      if (prefer != null) {
        localVarHeaderParameter['Prefer'] = String(prefer);
      }

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        reauthorizeRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Voids, or cancels, an authorized payment, by ID. You cannot void an authorized payment that has been fully captured.
     * @summary Void authorized payment
     * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {string} [payPalAuthAssertion] An API-caller-provided JSON Web Token (JWT) assertion that identifies the merchant. For details, see [PayPal-Auth-Assertion](/docs/api/reference/api-requests/#paypal-auth-assertion).&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt;For three party transactions in which a partner is managing the API calls on behalf of a merchant, the partner must identify the merchant using either a PayPal-Auth-Assertion header or an access token with target_subject.&lt;/blockquote&gt;
     * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsVoid: async (
      authorizationId: string,
      contentType: string,
      payPalAuthAssertion?: string,
      prefer?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorizationId' is not null or undefined
      assertParamExists(
        'authorizationsVoid',
        'authorizationId',
        authorizationId
      );
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists('authorizationsVoid', 'contentType', contentType);
      const localVarPath =
        `/v2/payments/authorizations/{authorization_id}/void`.replace(
          `{${'authorization_id'}}`,
          encodeURIComponent(String(authorizationId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/payments/payment/authcapture'],
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      if (payPalAuthAssertion != null) {
        localVarHeaderParameter['PayPal-Auth-Assertion'] =
          String(payPalAuthAssertion);
      }

      if (prefer != null) {
        localVarHeaderParameter['Prefer'] = String(prefer);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthorizationsApi - functional programming interface
 * @export
 */
export const AuthorizationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AuthorizationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Captures an authorized payment, by ID.
     * @summary Capture authorized payment
     * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
     * @param {string} payPalRequestId The server stores keys for 45 days.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
     * @param {CaptureRequest} [captureRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authorizationsCapture(
      authorizationId: string,
      payPalRequestId: string,
      contentType: string,
      prefer?: string,
      captureRequest?: CaptureRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Capture2>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authorizationsCapture(
          authorizationId,
          payPalRequestId,
          contentType,
          prefer,
          captureRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Shows details for an authorized payment, by ID.
     * @summary Show details for authorized payment
     * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authorizationsGet(
      authorizationId: string,
      contentType: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization2>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authorizationsGet(
          authorizationId,
          contentType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Reauthorizes an authorized PayPal account payment, by ID. To ensure that funds are still available, reauthorize a payment after its initial three-day honor period expires. Within the 29-day authorization period, you can issue multiple re-authorizations after the honor period expires.<br/><br/>If 30 days have transpired since the date of the original authorization, you must create an authorized payment instead of reauthorizing the original authorized payment.<br/><br/>A reauthorized payment itself has a new honor period of three days.<br/><br/>You can reauthorize an authorized payment once for up to 115% of the original authorized amount, not to exceed an increase of $75 USD.<br/><br/>Supports only the `amount` request parameter.<blockquote><strong>Note:</strong> This request is currently not supported for Partner use cases.</blockquote>
     * @summary Reauthorize authorized payment
     * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
     * @param {string} payPalRequestId The server stores keys for 45 days.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
     * @param {ReauthorizeRequest} [reauthorizeRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authorizationsReauthorize(
      authorizationId: string,
      payPalRequestId: string,
      contentType: string,
      prefer?: string,
      reauthorizeRequest?: ReauthorizeRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization2>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authorizationsReauthorize(
          authorizationId,
          payPalRequestId,
          contentType,
          prefer,
          reauthorizeRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Voids, or cancels, an authorized payment, by ID. You cannot void an authorized payment that has been fully captured.
     * @summary Void authorized payment
     * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {string} [payPalAuthAssertion] An API-caller-provided JSON Web Token (JWT) assertion that identifies the merchant. For details, see [PayPal-Auth-Assertion](/docs/api/reference/api-requests/#paypal-auth-assertion).&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt;For three party transactions in which a partner is managing the API calls on behalf of a merchant, the partner must identify the merchant using either a PayPal-Auth-Assertion header or an access token with target_subject.&lt;/blockquote&gt;
     * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authorizationsVoid(
      authorizationId: string,
      contentType: string,
      payPalAuthAssertion?: string,
      prefer?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization2>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authorizationsVoid(
          authorizationId,
          contentType,
          payPalAuthAssertion,
          prefer,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AuthorizationsApi - factory interface
 * @export
 */
export const AuthorizationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthorizationsApiFp(configuration);
  return {
    /**
     * Captures an authorized payment, by ID.
     * @summary Capture authorized payment
     * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
     * @param {string} payPalRequestId The server stores keys for 45 days.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
     * @param {CaptureRequest} [captureRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsCapture(
      authorizationId: string,
      payPalRequestId: string,
      contentType: string,
      prefer?: string,
      captureRequest?: CaptureRequest,
      options?: any
    ): AxiosPromise<Capture2> {
      return localVarFp
        .authorizationsCapture(
          authorizationId,
          payPalRequestId,
          contentType,
          prefer,
          captureRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Shows details for an authorized payment, by ID.
     * @summary Show details for authorized payment
     * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsGet(
      authorizationId: string,
      contentType: string,
      options?: any
    ): AxiosPromise<Authorization2> {
      return localVarFp
        .authorizationsGet(authorizationId, contentType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Reauthorizes an authorized PayPal account payment, by ID. To ensure that funds are still available, reauthorize a payment after its initial three-day honor period expires. Within the 29-day authorization period, you can issue multiple re-authorizations after the honor period expires.<br/><br/>If 30 days have transpired since the date of the original authorization, you must create an authorized payment instead of reauthorizing the original authorized payment.<br/><br/>A reauthorized payment itself has a new honor period of three days.<br/><br/>You can reauthorize an authorized payment once for up to 115% of the original authorized amount, not to exceed an increase of $75 USD.<br/><br/>Supports only the `amount` request parameter.<blockquote><strong>Note:</strong> This request is currently not supported for Partner use cases.</blockquote>
     * @summary Reauthorize authorized payment
     * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
     * @param {string} payPalRequestId The server stores keys for 45 days.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
     * @param {ReauthorizeRequest} [reauthorizeRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsReauthorize(
      authorizationId: string,
      payPalRequestId: string,
      contentType: string,
      prefer?: string,
      reauthorizeRequest?: ReauthorizeRequest,
      options?: any
    ): AxiosPromise<Authorization2> {
      return localVarFp
        .authorizationsReauthorize(
          authorizationId,
          payPalRequestId,
          contentType,
          prefer,
          reauthorizeRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Voids, or cancels, an authorized payment, by ID. You cannot void an authorized payment that has been fully captured.
     * @summary Void authorized payment
     * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {string} [payPalAuthAssertion] An API-caller-provided JSON Web Token (JWT) assertion that identifies the merchant. For details, see [PayPal-Auth-Assertion](/docs/api/reference/api-requests/#paypal-auth-assertion).&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt;For three party transactions in which a partner is managing the API calls on behalf of a merchant, the partner must identify the merchant using either a PayPal-Auth-Assertion header or an access token with target_subject.&lt;/blockquote&gt;
     * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsVoid(
      authorizationId: string,
      contentType: string,
      payPalAuthAssertion?: string,
      prefer?: string,
      options?: any
    ): AxiosPromise<Authorization2> {
      return localVarFp
        .authorizationsVoid(
          authorizationId,
          contentType,
          payPalAuthAssertion,
          prefer,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthorizationsApi - object-oriented interface
 * @export
 * @class AuthorizationsApi
 * @extends {BaseAPI}
 */
export class AuthorizationsApi extends BaseAPI {
  /**
   * Captures an authorized payment, by ID.
   * @summary Capture authorized payment
   * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
   * @param {string} payPalRequestId The server stores keys for 45 days.
   * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
   * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
   * @param {CaptureRequest} [captureRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorizationsApi
   */
  public authorizationsCapture(
    authorizationId: string,
    payPalRequestId: string,
    contentType: string,
    prefer?: string,
    captureRequest?: CaptureRequest,
    options?: AxiosRequestConfig
  ) {
    return AuthorizationsApiFp(this.configuration)
      .authorizationsCapture(
        authorizationId,
        payPalRequestId,
        contentType,
        prefer,
        captureRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Shows details for an authorized payment, by ID.
   * @summary Show details for authorized payment
   * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
   * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorizationsApi
   */
  public authorizationsGet(
    authorizationId: string,
    contentType: string,
    options?: AxiosRequestConfig
  ) {
    return AuthorizationsApiFp(this.configuration)
      .authorizationsGet(authorizationId, contentType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Reauthorizes an authorized PayPal account payment, by ID. To ensure that funds are still available, reauthorize a payment after its initial three-day honor period expires. Within the 29-day authorization period, you can issue multiple re-authorizations after the honor period expires.<br/><br/>If 30 days have transpired since the date of the original authorization, you must create an authorized payment instead of reauthorizing the original authorized payment.<br/><br/>A reauthorized payment itself has a new honor period of three days.<br/><br/>You can reauthorize an authorized payment once for up to 115% of the original authorized amount, not to exceed an increase of $75 USD.<br/><br/>Supports only the `amount` request parameter.<blockquote><strong>Note:</strong> This request is currently not supported for Partner use cases.</blockquote>
   * @summary Reauthorize authorized payment
   * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
   * @param {string} payPalRequestId The server stores keys for 45 days.
   * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
   * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
   * @param {ReauthorizeRequest} [reauthorizeRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorizationsApi
   */
  public authorizationsReauthorize(
    authorizationId: string,
    payPalRequestId: string,
    contentType: string,
    prefer?: string,
    reauthorizeRequest?: ReauthorizeRequest,
    options?: AxiosRequestConfig
  ) {
    return AuthorizationsApiFp(this.configuration)
      .authorizationsReauthorize(
        authorizationId,
        payPalRequestId,
        contentType,
        prefer,
        reauthorizeRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Voids, or cancels, an authorized payment, by ID. You cannot void an authorized payment that has been fully captured.
   * @summary Void authorized payment
   * @param {string} authorizationId The PayPal-generated ID for the authorized payment to void.
   * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
   * @param {string} [payPalAuthAssertion] An API-caller-provided JSON Web Token (JWT) assertion that identifies the merchant. For details, see [PayPal-Auth-Assertion](/docs/api/reference/api-requests/#paypal-auth-assertion).&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt;For three party transactions in which a partner is managing the API calls on behalf of a merchant, the partner must identify the merchant using either a PayPal-Auth-Assertion header or an access token with target_subject.&lt;/blockquote&gt;
   * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorizationsApi
   */
  public authorizationsVoid(
    authorizationId: string,
    contentType: string,
    payPalAuthAssertion?: string,
    prefer?: string,
    options?: AxiosRequestConfig
  ) {
    return AuthorizationsApiFp(this.configuration)
      .authorizationsVoid(
        authorizationId,
        contentType,
        payPalAuthAssertion,
        prefer,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CapturesApi - axios parameter creator
 * @export
 */
export const CapturesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Shows details for a captured payment, by ID.
     * @summary Show captured payment details
     * @param {string} captureId The PayPal-generated ID for the captured payment to refund.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capturesGet: async (
      captureId: string,
      contentType: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'captureId' is not null or undefined
      assertParamExists('capturesGet', 'captureId', captureId);
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists('capturesGet', 'contentType', contentType);
      const localVarPath = `/v2/payments/captures/{capture_id}`.replace(
        `{${'capture_id'}}`,
        encodeURIComponent(String(captureId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/payments/payment/authcapture'],
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Refunds a captured payment, by ID. For a full refund, include an empty payload in the JSON request body. For a partial refund, include an <code>amount</code> object in the JSON request body.
     * @summary Refund captured payment
     * @param {string} captureId The PayPal-generated ID for the captured payment to refund.
     * @param {string} payPalRequestId The server stores keys for 45 days.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
     * @param {string} [payPalAuthAssertion] An API-caller-provided JSON Web Token (JWT) assertion that identifies the merchant. For details, see [PayPal-Auth-Assertion](/docs/api/reference/api-requests/#paypal-auth-assertion).&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt;For three party transactions in which a partner is managing the API calls on behalf of a merchant, the partner must identify the merchant using either a PayPal-Auth-Assertion header or an access token with target_subject.&lt;/blockquote&gt;
     * @param {RefundRequest} [refundRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capturesRefund: async (
      captureId: string,
      payPalRequestId: string,
      contentType: string,
      prefer?: string,
      payPalAuthAssertion?: string,
      refundRequest?: RefundRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'captureId' is not null or undefined
      assertParamExists('capturesRefund', 'captureId', captureId);
      // verify required parameter 'payPalRequestId' is not null or undefined
      assertParamExists('capturesRefund', 'payPalRequestId', payPalRequestId);
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists('capturesRefund', 'contentType', contentType);
      const localVarPath = `/v2/payments/captures/{capture_id}/refund`.replace(
        `{${'capture_id'}}`,
        encodeURIComponent(String(captureId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/payments/refund'],
        configuration
      );

      if (payPalRequestId != null) {
        localVarHeaderParameter['PayPal-Request-Id'] = String(payPalRequestId);
      }

      if (prefer != null) {
        localVarHeaderParameter['Prefer'] = String(prefer);
      }

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      if (payPalAuthAssertion != null) {
        localVarHeaderParameter['PayPal-Auth-Assertion'] =
          String(payPalAuthAssertion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        refundRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CapturesApi - functional programming interface
 * @export
 */
export const CapturesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CapturesApiAxiosParamCreator(configuration);
  return {
    /**
     * Shows details for a captured payment, by ID.
     * @summary Show captured payment details
     * @param {string} captureId The PayPal-generated ID for the captured payment to refund.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async capturesGet(
      captureId: string,
      contentType: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Capture2>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.capturesGet(
        captureId,
        contentType,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Refunds a captured payment, by ID. For a full refund, include an empty payload in the JSON request body. For a partial refund, include an <code>amount</code> object in the JSON request body.
     * @summary Refund captured payment
     * @param {string} captureId The PayPal-generated ID for the captured payment to refund.
     * @param {string} payPalRequestId The server stores keys for 45 days.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
     * @param {string} [payPalAuthAssertion] An API-caller-provided JSON Web Token (JWT) assertion that identifies the merchant. For details, see [PayPal-Auth-Assertion](/docs/api/reference/api-requests/#paypal-auth-assertion).&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt;For three party transactions in which a partner is managing the API calls on behalf of a merchant, the partner must identify the merchant using either a PayPal-Auth-Assertion header or an access token with target_subject.&lt;/blockquote&gt;
     * @param {RefundRequest} [refundRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async capturesRefund(
      captureId: string,
      payPalRequestId: string,
      contentType: string,
      prefer?: string,
      payPalAuthAssertion?: string,
      refundRequest?: RefundRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refund>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.capturesRefund(
        captureId,
        payPalRequestId,
        contentType,
        prefer,
        payPalAuthAssertion,
        refundRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CapturesApi - factory interface
 * @export
 */
export const CapturesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CapturesApiFp(configuration);
  return {
    /**
     * Shows details for a captured payment, by ID.
     * @summary Show captured payment details
     * @param {string} captureId The PayPal-generated ID for the captured payment to refund.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capturesGet(
      captureId: string,
      contentType: string,
      options?: any
    ): AxiosPromise<Capture2> {
      return localVarFp
        .capturesGet(captureId, contentType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Refunds a captured payment, by ID. For a full refund, include an empty payload in the JSON request body. For a partial refund, include an <code>amount</code> object in the JSON request body.
     * @summary Refund captured payment
     * @param {string} captureId The PayPal-generated ID for the captured payment to refund.
     * @param {string} payPalRequestId The server stores keys for 45 days.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
     * @param {string} [payPalAuthAssertion] An API-caller-provided JSON Web Token (JWT) assertion that identifies the merchant. For details, see [PayPal-Auth-Assertion](/docs/api/reference/api-requests/#paypal-auth-assertion).&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt;For three party transactions in which a partner is managing the API calls on behalf of a merchant, the partner must identify the merchant using either a PayPal-Auth-Assertion header or an access token with target_subject.&lt;/blockquote&gt;
     * @param {RefundRequest} [refundRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capturesRefund(
      captureId: string,
      payPalRequestId: string,
      contentType: string,
      prefer?: string,
      payPalAuthAssertion?: string,
      refundRequest?: RefundRequest,
      options?: any
    ): AxiosPromise<Refund> {
      return localVarFp
        .capturesRefund(
          captureId,
          payPalRequestId,
          contentType,
          prefer,
          payPalAuthAssertion,
          refundRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CapturesApi - object-oriented interface
 * @export
 * @class CapturesApi
 * @extends {BaseAPI}
 */
export class CapturesApi extends BaseAPI {
  /**
   * Shows details for a captured payment, by ID.
   * @summary Show captured payment details
   * @param {string} captureId The PayPal-generated ID for the captured payment to refund.
   * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CapturesApi
   */
  public capturesGet(
    captureId: string,
    contentType: string,
    options?: AxiosRequestConfig
  ) {
    return CapturesApiFp(this.configuration)
      .capturesGet(captureId, contentType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Refunds a captured payment, by ID. For a full refund, include an empty payload in the JSON request body. For a partial refund, include an <code>amount</code> object in the JSON request body.
   * @summary Refund captured payment
   * @param {string} captureId The PayPal-generated ID for the captured payment to refund.
   * @param {string} payPalRequestId The server stores keys for 45 days.
   * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
   * @param {string} [prefer] The preferred server response upon successful completion of the request. Value is:&lt;ul&gt;&lt;li&gt;&lt;code&gt;return&#x3D;minimal&lt;/code&gt;. The server returns a minimal response to optimize communication between the API caller and the server. A minimal response includes the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt; and HATEOAS links.&lt;/li&gt;&lt;li&gt;&lt;code&gt;return&#x3D;representation&lt;/code&gt;. The server returns a complete resource representation, including the current state of the resource.&lt;/li&gt;&lt;/ul&gt;
   * @param {string} [payPalAuthAssertion] An API-caller-provided JSON Web Token (JWT) assertion that identifies the merchant. For details, see [PayPal-Auth-Assertion](/docs/api/reference/api-requests/#paypal-auth-assertion).&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt;For three party transactions in which a partner is managing the API calls on behalf of a merchant, the partner must identify the merchant using either a PayPal-Auth-Assertion header or an access token with target_subject.&lt;/blockquote&gt;
   * @param {RefundRequest} [refundRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CapturesApi
   */
  public capturesRefund(
    captureId: string,
    payPalRequestId: string,
    contentType: string,
    prefer?: string,
    payPalAuthAssertion?: string,
    refundRequest?: RefundRequest,
    options?: AxiosRequestConfig
  ) {
    return CapturesApiFp(this.configuration)
      .capturesRefund(
        captureId,
        payPalRequestId,
        contentType,
        prefer,
        payPalAuthAssertion,
        refundRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RefundsApi - axios parameter creator
 * @export
 */
export const RefundsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Shows details for a refund, by ID.
     * @summary Show refund details
     * @param {string} refundId The PayPal-generated ID for the refund for which to show details.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refundsGet: async (
      refundId: string,
      contentType: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'refundId' is not null or undefined
      assertParamExists('refundsGet', 'refundId', refundId);
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists('refundsGet', 'contentType', contentType);
      const localVarPath = `/v2/payments/refunds/{refund_id}`.replace(
        `{${'refund_id'}}`,
        encodeURIComponent(String(refundId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/payments/refund'],
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RefundsApi - functional programming interface
 * @export
 */
export const RefundsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RefundsApiAxiosParamCreator(configuration);
  return {
    /**
     * Shows details for a refund, by ID.
     * @summary Show refund details
     * @param {string} refundId The PayPal-generated ID for the refund for which to show details.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refundsGet(
      refundId: string,
      contentType: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refund>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refundsGet(
        refundId,
        contentType,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RefundsApi - factory interface
 * @export
 */
export const RefundsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RefundsApiFp(configuration);
  return {
    /**
     * Shows details for a refund, by ID.
     * @summary Show refund details
     * @param {string} refundId The PayPal-generated ID for the refund for which to show details.
     * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refundsGet(
      refundId: string,
      contentType: string,
      options?: any
    ): AxiosPromise<Refund> {
      return localVarFp
        .refundsGet(refundId, contentType, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RefundsApi - object-oriented interface
 * @export
 * @class RefundsApi
 * @extends {BaseAPI}
 */
export class RefundsApi extends BaseAPI {
  /**
   * Shows details for a refund, by ID.
   * @summary Show refund details
   * @param {string} refundId The PayPal-generated ID for the refund for which to show details.
   * @param {string} contentType The media type. Required for operations with a request body. The value is &#x60;application/&lt;format&gt;&#x60;, where &#x60;format&#x60; is &#x60;json&#x60;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RefundsApi
   */
  public refundsGet(
    refundId: string,
    contentType: string,
    options?: AxiosRequestConfig
  ) {
    return RefundsApiFp(this.configuration)
      .refundsGet(refundId, contentType, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
