/* tslint:disable */
/* eslint-disable */
/**
 * Payment Method Tokens
 * The Payment Method Tokens API saves payment methods so payers don\'t have to enter details for future transactions. Payers can check out faster or pay without being present after they agree to save a payment method.<br><br>The API associates a payment method with a temporary setup token. Pass the setup token to the API to exchange the setup token for a permanent token.<br><br>The permanent token represents a payment method that\'s saved to the vault. This token can be used repeatedly for checkout or recurring transactions such as subscriptions.<br><br>The Payment Method Tokens API is available in the US only.
 *
 * The version of the OpenAPI document: 3.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { AxiosInstance, AxiosPromise, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import type { Configuration } from './configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import type { RequestArgs } from './base';
import {
  assertParamExists,
  createRequestFunction,
  DUMMY_BASE_URL,
  serializeDataIfNeeded,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
// @ts-ignore
import { BaseAPI, BASE_PATH } from './base';

/**
 * The non-portable additional address details that are sometimes needed for compliance, risk, or other scenarios where fine-grain address information might be needed. Not portable with common third party and open source. Redundant with core fields.<br/>For example, `address_portable.address_line_1` is usually a combination of `address_details.street_number`, `street_name`, and `street_type`.
 * @export
 * @interface AddressDetails
 */
export interface AddressDetails {
  /**
   * The street number.
   * @type {string}
   * @memberof AddressDetails
   */
  street_number?: string;
  /**
   * The street name. Just `Drury` in `Drury Lane`.
   * @type {string}
   * @memberof AddressDetails
   */
  street_name?: string;
  /**
   * The street type. For example, avenue, boulevard, road, or expressway.
   * @type {string}
   * @memberof AddressDetails
   */
  street_type?: string;
  /**
   * The delivery service. Post office box, bag number, or post office name.
   * @type {string}
   * @memberof AddressDetails
   */
  delivery_service?: string;
  /**
   * A named locations that represents the premise. Usually a building name or number or collection of buildings with a common name or number. For example, <code>Craven House</code>.
   * @type {string}
   * @memberof AddressDetails
   */
  building_name?: string;
  /**
   * The first-order entity below a named building or location that represents the sub-premises. Usually a single building within a collection of buildings with a common name. Can be a flat, story, floor, room, or apartment.
   * @type {string}
   * @memberof AddressDetails
   */
  sub_building?: string;
}
/**
 * The portable international postal address. Maps to [AddressValidationMetadata](https://github.com/googlei18n/libaddressinput/wiki/AddressValidationMetadata) and HTML 5.1 [Autofilling form controls: the autocomplete attribute](https://www.w3.org/TR/html51/sec-forms.html#autofilling-form-controls-the-autocomplete-attribute).
 * @export
 * @interface AddressPortable
 */
export interface AddressPortable {
  /**
   * The first line of the address. For example, number or street. For example, `173 Drury Lane`. Required for data entry and compliance and risk checks. Must contain the full address.
   * @type {string}
   * @memberof AddressPortable
   */
  address_line_1?: string;
  /**
   * The second line of the address. For example, suite or apartment number.
   * @type {string}
   * @memberof AddressPortable
   */
  address_line_2?: string;
  /**
   * The third line of the address, if needed. For example, a street complement for Brazil, direction text, such as `next to Walmart`, or a landmark in an Indian address.
   * @type {string}
   * @memberof AddressPortable
   */
  address_line_3?: string;
  /**
   * The neighborhood, ward, or district. Smaller than `admin_area_level_3` or `sub_locality`. Value is:<ul><li>The postal sorting code for Guernsey and many French territories, such as French Guiana.</li><li>The fine-grained administrative levels in China.</li></ul>
   * @type {string}
   * @memberof AddressPortable
   */
  admin_area_4?: string;
  /**
   * A sub-locality, suburb, neighborhood, or district. Smaller than `admin_area_level_2`. Value is:<ul><li>Brazil. Suburb, bairro, or neighborhood.</li><li>India. Sub-locality or district. Street name information is not always available but a sub-locality or district can be a very small area.</li></ul>
   * @type {string}
   * @memberof AddressPortable
   */
  admin_area_3?: string;
  /**
   * A city, town, or village. Smaller than `admin_area_level_1`.
   * @type {string}
   * @memberof AddressPortable
   */
  admin_area_2?: string;
  /**
   * The highest level sub-division in a country, which is usually a province, state, or ISO-3166-2 subdivision. Format for postal delivery. For example, `CA` and not `California`. Value, by country, is:<ul><li>UK. A county.</li><li>US. A state.</li><li>Canada. A province.</li><li>Japan. A prefecture.</li><li>Switzerland. A kanton.</li></ul>
   * @type {string}
   * @memberof AddressPortable
   */
  admin_area_1?: string;
  /**
   * The postal code, which is the zip code or equivalent. Typically required for countries with a postal code or an equivalent. See [postal code](https://en.wikipedia.org/wiki/Postal_code).
   * @type {string}
   * @memberof AddressPortable
   */
  postal_code?: string;
  /**
   * The [two-character ISO 3166-1 code](/api/rest/reference/country-codes/) that identifies the country or region.<blockquote><strong>Note:</strong> The country code for Great Britain is <code>GB</code> and not <code>UK</code> as used in the top-level domain names for that country. Use the `C2` country code for China worldwide for comparable uncontrolled price (CUP) method, bank card, and cross-border transactions.</blockquote>
   * @type {string}
   * @memberof AddressPortable
   */
  country_code: string;
  /**
   *
   * @type {AddressDetails}
   * @memberof AddressPortable
   */
  address_details?: AddressDetails;
}
/**
 * Results of Authentication such as 3D Secure.
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
  /**
   *
   * @type {LiabilityShift}
   * @memberof AuthenticationResponse
   */
  liability_shift?: LiabilityShift;
  /**
   *
   * @type {ThreeDSecureAuthenticationResponse}
   * @memberof AuthenticationResponse
   */
  three_d_secure?: ThreeDSecureAuthenticationResponse;
}

/**
 * The payment card to use to fund a payment. Can be a credit or debit card.
 * @export
 * @interface Card
 */
export interface Card {
  /**
   * The identifier of the instrument.
   * @type {string}
   * @memberof Card
   */
  id?: string;
  /**
   * The card holder\'s name as it appears on the card.
   * @type {string}
   * @memberof Card
   */
  name?: string;
  /**
   * The primary account number (PAN) for the payment card.
   * @type {string}
   * @memberof Card
   */
  number?: string;
  /**
   * The year and month, in ISO-8601 `YYYY-MM` date format. See [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6).
   * @type {string}
   * @memberof Card
   */
  expiry?: string;
  /**
   * The three- or four-digit security code of the card. Also known as the CVV, CVC, CVN, CVE, or CID. This parameter cannot be present in the request when `payment_initiator=MERCHANT`.
   * @type {string}
   * @memberof Card
   */
  security_code?: string;
  /**
   * The last digits of the payment card.
   * @type {string}
   * @memberof Card
   */
  last_digits?: string;
  /**
   *
   * @type {CardBrand}
   * @memberof Card
   */
  card_type?: CardBrand;
  /**
   *
   * @type {CardType}
   * @memberof Card
   */
  type?: CardType;
  /**
   *
   * @type {CardBrand}
   * @memberof Card
   */
  brand?: CardBrand;
  /**
   *
   * @type {AddressPortable}
   * @memberof Card
   */
  billing_address?: AddressPortable;
}

/**
 * The card network or brand. Applies to credit, debit, gift, and payment cards.
 * @export
 * @enum {string}
 */

export const CardBrand = {
  Visa: 'VISA',
  Mastercard: 'MASTERCARD',
  Discover: 'DISCOVER',
  Amex: 'AMEX',
  Solo: 'SOLO',
  Jcb: 'JCB',
  Star: 'STAR',
  Delta: 'DELTA',
  Switch: 'SWITCH',
  Maestro: 'MAESTRO',
  CbNationale: 'CB_NATIONALE',
  Configoga: 'CONFIGOGA',
  Confidis: 'CONFIDIS',
  Electron: 'ELECTRON',
  Cetelem: 'CETELEM',
  ChinaUnionPay: 'CHINA_UNION_PAY',
} as const;

export type CardBrand = (typeof CardBrand)[keyof typeof CardBrand];

/**
 * A Resource representing a request to vault a Card.
 * @export
 * @interface CardRequest
 */
export interface CardRequest {
  /**
   * The identifier of the instrument.
   * @type {string}
   * @memberof CardRequest
   */
  id?: string;
  /**
   * The card holder\'s name as it appears on the card.
   * @type {string}
   * @memberof CardRequest
   */
  name?: string;
  /**
   * The primary account number (PAN) for the payment card.
   * @type {string}
   * @memberof CardRequest
   */
  number?: string;
  /**
   * The year and month, in ISO-8601 `YYYY-MM` date format. See [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6).
   * @type {string}
   * @memberof CardRequest
   */
  expiry?: string;
  /**
   * The three- or four-digit security code of the card. Also known as the CVV, CVC, CVN, CVE, or CID. This parameter cannot be present in the request when `payment_initiator=MERCHANT`.
   * @type {string}
   * @memberof CardRequest
   */
  security_code?: string;
  /**
   * The last digits of the payment card.
   * @type {string}
   * @memberof CardRequest
   */
  last_digits?: string;
  /**
   *
   * @type {CardBrand}
   * @memberof CardRequest
   */
  card_type?: CardBrand;
  /**
   *
   * @type {CardType}
   * @memberof CardRequest
   */
  type?: CardType;
  /**
   *
   * @type {CardBrand}
   * @memberof CardRequest
   */
  brand?: CardBrand;
  /**
   *
   * @type {AddressPortable}
   * @memberof CardRequest
   */
  billing_address?: AddressPortable;
  /**
   * The verification method of the card.
   * @type {string}
   * @memberof CardRequest
   */
  verification_method?: string;
  /**
   *
   * @type {ExperienceContext}
   * @memberof CardRequest
   */
  experience_context?: ExperienceContext;
}

/**
 *
 * @export
 * @interface CardRequestAllOf
 */
export interface CardRequestAllOf {
  /**
   * The verification method of the card.
   * @type {string}
   * @memberof CardRequestAllOf
   */
  verification_method?: string;
  /**
   *
   * @type {ExperienceContext}
   * @memberof CardRequestAllOf
   */
  experience_context?: ExperienceContext;
}
/**
 * The payment card to use to fund a payment. Card can be a credit or debit card.
 * @export
 * @interface CardResponse
 */
export interface CardResponse {
  /**
   * The card holder\'s name as it appears on the card.
   * @type {string}
   * @memberof CardResponse
   */
  name?: string;
  /**
   *
   * @type {AddressPortable}
   * @memberof CardResponse
   */
  billing_address?: AddressPortable;
  /**
   * The last digits of the payment card.
   * @type {string}
   * @memberof CardResponse
   */
  last_digits?: string;
  /**
   *
   * @type {CardBrand}
   * @memberof CardResponse
   */
  brand?: CardBrand;
  /**
   * The payment card type.
   * @type {string}
   * @memberof CardResponse
   */
  type?: CardResponseTypeEnum;
  /**
   *
   * @type {AuthenticationResponse}
   * @memberof CardResponse
   */
  authentication_result?: AuthenticationResponse;
}

export const CardResponseTypeEnum = {
  Credit: 'CREDIT',
  Debit: 'DEBIT',
  Prepaid: 'PREPAID',
  Unknown: 'UNKNOWN',
} as const;

export type CardResponseTypeEnum =
  (typeof CardResponseTypeEnum)[keyof typeof CardResponseTypeEnum];

/**
 * Full representation of a Card Payment Token.
 * @export
 * @interface CardResponse2
 */
export interface CardResponse2 {
  /**
   * The card holder\'s name as it appears on the card.
   * @type {string}
   * @memberof CardResponse2
   */
  name?: string;
  /**
   *
   * @type {AddressPortable}
   * @memberof CardResponse2
   */
  billing_address?: AddressPortable;
  /**
   * The last digits of the payment card.
   * @type {string}
   * @memberof CardResponse2
   */
  last_digits?: string;
  /**
   *
   * @type {CardBrand}
   * @memberof CardResponse2
   */
  brand?: CardBrand;
  /**
   * The payment card type.
   * @type {string}
   * @memberof CardResponse2
   */
  type?: CardResponse2TypeEnum;
  /**
   *
   * @type {AuthenticationResponse}
   * @memberof CardResponse2
   */
  authentication_result?: AuthenticationResponse;
  /**
   * The year and month, in ISO-8601 `YYYY-MM` date format. See [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6).
   * @type {string}
   * @memberof CardResponse2
   */
  expiry?: string;
  /**
   * Verification status of Card.
   * @type {string}
   * @memberof CardResponse2
   */
  verification_status?: string;
  /**
   *
   * @type {CardVerificationDetails}
   * @memberof CardResponse2
   */
  verification?: CardVerificationDetails;
}

export const CardResponse2TypeEnum = {
  Credit: 'CREDIT',
  Debit: 'DEBIT',
  Prepaid: 'PREPAID',
  Unknown: 'UNKNOWN',
} as const;

export type CardResponse2TypeEnum =
  (typeof CardResponse2TypeEnum)[keyof typeof CardResponse2TypeEnum];

/**
 *
 * @export
 * @interface CardResponse2AllOf
 */
export interface CardResponse2AllOf {
  /**
   * The year and month, in ISO-8601 `YYYY-MM` date format. See [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6).
   * @type {string}
   * @memberof CardResponse2AllOf
   */
  expiry?: string;
  /**
   *
   * @type {AddressPortable}
   * @memberof CardResponse2AllOf
   */
  billing_address?: AddressPortable;
  /**
   * Verification status of Card.
   * @type {string}
   * @memberof CardResponse2AllOf
   */
  verification_status?: string;
  /**
   *
   * @type {CardVerificationDetails}
   * @memberof CardResponse2AllOf
   */
  verification?: CardVerificationDetails;
}
/**
 * Type of card. i.e Credit, Debit and so on.
 * @export
 * @enum {string}
 */

export const CardType = {
  Credit: 'CREDIT',
  Debit: 'DEBIT',
  Prepaid: 'PREPAID',
  Store: 'STORE',
  Unknown: 'UNKNOWN',
} as const;

export type CardType = (typeof CardType)[keyof typeof CardType];

/**
 * Card Verification details including the authorization details and 3D SECURE details.
 * @export
 * @interface CardVerificationDetails
 */
export interface CardVerificationDetails {
  /**
   * Transaction Identifier as given by the network to indicate a previously executed CIT authorization. Only present when authorization is successful for a verification.
   * @type {string}
   * @memberof CardVerificationDetails
   */
  network_transaction_id?: string;
  /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>
   * @type {string}
   * @memberof CardVerificationDetails
   */
  time?: string;
  /**
   *
   * @type {Money}
   * @memberof CardVerificationDetails
   */
  amount?: Money;
  /**
   *
   * @type {ProcessorResponse}
   * @memberof CardVerificationDetails
   */
  processor_response?: ProcessorResponse;
  /**
   *
   * @type {any}
   * @memberof CardVerificationDetails
   */
  three_d_secure?: any;
}
/**
 * Customer in merchant\'s or partner\'s system of records.
 * @export
 * @interface Customer
 */
export interface Customer {
  /**
   * The unique ID for a customer in merchant\'s or partner\'s system of records.
   * @type {string}
   * @memberof Customer
   */
  id?: string;
}
/**
 * Collection of payment tokens saved for a given customer.
 * @export
 * @interface CustomerVaultPaymentTokensResponse
 */
export interface CustomerVaultPaymentTokensResponse {
  /**
   * Total number of items.
   * @type {number}
   * @memberof CustomerVaultPaymentTokensResponse
   */
  total_items?: number;
  /**
   * Total number of pages.
   * @type {number}
   * @memberof CustomerVaultPaymentTokensResponse
   */
  total_pages?: number;
  /**
   *
   * @type {Customer}
   * @memberof CustomerVaultPaymentTokensResponse
   */
  customer?: Customer;
  /**
   *
   * @type {Array<PaymentTokenResponse>}
   * @memberof CustomerVaultPaymentTokensResponse
   */
  payment_tokens?: Array<PaymentTokenResponse>;
  /**
   * An array of related [HATEOAS links](/api/rest/responses/#hateoas).
   * @type {Array<LinkDescription>}
   * @memberof CustomerVaultPaymentTokensResponse
   */
  links?: Array<LinkDescription>;
}
/**
 * Status of Authentication eligibility.
 * @export
 * @enum {string}
 */

export const Enrolled = {
  Y: 'Y',
  N: 'N',
  U: 'U',
  B: 'B',
} as const;

export type Enrolled = (typeof Enrolled)[keyof typeof Enrolled];

/**
 * Error response for 400
 * @export
 * @interface Error400
 */
export interface Error400 {
  /**
   *
   * @type {string}
   * @memberof Error400
   */
  name?: Error400NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error400
   */
  message?: Error400MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error400
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error400
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error400
   */
  information_link?: string;
}

export const Error400NameEnum = {
  InvalidRequest: 'INVALID_REQUEST',
} as const;

export type Error400NameEnum =
  (typeof Error400NameEnum)[keyof typeof Error400NameEnum];
export const Error400MessageEnum = {
  RequestIsNotWellFormedSyntacticallyIncorrectOrViolatesSchema:
    'Request is not well-formed, syntactically incorrect, or violates schema.',
} as const;

export type Error400MessageEnum =
  (typeof Error400MessageEnum)[keyof typeof Error400MessageEnum];

/**
 * Error response for 401
 * @export
 * @interface Error401
 */
export interface Error401 {
  /**
   *
   * @type {string}
   * @memberof Error401
   */
  name?: Error401NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error401
   */
  message?: Error401MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error401
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error401
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error401
   */
  information_link?: string;
}

export const Error401NameEnum = {
  AuthenticationFailure: 'AUTHENTICATION_FAILURE',
} as const;

export type Error401NameEnum =
  (typeof Error401NameEnum)[keyof typeof Error401NameEnum];
export const Error401MessageEnum = {
  AuthenticationFailedDueToMissingAuthorizationHeaderOrInvalidAuthenticationCredentials:
    'Authentication failed due to missing authorization header, or invalid authentication credentials.',
} as const;

export type Error401MessageEnum =
  (typeof Error401MessageEnum)[keyof typeof Error401MessageEnum];

/**
 * Error response for 403
 * @export
 * @interface Error403
 */
export interface Error403 {
  /**
   *
   * @type {string}
   * @memberof Error403
   */
  name?: Error403NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error403
   */
  message?: Error403MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error403
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error403
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error403
   */
  information_link?: string;
}

export const Error403NameEnum = {
  NotAuthorized: 'NOT_AUTHORIZED',
} as const;

export type Error403NameEnum =
  (typeof Error403NameEnum)[keyof typeof Error403NameEnum];
export const Error403MessageEnum = {
  AuthorizationFailedDueToInsufficientPermissions:
    'Authorization failed due to insufficient permissions.',
} as const;

export type Error403MessageEnum =
  (typeof Error403MessageEnum)[keyof typeof Error403MessageEnum];

/**
 * Error response for 404
 * @export
 * @interface Error404
 */
export interface Error404 {
  /**
   *
   * @type {string}
   * @memberof Error404
   */
  name?: Error404NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error404
   */
  message?: Error404MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error404
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error404
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error404
   */
  information_link?: string;
}

export const Error404NameEnum = {
  ResourceNotFound: 'RESOURCE_NOT_FOUND',
} as const;

export type Error404NameEnum =
  (typeof Error404NameEnum)[keyof typeof Error404NameEnum];
export const Error404MessageEnum = {
  TheSpecifiedResourceDoesNotExist: 'The specified resource does not exist.',
} as const;

export type Error404MessageEnum =
  (typeof Error404MessageEnum)[keyof typeof Error404MessageEnum];

/**
 * Error response for 409
 * @export
 * @interface Error409
 */
export interface Error409 {
  /**
   *
   * @type {string}
   * @memberof Error409
   */
  name?: Error409NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error409
   */
  message?: Error409MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error409
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error409
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error409
   */
  information_link?: string;
}

export const Error409NameEnum = {
  ResourceConflict: 'RESOURCE_CONFLICT',
} as const;

export type Error409NameEnum =
  (typeof Error409NameEnum)[keyof typeof Error409NameEnum];
export const Error409MessageEnum = {
  TheServerHasDetectedAConflictWhileProcessingThisRequest:
    'The server has detected a conflict while processing this request.',
} as const;

export type Error409MessageEnum =
  (typeof Error409MessageEnum)[keyof typeof Error409MessageEnum];

/**
 * Error response for 415
 * @export
 * @interface Error415
 */
export interface Error415 {
  /**
   *
   * @type {string}
   * @memberof Error415
   */
  name?: Error415NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error415
   */
  message?: Error415MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error415
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error415
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error415
   */
  information_link?: string;
}

export const Error415NameEnum = {
  UnsupportedMediaType: 'UNSUPPORTED_MEDIA_TYPE',
} as const;

export type Error415NameEnum =
  (typeof Error415NameEnum)[keyof typeof Error415NameEnum];
export const Error415MessageEnum = {
  TheServerDoesNotSupportTheRequestPayloadsMediaType:
    "The server does not support the request payload's media type.",
} as const;

export type Error415MessageEnum =
  (typeof Error415MessageEnum)[keyof typeof Error415MessageEnum];

/**
 * Error response for 422
 * @export
 * @interface Error422
 */
export interface Error422 {
  /**
   *
   * @type {string}
   * @memberof Error422
   */
  name?: Error422NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error422
   */
  message?: Error422MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error422
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error422
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error422
   */
  information_link?: string;
}

export const Error422NameEnum = {
  UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
} as const;

export type Error422NameEnum =
  (typeof Error422NameEnum)[keyof typeof Error422NameEnum];
export const Error422MessageEnum = {
  TheRequestedActionCouldNotBePerformedSemanticallyIncorrectOrFailedBusinessValidation:
    'The requested action could not be performed, semantically incorrect, or failed business validation.',
} as const;

export type Error422MessageEnum =
  (typeof Error422MessageEnum)[keyof typeof Error422MessageEnum];

/**
 * Error response for 500
 * @export
 * @interface Error500
 */
export interface Error500 {
  /**
   *
   * @type {string}
   * @memberof Error500
   */
  name?: Error500NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error500
   */
  message?: Error500MessageEnum;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error500
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error500
   */
  information_link?: Error500InformationLinkEnum;
}

export const Error500NameEnum = {
  InternalServerError: 'INTERNAL_SERVER_ERROR',
} as const;

export type Error500NameEnum =
  (typeof Error500NameEnum)[keyof typeof Error500NameEnum];
export const Error500MessageEnum = {
  AnInternalServerErrorOccurred: 'An internal server error occurred.',
} as const;

export type Error500MessageEnum =
  (typeof Error500MessageEnum)[keyof typeof Error500MessageEnum];
export const Error500InformationLinkEnum = {
  HttpsDeveloperPaypalComApiOrdersV2ErrorInternalServerError:
    'https://developer.paypal.com/api/orders/v2/#error-INTERNAL_SERVER_ERROR',
} as const;

export type Error500InformationLinkEnum =
  (typeof Error500InformationLinkEnum)[keyof typeof Error500InformationLinkEnum];

/**
 * Error response for 503
 * @export
 * @interface Error503
 */
export interface Error503 {
  /**
   *
   * @type {string}
   * @memberof Error503
   */
  name?: Error503NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error503
   */
  message?: Error503MessageEnum;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error503
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error503
   */
  information_link?: string;
}

export const Error503NameEnum = {
  ServiceUnavailable: 'SERVICE_UNAVAILABLE',
} as const;

export type Error503NameEnum =
  (typeof Error503NameEnum)[keyof typeof Error503NameEnum];
export const Error503MessageEnum = {
  ServiceUnavailable: 'Service Unavailable.',
} as const;

export type Error503MessageEnum =
  (typeof Error503MessageEnum)[keyof typeof Error503MessageEnum];

/**
 * @type ErrorDefault
 * The default error response.
 * @export
 */
export type ErrorDefault =
  | Error400
  | Error401
  | Error403
  | Error404
  | Error409
  | Error415
  | Error422
  | Error500
  | Error503;

/**
 * The error details. Required for client-side `4XX` errors.
 * @export
 * @interface ErrorDetails
 */
export interface ErrorDetails {
  /**
   * The field that caused the error. If this field is in the body, set this value to the field\'s JSON pointer value. Required for client-side errors.
   * @type {string}
   * @memberof ErrorDetails
   */
  field?: string;
  /**
   * The value of the field that caused the error.
   * @type {string}
   * @memberof ErrorDetails
   */
  value?: string;
  /**
   * The location of the field that caused the error. Value is `body`, `path`, or `query`.
   * @type {string}
   * @memberof ErrorDetails
   */
  location?: string;
  /**
   * The unique, fine-grained application-level error code.
   * @type {string}
   * @memberof ErrorDetails
   */
  issue: string;
  /**
   * The human-readable description for an issue. The description can change over the lifetime of an API, so clients must not depend on this value.
   * @type {string}
   * @memberof ErrorDetails
   */
  description?: string;
}
/**
 * Customizes the Vault creation flow experience for your customers.
 * @export
 * @interface ExperienceContext
 */
export interface ExperienceContext {
  /**
   * The label that overrides the business name in the PayPal account on the PayPal site.
   * @type {string}
   * @memberof ExperienceContext
   */
  brand_name?: string;
  /**
   * The [language tag](https://tools.ietf.org/html/bcp47#section-2) for the language in which to localize the error-related strings, such as messages, issues, and suggested actions. The tag is made up of the [ISO 639-2 language code](https://www.loc.gov/standards/iso639-2/php/code_list.php), the optional [ISO-15924 script tag](https://www.unicode.org/iso15924/codelists.html), and the [ISO-3166 alpha-2 country code](/api/rest/reference/country-codes/) or [M49 region code](https://unstats.un.org/unsd/methodology/m49/).
   * @type {string}
   * @memberof ExperienceContext
   */
  locale?: string;
  /**
   * The URL where the customer is redirected after customer approves leaves the flow. It is a required field for contingency flows like PayPal wallet, 3DS.
   * @type {string}
   * @memberof ExperienceContext
   */
  return_url?: string;
  /**
   * The URL where the customer is redirected after customer cancels or leaves the flow. It is a required field for contingency flows like PayPal wallet, 3DS.
   * @type {string}
   * @memberof ExperienceContext
   */
  cancel_url?: string;
  /**
   * The shipping preference. This only applies to PayPal payment source.
   * @type {string}
   * @memberof ExperienceContext
   */
  shipping_preference?: string;
  /**
   * Vault Instruction on action to be performed after a successful payer approval.
   * @type {string}
   * @memberof ExperienceContext
   */
  vault_instruction?: string;
}
/**
 * Liability shift indicator. The outcome of the issuer\'s authentication.
 * @export
 * @enum {string}
 */

export const LiabilityShift = {
  Yes: 'YES',
  No: 'NO',
  Possible: 'POSSIBLE',
  Unknown: 'UNKNOWN',
} as const;

export type LiabilityShift =
  (typeof LiabilityShift)[keyof typeof LiabilityShift];

/**
 * The request-related [HATEOAS link](/api/rest/responses/#hateoas-links) information.
 * @export
 * @interface LinkDescription
 */
export interface LinkDescription {
  /**
   * The complete target URL. To make the related call, combine the method with this [URI Template-formatted](https://tools.ietf.org/html/rfc6570) link. For pre-processing, include the `$`, `(`, and `)` characters. The `href` is the key HATEOAS component that links a completed call with a subsequent call.
   * @type {string}
   * @memberof LinkDescription
   */
  href: string;
  /**
   * The [link relation type](https://tools.ietf.org/html/rfc5988#section-4), which serves as an ID for a link that unambiguously describes the semantics of the link. See [Link Relations](https://www.iana.org/assignments/link-relations/link-relations.xhtml).
   * @type {string}
   * @memberof LinkDescription
   */
  rel: string;
  /**
   * The HTTP method required to make the related call.
   * @type {string}
   * @memberof LinkDescription
   */
  method?: LinkDescriptionMethodEnum;
}

export const LinkDescriptionMethodEnum = {
  Get: 'GET',
  Post: 'POST',
  Put: 'PUT',
  Delete: 'DELETE',
  Head: 'HEAD',
  Connect: 'CONNECT',
  Options: 'OPTIONS',
  Patch: 'PATCH',
} as const;

export type LinkDescriptionMethodEnum =
  (typeof LinkDescriptionMethodEnum)[keyof typeof LinkDescriptionMethodEnum];

/**
 * The error details.
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * The human-readable, unique name of the error.
   * @type {string}
   * @memberof ModelError
   */
  name: string;
  /**
   * The message that describes the error.
   * @type {string}
   * @memberof ModelError
   */
  message: string;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof ModelError
   */
  debug_id: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof ModelError
   */
  information_link?: string;
  /**
   * An array of additional details about the error.
   * @type {Array<ErrorDetails>}
   * @memberof ModelError
   */
  details?: Array<ErrorDetails>;
  /**
   * An array of request-related [HATEOAS links](/api/rest/responses/#hateoas-links).
   * @type {Array<LinkDescription>}
   * @memberof ModelError
   */
  links?: Array<LinkDescription>;
}
/**
 * The currency and amount for a financial transaction, such as a balance or payment due.
 * @export
 * @interface Money
 */
export interface Money {
  /**
   * The [three-character ISO-4217 currency code](/api/rest/reference/currency-codes/) that identifies the currency.
   * @type {string}
   * @memberof Money
   */
  currency_code: string;
  /**
   * The value, which might be:<ul><li>An integer for currencies like `JPY` that are not typically fractional.</li><li>A decimal fraction for currencies like `TND` that are subdivided into thousandths.</li></ul>For the required number of decimal places for a currency code, see [Currency Codes](/api/rest/reference/currency-codes/).
   * @type {string}
   * @memberof Money
   */
  value: string;
}
/**
 * The name of the party.
 * @export
 * @interface Name
 */
export interface Name {
  /**
   * The prefix, or title, to the party\'s name.
   * @type {string}
   * @memberof Name
   */
  prefix?: string;
  /**
   * When the party is a person, the party\'s given, or first, name.
   * @type {string}
   * @memberof Name
   */
  given_name?: string;
  /**
   * When the party is a person, the party\'s surname or family name. Also known as the last name. Required when the party is a person. Use also to store multiple surnames including the matronymic, or mother\'s, surname.
   * @type {string}
   * @memberof Name
   */
  surname?: string;
  /**
   * When the party is a person, the party\'s middle name. Use also to store multiple middle names including the patronymic, or father\'s, middle name.
   * @type {string}
   * @memberof Name
   */
  middle_name?: string;
  /**
   * The suffix for the party\'s name.
   * @type {string}
   * @memberof Name
   */
  suffix?: string;
  /**
   * DEPRECATED. The party\'s alternate name. Can be a business name, nickname, or any other name that cannot be split into first, last name. Required when the party is a business.
   * @type {string}
   * @memberof Name
   */
  alternate_full_name?: string;
  /**
   * When the party is a person, the party\'s full name.
   * @type {string}
   * @memberof Name
   */
  full_name?: string;
}
/**
 * Transactions status result identifier. The outcome of the issuer\'s authentication.
 * @export
 * @enum {string}
 */

export const ParesStatus = {
  Y: 'Y',
  N: 'N',
  U: 'U',
  A: 'A',
  C: 'C',
  R: 'R',
  D: 'D',
  I: 'I',
} as const;

export type ParesStatus = (typeof ParesStatus)[keyof typeof ParesStatus];

/**
 * The customer who approves and pays for the order. The customer is also known as the payer.
 * @export
 * @interface Payer
 */
export interface Payer {
  /**
   * The internationalized email address.<blockquote><strong>Note:</strong> Up to 64 characters are allowed before and 255 characters are allowed after the <code>@</code> sign. However, the generally accepted maximum length for an email address is 254 characters. The pattern verifies that an unquoted <code>@</code> sign exists.</blockquote>
   * @type {string}
   * @memberof Payer
   */
  email_address?: string;
  /**
   * The account identifier for a PayPal account.
   * @type {string}
   * @memberof Payer
   */
  payer_id?: string;
  /**
   *
   * @type {Name}
   * @memberof Payer
   */
  name?: Name;
  /**
   *
   * @type {PhoneWithType}
   * @memberof Payer
   */
  phone?: PhoneWithType;
  /**
   * The stand-alone date, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). To represent special legal values, such as a date of birth, you should use dates with no associated time or time-zone data. Whenever possible, use the standard `date_time` type. This regular expression does not validate all dates. For example, February 31 is valid and nothing is known about leap years.
   * @type {string}
   * @memberof Payer
   */
  birth_date?: string;
  /**
   *
   * @type {TaxInfo}
   * @memberof Payer
   */
  tax_info?: TaxInfo;
  /**
   *
   * @type {AddressPortable}
   * @memberof Payer
   */
  address?: AddressPortable;
}
/**
 *
 * @export
 * @interface PayerAllOf
 */
export interface PayerAllOf {
  /**
   *
   * @type {Name}
   * @memberof PayerAllOf
   */
  name?: Name;
  /**
   *
   * @type {PhoneWithType}
   * @memberof PayerAllOf
   */
  phone?: PhoneWithType;
  /**
   * The stand-alone date, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). To represent special legal values, such as a date of birth, you should use dates with no associated time or time-zone data. Whenever possible, use the standard `date_time` type. This regular expression does not validate all dates. For example, February 31 is valid and nothing is known about leap years.
   * @type {string}
   * @memberof PayerAllOf
   */
  birth_date?: string;
  /**
   *
   * @type {TaxInfo}
   * @memberof PayerAllOf
   */
  tax_info?: TaxInfo;
  /**
   *
   * @type {AddressPortable}
   * @memberof PayerAllOf
   */
  address?: AddressPortable;
}
/**
 * The customer who approves and pays for the order. The customer is also known as the payer.
 * @export
 * @interface PayerBase
 */
export interface PayerBase {
  /**
   * The internationalized email address.<blockquote><strong>Note:</strong> Up to 64 characters are allowed before and 255 characters are allowed after the <code>@</code> sign. However, the generally accepted maximum length for an email address is 254 characters. The pattern verifies that an unquoted <code>@</code> sign exists.</blockquote>
   * @type {string}
   * @memberof PayerBase
   */
  email_address?: string;
  /**
   * The account identifier for a PayPal account.
   * @type {string}
   * @memberof PayerBase
   */
  payer_id?: string;
}
/**
 * Payment Token Request where the `source` defines the type of instrument to be stored.
 * @export
 * @interface PaymentTokenRequest
 */
export interface PaymentTokenRequest {
  /**
   *
   * @type {Customer}
   * @memberof PaymentTokenRequest
   */
  customer?: Customer;
  /**
   *
   * @type {PaymentTokenRequestPaymentSource}
   * @memberof PaymentTokenRequest
   */
  payment_source: PaymentTokenRequestPaymentSource;
}
/**
 * The payment method to vault with the instrument details.
 * @export
 * @interface PaymentTokenRequestPaymentSource
 */
export interface PaymentTokenRequestPaymentSource {
  /**
   *
   * @type {CardRequest}
   * @memberof PaymentTokenRequestPaymentSource
   */
  card?: CardRequest;
  /**
   *
   * @type {TokenIdRequest}
   * @memberof PaymentTokenRequestPaymentSource
   */
  token?: TokenIdRequest;
}
/**
 * Full representation of a saved payment token.
 * @export
 * @interface PaymentTokenResponse
 */
export interface PaymentTokenResponse {
  /**
   * The PayPal-generated ID for the vault token.
   * @type {string}
   * @memberof PaymentTokenResponse
   */
  id?: string;
  /**
   *
   * @type {Customer}
   * @memberof PaymentTokenResponse
   */
  customer?: Customer;
  /**
   *
   * @type {PaymentTokenResponsePaymentSource}
   * @memberof PaymentTokenResponse
   */
  payment_source?: PaymentTokenResponsePaymentSource;
  /**
   * An array of related [HATEOAS links](/api/rest/responses/#hateoas).
   * @type {Array<LinkDescription>}
   * @memberof PaymentTokenResponse
   */
  links?: Array<LinkDescription>;
}
/**
 * The vaulted payment method details.
 * @export
 * @interface PaymentTokenResponsePaymentSource
 */
export interface PaymentTokenResponsePaymentSource {
  /**
   *
   * @type {CardResponse2}
   * @memberof PaymentTokenResponsePaymentSource
   */
  card?: CardResponse2;
  /**
   *
   * @type {PaypalWalletResponse}
   * @memberof PaymentTokenResponsePaymentSource
   */
  paypal?: PaypalWalletResponse;
  /**
   *
   * @type {VenmoResponse}
   * @memberof PaymentTokenResponsePaymentSource
   */
  venmo?: VenmoResponse;
}
/**
 * A resource representing a request to vault PayPal Wallet.
 * @export
 * @interface PaypalWalletRequest
 */
export interface PaypalWalletRequest {
  /**
   * The description displayed to the consumer on the approval flow for a digital wallet, as well as on the merchant view of the payment token management experience. exp: PayPal.com.
   * @type {string}
   * @memberof PaypalWalletRequest
   */
  description?: string;
  /**
   *
   * @type {ShippingDetail}
   * @memberof PaypalWalletRequest
   */
  shipping?: ShippingDetail;
  /**
   * Create multiple payment tokens for the same payer, merchant/platform combination. Use this when the customer has not logged in at merchant/platform. The payment token thus generated, can then also be used to create the customer account at merchant/platform. Use this also when multiple payment tokens are required for the same payer, different customer at merchant/platform. This helps to identify customers distinctly even though they may share the same PayPal account. This only applies to PayPal payment source.
   * @type {boolean}
   * @memberof PaypalWalletRequest
   */
  permit_multiple_payment_tokens?: boolean;
  /**
   * The usage type associated with a digital wallet payment token.
   * @type {string}
   * @memberof PaypalWalletRequest
   */
  usage_type?: string;
  /**
   * The customer type associated with a digital wallet payment token. This is to indicate whether the customer acting on the merchant / platform is either a business or a consumer.
   * @type {string}
   * @memberof PaypalWalletRequest
   */
  customer_type?: string;
  /**
   *
   * @type {ExperienceContext}
   * @memberof PaypalWalletRequest
   */
  experience_context?: ExperienceContext;
}
/**
 *
 * @export
 * @interface PaypalWalletRequestAllOf
 */
export interface PaypalWalletRequestAllOf {
  /**
   *
   * @type {ExperienceContext}
   * @memberof PaypalWalletRequestAllOf
   */
  experience_context?: ExperienceContext;
}
/**
 * Full representation of a PayPal Payment Token.
 * @export
 * @interface PaypalWalletResponse
 */
export interface PaypalWalletResponse {
  /**
   * The description displayed to the consumer on the approval flow for a digital wallet, as well as on the merchant view of the payment token management experience. exp: PayPal.com.
   * @type {string}
   * @memberof PaypalWalletResponse
   */
  description?: string;
  /**
   *
   * @type {ShippingDetail}
   * @memberof PaypalWalletResponse
   */
  shipping?: ShippingDetail;
  /**
   * Create multiple payment tokens for the same payer, merchant/platform combination. Use this when the customer has not logged in at merchant/platform. The payment token thus generated, can then also be used to create the customer account at merchant/platform. Use this also when multiple payment tokens are required for the same payer, different customer at merchant/platform. This helps to identify customers distinctly even though they may share the same PayPal account. This only applies to PayPal payment source.
   * @type {boolean}
   * @memberof PaypalWalletResponse
   */
  permit_multiple_payment_tokens?: boolean;
  /**
   * The usage type associated with a digital wallet payment token.
   * @type {string}
   * @memberof PaypalWalletResponse
   */
  usage_type?: string;
  /**
   * The customer type associated with a digital wallet payment token. This is to indicate whether the customer acting on the merchant / platform is either a business or a consumer.
   * @type {string}
   * @memberof PaypalWalletResponse
   */
  customer_type?: string;
  /**
   * The internationalized email address.<blockquote><strong>Note:</strong> Up to 64 characters are allowed before and 255 characters are allowed after the <code>@</code> sign. However, the generally accepted maximum length for an email address is 254 characters. The pattern verifies that an unquoted <code>@</code> sign exists.</blockquote>
   * @type {string}
   * @memberof PaypalWalletResponse
   */
  email_address?: string;
  /**
   * The account identifier for a PayPal account.
   * @type {string}
   * @memberof PaypalWalletResponse
   */
  payer_id?: string;
  /**
   *
   * @type {Name}
   * @memberof PaypalWalletResponse
   */
  name?: Name;
  /**
   *
   * @type {PhoneWithType}
   * @memberof PaypalWalletResponse
   */
  phone?: PhoneWithType;
  /**
   * The stand-alone date, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). To represent special legal values, such as a date of birth, you should use dates with no associated time or time-zone data. Whenever possible, use the standard `date_time` type. This regular expression does not validate all dates. For example, February 31 is valid and nothing is known about leap years.
   * @type {string}
   * @memberof PaypalWalletResponse
   */
  birth_date?: string;
  /**
   *
   * @type {TaxInfo}
   * @memberof PaypalWalletResponse
   */
  tax_info?: TaxInfo;
  /**
   *
   * @type {AddressPortable}
   * @memberof PaypalWalletResponse
   */
  address?: AddressPortable;
  /**
   * The account identifier for a PayPal account.
   * @type {string}
   * @memberof PaypalWalletResponse
   */
  account_id?: string;
  /**
   *
   * @type {Phone}
   * @memberof PaypalWalletResponse
   */
  phone_number?: Phone;
}
/**
 *
 * @export
 * @interface PaypalWalletResponseAllOf
 */
export interface PaypalWalletResponseAllOf {
  /**
   * The account identifier for a PayPal account.
   * @type {string}
   * @memberof PaypalWalletResponseAllOf
   */
  account_id?: string;
  /**
   *
   * @type {Phone}
   * @memberof PaypalWalletResponseAllOf
   */
  phone_number?: Phone;
}
/**
 * The phone number, in its canonical international [E.164 numbering plan format](https://www.itu.int/rec/T-REC-E.164/en).
 * @export
 * @interface Phone
 */
export interface Phone {
  /**
   * The country calling code (CC), in its canonical international [E.164 numbering plan format](https://www.itu.int/rec/T-REC-E.164/en). The combined length of the CC and the national number must not be greater than 15 digits. The national number consists of a national destination code (NDC) and subscriber number (SN).
   * @type {string}
   * @memberof Phone
   */
  country_code: string;
  /**
   * The national number, in its canonical international [E.164 numbering plan format](https://www.itu.int/rec/T-REC-E.164/en). The combined length of the country calling code (CC) and the national number must not be greater than 15 digits. The national number consists of a national destination code (NDC) and subscriber number (SN).
   * @type {string}
   * @memberof Phone
   */
  national_number: string;
  /**
   * The extension number.
   * @type {string}
   * @memberof Phone
   */
  extension_number?: string;
}
/**
 * The phone type.
 * @export
 * @enum {string}
 */

export const PhoneType = {
  Fax: 'FAX',
  Home: 'HOME',
  Mobile: 'MOBILE',
  Other: 'OTHER',
  Pager: 'PAGER',
} as const;

export type PhoneType = (typeof PhoneType)[keyof typeof PhoneType];

/**
 * The phone information.
 * @export
 * @interface PhoneWithType
 */
export interface PhoneWithType {
  /**
   *
   * @type {PhoneType}
   * @memberof PhoneWithType
   */
  phone_type?: PhoneType;
  /**
   *
   * @type {Phone}
   * @memberof PhoneWithType
   */
  phone_number: Phone;
}

/**
 * The processor information. Might be required for payment requests, such as direct credit card transactions.
 * @export
 * @interface ProcessorResponse
 */
export interface ProcessorResponse {
  /**
   * The address verification code for Visa, Discover, Mastercard, or American Express transactions.
   * @type {string}
   * @memberof ProcessorResponse
   */
  avs_code?: ProcessorResponseAvsCodeEnum;
  /**
   * The card verification value code for for Visa, Discover, Mastercard, or American Express.
   * @type {string}
   * @memberof ProcessorResponse
   */
  cvv_code?: ProcessorResponseCvvCodeEnum;
  /**
   * Processor response code for the non-PayPal payment processor errors.
   * @type {string}
   * @memberof ProcessorResponse
   */
  response_code?: ProcessorResponseResponseCodeEnum;
  /**
   * The declined payment transactions might have payment advice codes. The card networks, like Visa and Mastercard, return payment advice codes.
   * @type {string}
   * @memberof ProcessorResponse
   */
  payment_advice_code?: ProcessorResponsePaymentAdviceCodeEnum;
}

export const ProcessorResponseAvsCodeEnum = {
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  E: 'E',
  F: 'F',
  G: 'G',
  I: 'I',
  M: 'M',
  N: 'N',
  P: 'P',
  R: 'R',
  S: 'S',
  U: 'U',
  W: 'W',
  X: 'X',
  Y: 'Y',
  Z: 'Z',
  Null: 'Null',
  _0: '0',
  _1: '1',
  _2: '2',
  _3: '3',
  _4: '4',
} as const;

export type ProcessorResponseAvsCodeEnum =
  (typeof ProcessorResponseAvsCodeEnum)[keyof typeof ProcessorResponseAvsCodeEnum];
export const ProcessorResponseCvvCodeEnum = {
  E: 'E',
  I: 'I',
  M: 'M',
  N: 'N',
  P: 'P',
  S: 'S',
  U: 'U',
  X: 'X',
  AllOthers: 'All others',
  _0: '0',
  _1: '1',
  _2: '2',
  _3: '3',
  _4: '4',
} as const;

export type ProcessorResponseCvvCodeEnum =
  (typeof ProcessorResponseCvvCodeEnum)[keyof typeof ProcessorResponseCvvCodeEnum];
export const ProcessorResponseResponseCodeEnum = {
  _0000: '0000',
  _00N7: '00N7',
  _0100: '0100',
  _0390: '0390',
  _0500: '0500',
  _0580: '0580',
  _0800: '0800',
  _0880: '0880',
  _0R00: '0R00',
  _1000: '1000',
  _10Br: '10BR',
  _1300: '1300',
  _1310: '1310',
  _1312: '1312',
  _1317: '1317',
  _1320: '1320',
  _1330: '1330',
  _1335: '1335',
  _1340: '1340',
  _1350: '1350',
  _1360: '1360',
  _1370: '1370',
  _1380: '1380',
  _1382: '1382',
  _1384: '1384',
  _1390: '1390',
  _1393: '1393',
  _5100: '5100',
  _5110: '5110',
  _5120: '5120',
  _5130: '5130',
  _5135: '5135',
  _5140: '5140',
  _5150: '5150',
  _5160: '5160',
  _5170: '5170',
  _5180: '5180',
  _5190: '5190',
  _5200: '5200',
  _5210: '5210',
  _5400: '5400',
  _5500: '5500',
  _5650: '5650',
  _5700: '5700',
  _5710: '5710',
  _5800: '5800',
  _5900: '5900',
  _5910: '5910',
  _5920: '5920',
  _5930: '5930',
  _6300: '6300',
  _7600: '7600',
  _7700: '7700',
  _7710: '7710',
  _7800: '7800',
  _7900: '7900',
  _8000: '8000',
  _8010: '8010',
  _8020: '8020',
  _8030: '8030',
  _8100: '8100',
  _8110: '8110',
  _8220: '8220',
  _9100: '9100',
  _9500: '9500',
  _9510: '9510',
  _9520: '9520',
  _9530: '9530',
  _9540: '9540',
  _9600: '9600',
  Pcnr: 'PCNR',
  Pcvv: 'PCVV',
  Ppad: 'PPAD',
  Ppae: 'PPAE',
  Ppag: 'PPAG',
  Ppai: 'PPAI',
  Ppar: 'PPAR',
  Ppau: 'PPAU',
  Ppav: 'PPAV',
  Ppax: 'PPAX',
  Ppbg: 'PPBG',
  Ppc2: 'PPC2',
  Ppce: 'PPCE',
  Ppco: 'PPCO',
  Ppcr: 'PPCR',
  Ppct: 'PPCT',
  Ppcu: 'PPCU',
  Ppd3: 'PPD3',
  Ppdc: 'PPDC',
  Ppdi: 'PPDI',
  Ppdv: 'PPDV',
  Ppef: 'PPEF',
  Ppel: 'PPEL',
  Pper: 'PPER',
  Ppex: 'PPEX',
  Ppfe: 'PPFE',
  Ppfi: 'PPFI',
  Ppfr: 'PPFR',
  Ppfv: 'PPFV',
  Ppgr: 'PPGR',
  Pph1: 'PPH1',
  Ppif: 'PPIF',
  Ppii: 'PPII',
  Ppim: 'PPIM',
  Ppit: 'PPIT',
  Pplr: 'PPLR',
  Ppls: 'PPLS',
  Ppmb: 'PPMB',
  Ppmc: 'PPMC',
  Ppmd: 'PPMD',
  Ppnc: 'PPNC',
  Ppnl: 'PPNL',
  Ppnt: 'PPNT',
  Ppph: 'PPPH',
  Pppi: 'PPPI',
  Pppm: 'PPPM',
  Ppqc: 'PPQC',
  Ppre: 'PPRE',
  Pprf: 'PPRF',
  Pprr: 'PPRR',
  Pps0: 'PPS0',
  Pps1: 'PPS1',
  Pps2: 'PPS2',
  Pps3: 'PPS3',
  Pps4: 'PPS4',
  Pps5: 'PPS5',
  Pps6: 'PPS6',
  Ppsc: 'PPSC',
  Ppsd: 'PPSD',
  Ppse: 'PPSE',
  Ppte: 'PPTE',
  Pptf: 'PPTF',
  Ppti: 'PPTI',
  Pptr: 'PPTR',
  Pptt: 'PPTT',
  Pptv: 'PPTV',
  Ppua: 'PPUA',
  Ppuc: 'PPUC',
  Ppue: 'PPUE',
  Ppui: 'PPUI',
  Ppup: 'PPUP',
  Ppur: 'PPUR',
  Ppvc: 'PPVC',
  Ppve: 'PPVE',
  Ppvt: 'PPVT',
} as const;

export type ProcessorResponseResponseCodeEnum =
  (typeof ProcessorResponseResponseCodeEnum)[keyof typeof ProcessorResponseResponseCodeEnum];
export const ProcessorResponsePaymentAdviceCodeEnum = {
  _01: '01',
  _02: '02',
  _03: '03',
  _21: '21',
} as const;

export type ProcessorResponsePaymentAdviceCodeEnum =
  (typeof ProcessorResponsePaymentAdviceCodeEnum)[keyof typeof ProcessorResponsePaymentAdviceCodeEnum];

/**
 * Setup Token Request where the `source` defines the type of instrument to be stored.
 * @export
 * @interface SetupTokenRequest
 */
export interface SetupTokenRequest {
  /**
   *
   * @type {Customer}
   * @memberof SetupTokenRequest
   */
  customer?: Customer;
  /**
   *
   * @type {SetupTokenRequestPaymentSource}
   * @memberof SetupTokenRequest
   */
  payment_source: SetupTokenRequestPaymentSource;
}
/**
 * The payment method to vault with the instrument details.
 * @export
 * @interface SetupTokenRequestPaymentSource
 */
export interface SetupTokenRequestPaymentSource {
  /**
   *
   * @type {CardRequest}
   * @memberof SetupTokenRequestPaymentSource
   */
  card?: CardRequest;
  /**
   *
   * @type {PaypalWalletRequest}
   * @memberof SetupTokenRequestPaymentSource
   */
  paypal?: PaypalWalletRequest;
  /**
   *
   * @type {VenmoRequest}
   * @memberof SetupTokenRequestPaymentSource
   */
  venmo?: VenmoRequest;
  /**
   *
   * @type {TokenIdRequest}
   * @memberof SetupTokenRequestPaymentSource
   */
  token?: TokenIdRequest;
}
/**
 * Minimal representation of a cached setup token.
 * @export
 * @interface SetupTokenResponse
 */
export interface SetupTokenResponse {
  /**
   * The PayPal-generated ID for the vault token.
   * @type {string}
   * @memberof SetupTokenResponse
   */
  id?: string;
  /**
   *
   * @type {Customer}
   * @memberof SetupTokenResponse
   */
  customer?: Customer;
  /**
   * The status of the payment token.
   * @type {string}
   * @memberof SetupTokenResponse
   */
  status?: string;
  /**
   *
   * @type {SetupTokenResponsePaymentSource}
   * @memberof SetupTokenResponse
   */
  payment_source?: SetupTokenResponsePaymentSource;
  /**
   * An array of related [HATEOAS links](/api/rest/responses/#hateoas).
   * @type {Array<LinkDescription>}
   * @memberof SetupTokenResponse
   */
  links?: Array<LinkDescription>;
}
/**
 * The setup payment method details.
 * @export
 * @interface SetupTokenResponsePaymentSource
 */
export interface SetupTokenResponsePaymentSource {
  /**
   *
   * @type {CardResponse2}
   * @memberof SetupTokenResponsePaymentSource
   */
  card?: CardResponse2;
  /**
   *
   * @type {PaypalWalletResponse}
   * @memberof SetupTokenResponsePaymentSource
   */
  paypal?: PaypalWalletResponse;
  /**
   *
   * @type {VenmoResponse}
   * @memberof SetupTokenResponsePaymentSource
   */
  venmo?: VenmoResponse;
}
/**
 * The shipping details.
 * @export
 * @interface ShippingDetail
 */
export interface ShippingDetail {
  /**
   *
   * @type {Name}
   * @memberof ShippingDetail
   */
  name?: Name;
  /**
   * The method by which the payer wants to get their items from the payee e.g shipping, in-person pickup. Either type or options but not both may be present.
   * @type {string}
   * @memberof ShippingDetail
   */
  type?: ShippingDetailTypeEnum;
  /**
   *
   * @type {AddressPortable}
   * @memberof ShippingDetail
   */
  address?: AddressPortable;
}

export const ShippingDetailTypeEnum = {
  Shipping: 'SHIPPING',
  PickupInPerson: 'PICKUP_IN_PERSON',
} as const;

export type ShippingDetailTypeEnum =
  (typeof ShippingDetailTypeEnum)[keyof typeof ShippingDetailTypeEnum];

/**
 * The tax ID of the customer. The customer is also known as the payer. Both `tax_id` and `tax_id_type` are required.
 * @export
 * @interface TaxInfo
 */
export interface TaxInfo {
  /**
   * The customer\'s tax ID value.
   * @type {string}
   * @memberof TaxInfo
   */
  tax_id: string;
  /**
   * The customer\'s tax ID type.
   * @type {string}
   * @memberof TaxInfo
   */
  tax_id_type: TaxInfoTaxIdTypeEnum;
}

export const TaxInfoTaxIdTypeEnum = {
  Cpf: 'BR_CPF',
  Cnpj: 'BR_CNPJ',
} as const;

export type TaxInfoTaxIdTypeEnum =
  (typeof TaxInfoTaxIdTypeEnum)[keyof typeof TaxInfoTaxIdTypeEnum];

/**
 * Results of 3D Secure Authentication.
 * @export
 * @interface ThreeDSecureAuthenticationResponse
 */
export interface ThreeDSecureAuthenticationResponse {
  /**
   *
   * @type {ParesStatus}
   * @memberof ThreeDSecureAuthenticationResponse
   */
  authentication_status?: ParesStatus;
  /**
   *
   * @type {Enrolled}
   * @memberof ThreeDSecureAuthenticationResponse
   */
  enrollment_status?: Enrolled;
}

/**
 * The tokenized payment source to fund a payment.
 * @export
 * @interface Token
 */
export interface Token {
  /**
   * The PayPal-generated ID for the token.
   * @type {string}
   * @memberof Token
   */
  id: string;
  /**
   * The tokenization method that generated the ID.
   * @type {string}
   * @memberof Token
   */
  type: TokenTypeEnum;
}

export const TokenTypeEnum = {
  BillingAgreement: 'BILLING_AGREEMENT',
} as const;

export type TokenTypeEnum = (typeof TokenTypeEnum)[keyof typeof TokenTypeEnum];

/**
 * The Tokenized Payment Source representing a Request to Vault a Token.
 * @export
 * @interface TokenIdRequest
 */
export interface TokenIdRequest {
  /**
   * The PayPal-generated ID for the token.
   * @type {string}
   * @memberof TokenIdRequest
   */
  id: string;
  /**
   * The tokenization method that generated the ID.
   * @type {string}
   * @memberof TokenIdRequest
   */
  type: TokenIdRequestTypeEnum;
  /**
   *
   * @type {any}
   * @memberof TokenIdRequest
   */
  attributes?: any;
}

export const TokenIdRequestTypeEnum = {
  BillingAgreement: 'BILLING_AGREEMENT',
  //MEDIAOPT ADJUSTMENT START
  SetupToken: 'SETUP_TOKEN',
  //MEDIAOPT ADJUSTMENT END
} as const;

export type TokenIdRequestTypeEnum =
  (typeof TokenIdRequestTypeEnum)[keyof typeof TokenIdRequestTypeEnum];

/**
 *
 * @export
 * @interface TokenIdRequestAllOf
 */
export interface TokenIdRequestAllOf {
  /**
   *
   * @type {any}
   * @memberof TokenIdRequestAllOf
   */
  attributes?: any;
}
/**
 * A resource representing a request to vault Venmo.
 * @export
 * @interface VenmoRequest
 */
export interface VenmoRequest {
  /**
   * The description displayed to the consumer on the approval flow for a digital wallet, as well as on the merchant view of the payment token management experience. exp: PayPal.com.
   * @type {string}
   * @memberof VenmoRequest
   */
  description?: string;
  /**
   *
   * @type {ShippingDetail}
   * @memberof VenmoRequest
   */
  shipping?: ShippingDetail;
  /**
   * Create multiple payment tokens for the same payer, merchant/platform combination. Use this when the customer has not logged in at merchant/platform. The payment token thus generated, can then also be used to create the customer account at merchant/platform. Use this also when multiple payment tokens are required for the same payer, different customer at merchant/platform. This helps to identify customers distinctly even though they may share the same PayPal account. This only applies to PayPal payment source.
   * @type {boolean}
   * @memberof VenmoRequest
   */
  permit_multiple_payment_tokens?: boolean;
  /**
   * The usage type associated with a digital wallet payment token.
   * @type {string}
   * @memberof VenmoRequest
   */
  usage_type?: string;
  /**
   * The customer type associated with a digital wallet payment token. This is to indicate whether the customer acting on the merchant / platform is either a business or a consumer.
   * @type {string}
   * @memberof VenmoRequest
   */
  customer_type?: string;
  /**
   *
   * @type {ExperienceContext}
   * @memberof VenmoRequest
   */
  experience_context?: ExperienceContext;
}
/**
 * Full representation of a Venmo Payment Token.
 * @export
 * @interface VenmoResponse
 */
export interface VenmoResponse {
  /**
   * The description displayed to the consumer on the approval flow for a digital wallet, as well as on the merchant view of the payment token management experience. exp: PayPal.com.
   * @type {string}
   * @memberof VenmoResponse
   */
  description?: string;
  /**
   *
   * @type {ShippingDetail}
   * @memberof VenmoResponse
   */
  shipping?: ShippingDetail;
  /**
   * Create multiple payment tokens for the same payer, merchant/platform combination. Use this when the customer has not logged in at merchant/platform. The payment token thus generated, can then also be used to create the customer account at merchant/platform. Use this also when multiple payment tokens are required for the same payer, different customer at merchant/platform. This helps to identify customers distinctly even though they may share the same PayPal account. This only applies to PayPal payment source.
   * @type {boolean}
   * @memberof VenmoResponse
   */
  permit_multiple_payment_tokens?: boolean;
  /**
   * The usage type associated with a digital wallet payment token.
   * @type {string}
   * @memberof VenmoResponse
   */
  usage_type?: string;
  /**
   * The customer type associated with a digital wallet payment token. This is to indicate whether the customer acting on the merchant / platform is either a business or a consumer.
   * @type {string}
   * @memberof VenmoResponse
   */
  customer_type?: string;
  /**
   * The internationalized email address.<blockquote><strong>Note:</strong> Up to 64 characters are allowed before and 255 characters are allowed after the <code>@</code> sign. However, the generally accepted maximum length for an email address is 254 characters. The pattern verifies that an unquoted <code>@</code> sign exists.</blockquote>
   * @type {string}
   * @memberof VenmoResponse
   */
  email_address?: string;
  /**
   * The account identifier for a PayPal account.
   * @type {string}
   * @memberof VenmoResponse
   */
  payer_id?: string;
  /**
   *
   * @type {Name}
   * @memberof VenmoResponse
   */
  name?: Name;
  /**
   *
   * @type {PhoneWithType}
   * @memberof VenmoResponse
   */
  phone?: PhoneWithType;
  /**
   * The stand-alone date, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). To represent special legal values, such as a date of birth, you should use dates with no associated time or time-zone data. Whenever possible, use the standard `date_time` type. This regular expression does not validate all dates. For example, February 31 is valid and nothing is known about leap years.
   * @type {string}
   * @memberof VenmoResponse
   */
  birth_date?: string;
  /**
   *
   * @type {TaxInfo}
   * @memberof VenmoResponse
   */
  tax_info?: TaxInfo;
  /**
   *
   * @type {AddressPortable}
   * @memberof VenmoResponse
   */
  address?: AddressPortable;
  /**
   * The Venmo username, as chosen by the user.
   * @type {string}
   * @memberof VenmoResponse
   */
  user_name?: string;
}
/**
 *
 * @export
 * @interface VenmoResponseAllOf
 */
export interface VenmoResponseAllOf {
  /**
   * The Venmo username, as chosen by the user.
   * @type {string}
   * @memberof VenmoResponseAllOf
   */
  user_name?: string;
}
/**
 * Resource consolidating common request and response attributes for vaulting a Digital Wallet.
 * @export
 * @interface WalletBase
 */
export interface WalletBase {
  /**
   * The description displayed to the consumer on the approval flow for a digital wallet, as well as on the merchant view of the payment token management experience. exp: PayPal.com.
   * @type {string}
   * @memberof WalletBase
   */
  description?: string;
  /**
   *
   * @type {ShippingDetail}
   * @memberof WalletBase
   */
  shipping?: ShippingDetail;
  /**
   * Create multiple payment tokens for the same payer, merchant/platform combination. Use this when the customer has not logged in at merchant/platform. The payment token thus generated, can then also be used to create the customer account at merchant/platform. Use this also when multiple payment tokens are required for the same payer, different customer at merchant/platform. This helps to identify customers distinctly even though they may share the same PayPal account. This only applies to PayPal payment source.
   * @type {boolean}
   * @memberof WalletBase
   */
  permit_multiple_payment_tokens?: boolean;
  /**
   * The usage type associated with a digital wallet payment token.
   * @type {string}
   * @memberof WalletBase
   */
  usage_type?: string;
  /**
   * The customer type associated with a digital wallet payment token. This is to indicate whether the customer acting on the merchant / platform is either a business or a consumer.
   * @type {string}
   * @memberof WalletBase
   */
  customer_type?: string;
}

/**
 * PaymentTokensApi - axios parameter creator
 * @export
 */
export const PaymentTokensApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns all payment tokens for a customer.
     * @summary List all payment tokens
     * @param {string} contentType Specifies the request format.
     * @param {string} [customerId] A unique identifier representing a specific customer in merchant\&#39;s/partner\&#39;s system or records.
     * @param {number} [pageSize] A non-negative, non-zero integer indicating the maximum number of results to return at one time.
     * @param {number} [page] A non-negative, non-zero integer representing the page of the results.
     * @param {boolean} [totalRequired] A boolean indicating total number of items (total_items) and pages (total_pages) are expected to be returned in the response.
     * @param {string} [paymentSource] Filters the records for a specific payment token source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerPaymentTokensGet: async (
      contentType: string,
      customerId?: string,
      pageSize?: number,
      page?: number,
      totalRequired?: boolean,
      paymentSource?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists('customerPaymentTokensGet', 'contentType', contentType);
      const localVarPath = `/v3/vault/payment-tokens`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/vault/payment-tokens/readwrite'],
        configuration
      );

      if (customerId !== undefined) {
        localVarQueryParameter['customer_id'] = customerId;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (totalRequired !== undefined) {
        localVarQueryParameter['total_required'] = totalRequired;
      }

      if (paymentSource !== undefined) {
        localVarQueryParameter['payment_source'] = paymentSource;
      }

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a Payment Token from the given payment source and adds it to the Vault of the associated customer.
     * @summary Create payment token for a given payment source
     * @param {string} contentType Specifies the request format.
     * @param {string} payPalRequestId The server stores keys for 3 hours.
     * @param {PaymentTokenRequest} paymentTokenRequest Payment Token creation with a financial instrument and an optional customer_id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentTokensCreate: async (
      contentType: string,
      payPalRequestId: string,
      paymentTokenRequest: PaymentTokenRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists('paymentTokensCreate', 'contentType', contentType);
      // verify required parameter 'payPalRequestId' is not null or undefined
      assertParamExists(
        'paymentTokensCreate',
        'payPalRequestId',
        payPalRequestId
      );
      // verify required parameter 'paymentTokenRequest' is not null or undefined
      assertParamExists(
        'paymentTokensCreate',
        'paymentTokenRequest',
        paymentTokenRequest
      );
      const localVarPath = `/v3/vault/payment-tokens`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/vault/payment-tokens/readwrite'],
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      if (payPalRequestId != null) {
        localVarHeaderParameter['PayPal-Request-Id'] = String(payPalRequestId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        paymentTokenRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete the payment token associated with the payment token id.
     * @summary Delete payment token
     * @param {string} id A representation of a vault token.
     * @param {string} contentType Specifies the request format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentTokensDelete: async (
      id: string,
      contentType: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('paymentTokensDelete', 'id', id);
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists('paymentTokensDelete', 'contentType', contentType);
      const localVarPath = `/v3/vault/payment-tokens/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/vault/payment-tokens/readwrite'],
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a readable representation of vaulted payment source associated with the payment token id.
     * @summary Retrieve a payment token
     * @param {string} id A representation of a vault token.
     * @param {string} contentType Specifies the request format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentTokensGet: async (
      id: string,
      contentType: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('paymentTokensGet', 'id', id);
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists('paymentTokensGet', 'contentType', contentType);
      const localVarPath = `/v3/vault/payment-tokens/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/vault/payment-tokens/readwrite'],
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PaymentTokensApi - functional programming interface
 * @export
 */
export const PaymentTokensApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PaymentTokensApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all payment tokens for a customer.
     * @summary List all payment tokens
     * @param {string} contentType Specifies the request format.
     * @param {string} [customerId] A unique identifier representing a specific customer in merchant\&#39;s/partner\&#39;s system or records.
     * @param {number} [pageSize] A non-negative, non-zero integer indicating the maximum number of results to return at one time.
     * @param {number} [page] A non-negative, non-zero integer representing the page of the results.
     * @param {boolean} [totalRequired] A boolean indicating total number of items (total_items) and pages (total_pages) are expected to be returned in the response.
     * @param {string} [paymentSource] Filters the records for a specific payment token source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerPaymentTokensGet(
      contentType: string,
      customerId?: string,
      pageSize?: number,
      page?: number,
      totalRequired?: boolean,
      paymentSource?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CustomerVaultPaymentTokensResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.customerPaymentTokensGet(
          contentType,
          customerId,
          pageSize,
          page,
          totalRequired,
          paymentSource,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Creates a Payment Token from the given payment source and adds it to the Vault of the associated customer.
     * @summary Create payment token for a given payment source
     * @param {string} contentType Specifies the request format.
     * @param {string} payPalRequestId The server stores keys for 3 hours.
     * @param {PaymentTokenRequest} paymentTokenRequest Payment Token creation with a financial instrument and an optional customer_id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentTokensCreate(
      contentType: string,
      payPalRequestId: string,
      paymentTokenRequest: PaymentTokenRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PaymentTokenResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentTokensCreate(
          contentType,
          payPalRequestId,
          paymentTokenRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete the payment token associated with the payment token id.
     * @summary Delete payment token
     * @param {string} id A representation of a vault token.
     * @param {string} contentType Specifies the request format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentTokensDelete(
      id: string,
      contentType: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentTokensDelete(
          id,
          contentType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a readable representation of vaulted payment source associated with the payment token id.
     * @summary Retrieve a payment token
     * @param {string} id A representation of a vault token.
     * @param {string} contentType Specifies the request format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentTokensGet(
      id: string,
      contentType: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PaymentTokenResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentTokensGet(
          id,
          contentType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PaymentTokensApi - factory interface
 * @export
 */
export const PaymentTokensApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PaymentTokensApiFp(configuration);
  return {
    /**
     * Returns all payment tokens for a customer.
     * @summary List all payment tokens
     * @param {string} contentType Specifies the request format.
     * @param {string} [customerId] A unique identifier representing a specific customer in merchant\&#39;s/partner\&#39;s system or records.
     * @param {number} [pageSize] A non-negative, non-zero integer indicating the maximum number of results to return at one time.
     * @param {number} [page] A non-negative, non-zero integer representing the page of the results.
     * @param {boolean} [totalRequired] A boolean indicating total number of items (total_items) and pages (total_pages) are expected to be returned in the response.
     * @param {string} [paymentSource] Filters the records for a specific payment token source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerPaymentTokensGet(
      contentType: string,
      customerId?: string,
      pageSize?: number,
      page?: number,
      totalRequired?: boolean,
      paymentSource?: string,
      options?: any
    ): AxiosPromise<CustomerVaultPaymentTokensResponse> {
      return localVarFp
        .customerPaymentTokensGet(
          contentType,
          customerId,
          pageSize,
          page,
          totalRequired,
          paymentSource,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a Payment Token from the given payment source and adds it to the Vault of the associated customer.
     * @summary Create payment token for a given payment source
     * @param {string} contentType Specifies the request format.
     * @param {string} payPalRequestId The server stores keys for 3 hours.
     * @param {PaymentTokenRequest} paymentTokenRequest Payment Token creation with a financial instrument and an optional customer_id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentTokensCreate(
      contentType: string,
      payPalRequestId: string,
      paymentTokenRequest: PaymentTokenRequest,
      options?: any
    ): AxiosPromise<PaymentTokenResponse> {
      return localVarFp
        .paymentTokensCreate(
          contentType,
          payPalRequestId,
          paymentTokenRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete the payment token associated with the payment token id.
     * @summary Delete payment token
     * @param {string} id A representation of a vault token.
     * @param {string} contentType Specifies the request format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentTokensDelete(
      id: string,
      contentType: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .paymentTokensDelete(id, contentType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a readable representation of vaulted payment source associated with the payment token id.
     * @summary Retrieve a payment token
     * @param {string} id A representation of a vault token.
     * @param {string} contentType Specifies the request format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentTokensGet(
      id: string,
      contentType: string,
      options?: any
    ): AxiosPromise<PaymentTokenResponse> {
      return localVarFp
        .paymentTokensGet(id, contentType, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PaymentTokensApi - object-oriented interface
 * @export
 * @class PaymentTokensApi
 * @extends {BaseAPI}
 */
export class PaymentTokensApi extends BaseAPI {
  /**
   * Returns all payment tokens for a customer.
   * @summary List all payment tokens
   * @param {string} contentType Specifies the request format.
   * @param {string} [customerId] A unique identifier representing a specific customer in merchant\&#39;s/partner\&#39;s system or records.
   * @param {number} [pageSize] A non-negative, non-zero integer indicating the maximum number of results to return at one time.
   * @param {number} [page] A non-negative, non-zero integer representing the page of the results.
   * @param {boolean} [totalRequired] A boolean indicating total number of items (total_items) and pages (total_pages) are expected to be returned in the response.
   * @param {string} [paymentSource] Filters the records for a specific payment token source.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentTokensApi
   */
  public customerPaymentTokensGet(
    contentType: string,
    customerId?: string,
    pageSize?: number,
    page?: number,
    totalRequired?: boolean,
    paymentSource?: string,
    options?: AxiosRequestConfig
  ) {
    return PaymentTokensApiFp(this.configuration)
      .customerPaymentTokensGet(
        contentType,
        customerId,
        pageSize,
        page,
        totalRequired,
        paymentSource,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a Payment Token from the given payment source and adds it to the Vault of the associated customer.
   * @summary Create payment token for a given payment source
   * @param {string} contentType Specifies the request format.
   * @param {string} payPalRequestId The server stores keys for 3 hours.
   * @param {PaymentTokenRequest} paymentTokenRequest Payment Token creation with a financial instrument and an optional customer_id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentTokensApi
   */
  public paymentTokensCreate(
    contentType: string,
    payPalRequestId: string,
    paymentTokenRequest: PaymentTokenRequest,
    options?: AxiosRequestConfig
  ) {
    return PaymentTokensApiFp(this.configuration)
      .paymentTokensCreate(
        contentType,
        payPalRequestId,
        paymentTokenRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete the payment token associated with the payment token id.
   * @summary Delete payment token
   * @param {string} id A representation of a vault token.
   * @param {string} contentType Specifies the request format.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentTokensApi
   */
  public paymentTokensDelete(
    id: string,
    contentType: string,
    options?: AxiosRequestConfig
  ) {
    return PaymentTokensApiFp(this.configuration)
      .paymentTokensDelete(id, contentType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a readable representation of vaulted payment source associated with the payment token id.
   * @summary Retrieve a payment token
   * @param {string} id A representation of a vault token.
   * @param {string} contentType Specifies the request format.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentTokensApi
   */
  public paymentTokensGet(
    id: string,
    contentType: string,
    options?: AxiosRequestConfig
  ) {
    return PaymentTokensApiFp(this.configuration)
      .paymentTokensGet(id, contentType, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SetupTokensApi - axios parameter creator
 * @export
 */
export const SetupTokensApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a Setup Token from the given payment source and adds it to the Vault of the associated customer.
     * @summary Create a setup token
     * @param {string} contentType Specifies the request format.
     * @param {string} payPalRequestId The server stores keys for 3 hours.
     * @param {SetupTokenRequest} setupTokenRequest Setup Token creation with a instrument type optional financial instrument details and customer_id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupTokensCreate: async (
      contentType: string,
      payPalRequestId: string,
      setupTokenRequest: SetupTokenRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists('setupTokensCreate', 'contentType', contentType);
      // verify required parameter 'payPalRequestId' is not null or undefined
      assertParamExists(
        'setupTokensCreate',
        'payPalRequestId',
        payPalRequestId
      );
      // verify required parameter 'setupTokenRequest' is not null or undefined
      assertParamExists(
        'setupTokensCreate',
        'setupTokenRequest',
        setupTokenRequest
      );
      const localVarPath = `/v3/vault/setup-tokens`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/vault/payment-tokens/read'],
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      if (payPalRequestId != null) {
        localVarHeaderParameter['PayPal-Request-Id'] = String(payPalRequestId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setupTokenRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a readable representation of temporarily vaulted payment source associated with the setup token id.
     * @summary Retrieve a setup token
     * @param {string} id A representation of a vault token.
     * @param {string} contentType Specifies the request format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupTokensGet: async (
      id: string,
      contentType: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('setupTokensGet', 'id', id);
      // verify required parameter 'contentType' is not null or undefined
      assertParamExists('setupTokensGet', 'contentType', contentType);
      const localVarPath = `/v3/vault/setup-tokens/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/vault/payment-tokens/read'],
        configuration
      );

      if (contentType != null) {
        localVarHeaderParameter['Content-Type'] = String(contentType);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SetupTokensApi - functional programming interface
 * @export
 */
export const SetupTokensApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SetupTokensApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a Setup Token from the given payment source and adds it to the Vault of the associated customer.
     * @summary Create a setup token
     * @param {string} contentType Specifies the request format.
     * @param {string} payPalRequestId The server stores keys for 3 hours.
     * @param {SetupTokenRequest} setupTokenRequest Setup Token creation with a instrument type optional financial instrument details and customer_id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setupTokensCreate(
      contentType: string,
      payPalRequestId: string,
      setupTokenRequest: SetupTokenRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SetupTokenResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setupTokensCreate(
          contentType,
          payPalRequestId,
          setupTokenRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a readable representation of temporarily vaulted payment source associated with the setup token id.
     * @summary Retrieve a setup token
     * @param {string} id A representation of a vault token.
     * @param {string} contentType Specifies the request format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setupTokensGet(
      id: string,
      contentType: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SetupTokenResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setupTokensGet(
        id,
        contentType,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SetupTokensApi - factory interface
 * @export
 */
export const SetupTokensApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SetupTokensApiFp(configuration);
  return {
    /**
     * Creates a Setup Token from the given payment source and adds it to the Vault of the associated customer.
     * @summary Create a setup token
     * @param {string} contentType Specifies the request format.
     * @param {string} payPalRequestId The server stores keys for 3 hours.
     * @param {SetupTokenRequest} setupTokenRequest Setup Token creation with a instrument type optional financial instrument details and customer_id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupTokensCreate(
      contentType: string,
      payPalRequestId: string,
      setupTokenRequest: SetupTokenRequest,
      options?: any
    ): AxiosPromise<SetupTokenResponse> {
      return localVarFp
        .setupTokensCreate(
          contentType,
          payPalRequestId,
          setupTokenRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a readable representation of temporarily vaulted payment source associated with the setup token id.
     * @summary Retrieve a setup token
     * @param {string} id A representation of a vault token.
     * @param {string} contentType Specifies the request format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupTokensGet(
      id: string,
      contentType: string,
      options?: any
    ): AxiosPromise<SetupTokenResponse> {
      return localVarFp
        .setupTokensGet(id, contentType, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SetupTokensApi - object-oriented interface
 * @export
 * @class SetupTokensApi
 * @extends {BaseAPI}
 */
export class SetupTokensApi extends BaseAPI {
  /**
   * Creates a Setup Token from the given payment source and adds it to the Vault of the associated customer.
   * @summary Create a setup token
   * @param {string} contentType Specifies the request format.
   * @param {string} payPalRequestId The server stores keys for 3 hours.
   * @param {SetupTokenRequest} setupTokenRequest Setup Token creation with a instrument type optional financial instrument details and customer_id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SetupTokensApi
   */
  public setupTokensCreate(
    contentType: string,
    payPalRequestId: string,
    setupTokenRequest: SetupTokenRequest,
    options?: AxiosRequestConfig
  ) {
    return SetupTokensApiFp(this.configuration)
      .setupTokensCreate(
        contentType,
        payPalRequestId,
        setupTokenRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a readable representation of temporarily vaulted payment source associated with the setup token id.
   * @summary Retrieve a setup token
   * @param {string} id A representation of a vault token.
   * @param {string} contentType Specifies the request format.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SetupTokensApi
   */
  public setupTokensGet(
    id: string,
    contentType: string,
    options?: AxiosRequestConfig
  ) {
    return SetupTokensApiFp(this.configuration)
      .setupTokensGet(id, contentType, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
