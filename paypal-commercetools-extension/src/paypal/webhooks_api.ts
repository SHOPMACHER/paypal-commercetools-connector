/* tslint:disable */
/* eslint-disable */
/**
 * Webhooks Management
 * The PayPal REST APIs use <a href=\"/docs/api/notifications/webhooks/\"/>webhooks</a> for event notification. Webhooks are HTTP callbacks that receive notification messages for events. After you configure a webhook listener for your app, you can <a href=\"#webhooks_create\">create a webhook</a>, which subscribes the webhook listener for your app to events. The <code>notifications</code> namespace contains resource collections for webhooks.
 *
 * The version of the OpenAPI document: 1.11
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { AxiosInstance, AxiosPromise, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import type { Configuration } from './configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import type { RequestArgs } from './base';
import {
  assertParamExists,
  createRequestFunction,
  DUMMY_BASE_URL,
  serializeDataIfNeeded,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
// @ts-ignore
import { BaseAPI, BASE_PATH } from './base';

/**
 * Error response for 400
 * @export
 * @interface Error400
 */
export interface Error400 {
  /**
   *
   * @type {string}
   * @memberof Error400
   */
  name?: Error400NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error400
   */
  message?: Error400MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error400
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error400
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error400
   */
  information_link?: string;
}

export const Error400NameEnum = {
  InvalidRequest: 'INVALID_REQUEST',
} as const;

export type Error400NameEnum =
  (typeof Error400NameEnum)[keyof typeof Error400NameEnum];
export const Error400MessageEnum = {
  RequestIsNotWellFormedSyntacticallyIncorrectOrViolatesSchema:
    'Request is not well-formed, syntactically incorrect, or violates schema.',
} as const;

export type Error400MessageEnum =
  (typeof Error400MessageEnum)[keyof typeof Error400MessageEnum];

/**
 * Error response for 401
 * @export
 * @interface Error401
 */
export interface Error401 {
  /**
   *
   * @type {string}
   * @memberof Error401
   */
  name?: Error401NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error401
   */
  message?: Error401MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error401
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error401
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error401
   */
  information_link?: string;
}

export const Error401NameEnum = {
  AuthenticationFailure: 'AUTHENTICATION_FAILURE',
} as const;

export type Error401NameEnum =
  (typeof Error401NameEnum)[keyof typeof Error401NameEnum];
export const Error401MessageEnum = {
  AuthenticationFailedDueToMissingAuthorizationHeaderOrInvalidAuthenticationCredentials:
    'Authentication failed due to missing authorization header, or invalid authentication credentials.',
} as const;

export type Error401MessageEnum =
  (typeof Error401MessageEnum)[keyof typeof Error401MessageEnum];

/**
 * Error response for 403
 * @export
 * @interface Error403
 */
export interface Error403 {
  /**
   *
   * @type {string}
   * @memberof Error403
   */
  name?: Error403NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error403
   */
  message?: Error403MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error403
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error403
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error403
   */
  information_link?: string;
}

export const Error403NameEnum = {
  NotAuthorized: 'NOT_AUTHORIZED',
} as const;

export type Error403NameEnum =
  (typeof Error403NameEnum)[keyof typeof Error403NameEnum];
export const Error403MessageEnum = {
  AuthorizationFailedDueToInsufficientPermissions:
    'Authorization failed due to insufficient permissions.',
} as const;

export type Error403MessageEnum =
  (typeof Error403MessageEnum)[keyof typeof Error403MessageEnum];

/**
 * Error response for 404
 * @export
 * @interface Error404
 */
export interface Error404 {
  /**
   *
   * @type {string}
   * @memberof Error404
   */
  name?: Error404NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error404
   */
  message?: Error404MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error404
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error404
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error404
   */
  information_link?: string;
}

export const Error404NameEnum = {
  ResourceNotFound: 'RESOURCE_NOT_FOUND',
} as const;

export type Error404NameEnum =
  (typeof Error404NameEnum)[keyof typeof Error404NameEnum];
export const Error404MessageEnum = {
  TheSpecifiedResourceDoesNotExist: 'The specified resource does not exist.',
} as const;

export type Error404MessageEnum =
  (typeof Error404MessageEnum)[keyof typeof Error404MessageEnum];

/**
 * Error response for 409
 * @export
 * @interface Error409
 */
export interface Error409 {
  /**
   *
   * @type {string}
   * @memberof Error409
   */
  name?: Error409NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error409
   */
  message?: Error409MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error409
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error409
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error409
   */
  information_link?: string;
}

export const Error409NameEnum = {
  ResourceConflict: 'RESOURCE_CONFLICT',
} as const;

export type Error409NameEnum =
  (typeof Error409NameEnum)[keyof typeof Error409NameEnum];
export const Error409MessageEnum = {
  TheServerHasDetectedAConflictWhileProcessingThisRequest:
    'The server has detected a conflict while processing this request.',
} as const;

export type Error409MessageEnum =
  (typeof Error409MessageEnum)[keyof typeof Error409MessageEnum];

/**
 * Error response for 415
 * @export
 * @interface Error415
 */
export interface Error415 {
  /**
   *
   * @type {string}
   * @memberof Error415
   */
  name?: Error415NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error415
   */
  message?: Error415MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error415
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error415
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error415
   */
  information_link?: string;
}

export const Error415NameEnum = {
  UnsupportedMediaType: 'UNSUPPORTED_MEDIA_TYPE',
} as const;

export type Error415NameEnum =
  (typeof Error415NameEnum)[keyof typeof Error415NameEnum];
export const Error415MessageEnum = {
  TheServerDoesNotSupportTheRequestPayloadsMediaType:
    "The server does not support the request payload's media type.",
} as const;

export type Error415MessageEnum =
  (typeof Error415MessageEnum)[keyof typeof Error415MessageEnum];

/**
 * Error response for 422
 * @export
 * @interface Error422
 */
export interface Error422 {
  /**
   *
   * @type {string}
   * @memberof Error422
   */
  name?: Error422NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error422
   */
  message?: Error422MessageEnum;
  /**
   *
   * @type {Array<ErrorDetails>}
   * @memberof Error422
   */
  issues?: Array<ErrorDetails>;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error422
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error422
   */
  information_link?: string;
}

export const Error422NameEnum = {
  UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
} as const;

export type Error422NameEnum =
  (typeof Error422NameEnum)[keyof typeof Error422NameEnum];
export const Error422MessageEnum = {
  TheRequestedActionCouldNotBePerformedSemanticallyIncorrectOrFailedBusinessValidation:
    'The requested action could not be performed, semantically incorrect, or failed business validation.',
} as const;

export type Error422MessageEnum =
  (typeof Error422MessageEnum)[keyof typeof Error422MessageEnum];

/**
 * Error response for 500
 * @export
 * @interface Error500
 */
export interface Error500 {
  /**
   *
   * @type {string}
   * @memberof Error500
   */
  name?: Error500NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error500
   */
  message?: Error500MessageEnum;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error500
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error500
   */
  information_link?: Error500InformationLinkEnum;
}

export const Error500NameEnum = {
  InternalServerError: 'INTERNAL_SERVER_ERROR',
} as const;

export type Error500NameEnum =
  (typeof Error500NameEnum)[keyof typeof Error500NameEnum];
export const Error500MessageEnum = {
  AnInternalServerErrorOccurred: 'An internal server error occurred.',
} as const;

export type Error500MessageEnum =
  (typeof Error500MessageEnum)[keyof typeof Error500MessageEnum];
export const Error500InformationLinkEnum = {
  HttpsDeveloperPaypalComApiOrdersV2ErrorInternalServerError:
    'https://developer.paypal.com/api/orders/v2/#error-INTERNAL_SERVER_ERROR',
} as const;

export type Error500InformationLinkEnum =
  (typeof Error500InformationLinkEnum)[keyof typeof Error500InformationLinkEnum];

/**
 * Error response for 503
 * @export
 * @interface Error503
 */
export interface Error503 {
  /**
   *
   * @type {string}
   * @memberof Error503
   */
  name?: Error503NameEnum;
  /**
   *
   * @type {string}
   * @memberof Error503
   */
  message?: Error503MessageEnum;
  /**
   * The PayPal internal ID. Used for correlation purposes.
   * @type {string}
   * @memberof Error503
   */
  debug_id?: string;
  /**
   * The information link, or URI, that shows detailed information about this error for the developer.
   * @type {string}
   * @memberof Error503
   */
  information_link?: string;
}

export const Error503NameEnum = {
  ServiceUnavailable: 'SERVICE_UNAVAILABLE',
} as const;

export type Error503NameEnum =
  (typeof Error503NameEnum)[keyof typeof Error503NameEnum];
export const Error503MessageEnum = {
  ServiceUnavailable: 'Service Unavailable.',
} as const;

export type Error503MessageEnum =
  (typeof Error503MessageEnum)[keyof typeof Error503MessageEnum];

/**
 * @type ErrorDefault
 * The default error response.
 * @export
 */
export type ErrorDefault =
  | Error400
  | Error401
  | Error403
  | Error404
  | Error409
  | Error415
  | Error422
  | Error500
  | Error503;

/**
 * The error details. Required for client-side `4XX` errors.
 * @export
 * @interface ErrorDetails
 */
export interface ErrorDetails {
  /**
   * The field that caused the error. If this field is in the body, set this value to the field\'s JSON pointer value. Required for client-side errors.
   * @type {string}
   * @memberof ErrorDetails
   */
  field?: string;
  /**
   * The value of the field that caused the error.
   * @type {string}
   * @memberof ErrorDetails
   */
  value?: string;
  /**
   * The location of the field that caused the error. Value is `body`, `path`, or `query`.
   * @type {string}
   * @memberof ErrorDetails
   */
  location?: string;
  /**
   * The unique, fine-grained application-level error code.
   * @type {string}
   * @memberof ErrorDetails
   */
  issue: string;
  /**
   * The human-readable description for an issue. The description can change over the lifetime of an API, so clients must not depend on this value.
   * @type {string}
   * @memberof ErrorDetails
   */
  description?: string;
}
/**
 * A webhook event notification.
 * @export
 * @interface Event
 */
export interface Event {
  /**
   * The ID of the webhook event notification.
   * @type {string}
   * @memberof Event
   */
  id?: string;
  /**
   * The date and time when the webhook event notification was created, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6).
   * @type {string}
   * @memberof Event
   */
  create_time?: string;
  /**
   * The name of the resource related to the webhook notification event.
   * @type {string}
   * @memberof Event
   */
  resource_type?: string;
  /**
   * The event version in the webhook notification.
   * @type {string}
   * @memberof Event
   * @deprecated
   */
  event_version?: string;
  /**
   * The event that triggered the webhook event notification.
   * @type {string}
   * @memberof Event
   */
  event_type?: string;
  /**
   * A summary description for the event notification.
   * @type {string}
   * @memberof Event
   */
  summary?: string;
  /**
   * The resource version in the webhook notification.
   * @type {string}
   * @memberof Event
   */
  resource_version?: string;
  /**
   * The resource that triggered the webhook event notification.
   * @type {{ [key: string]: any; }}
   * @memberof Event
   */
  resource?: { [key: string]: any };
  /**
   * An array of request-related [HATEOAS links](/docs/api/reference/api-responses/#hateoas-links).
   * @type {Array<LinkDescription>}
   * @memberof Event
   */
  links?: Array<LinkDescription>;
}
/**
 * A list of webhooks events.
 * @export
 * @interface EventList
 */
export interface EventList {
  /**
   * An array of webhooks events.
   * @type {Array<Event>}
   * @memberof EventList
   */
  events?: Array<Event>;
  /**
   * The number of items in each range of results. Note that the response might have fewer items than the requested `page_size` value.
   * @type {number}
   * @memberof EventList
   */
  count?: number;
  /**
   * An array of request-related [HATEOAS links](/docs/api/reference/api-responses/#hateoas-links).
   * @type {Array<LinkDescription>}
   * @memberof EventList
   */
  links?: Array<LinkDescription>;
}
/**
 * Resends a webhook event notification, by ID.
 * @export
 * @interface EventResend
 */
export interface EventResend {
  /**
   * An array of webhook account IDs.
   * @type {Array<string>}
   * @memberof EventResend
   */
  webhook_ids?: Array<string>;
}
/**
 * An event type.
 * @export
 * @interface EventType
 */
export interface EventType {
  /**
   * The unique event name.<blockquote><strong>Note:</strong> To subscribe to all events, including events as they are added, specify an `*` as the value to represent a wildcard.</blockquote>
   * @type {string}
   * @memberof EventType
   */
  name: string;
  /**
   * A human-readable description of the event.
   * @type {string}
   * @memberof EventType
   */
  description?: string;
  /**
   * The status of a webhook event.
   * @type {string}
   * @memberof EventType
   */
  status?: string;
  /**
   * Identifier for the event type example: 1.0/2.0 etc.
   * @type {Array<string>}
   * @memberof EventType
   */
  resource_versions?: Array<string>;
}
/**
 * A list of webhook events.
 * @export
 * @interface EventTypeList
 */
export interface EventTypeList {
  /**
   * An array of webhook events.
   * @type {Array<EventType>}
   * @memberof EventTypeList
   */
  event_types?: Array<EventType>;
}
/**
 * The request-related [HATEOAS link](/docs/api/reference/api-responses/#hateoas-links) information.
 * @export
 * @interface LinkDescription
 */
export interface LinkDescription {
  /**
   * The complete target URL. To make the related call, combine the method with this [URI Template-formatted](https://tools.ietf.org/html/rfc6570) link. For pre-processing, include the `$`, `(`, and `)` characters. The `href` is the key HATEOAS component that links a completed call with a subsequent call.
   * @type {string}
   * @memberof LinkDescription
   */
  href: string;
  /**
   * The [link relation type](https://tools.ietf.org/html/rfc5988#section-4), which serves as an ID for a link that unambiguously describes the semantics of the link. See [Link Relations](https://www.iana.org/assignments/link-relations/link-relations.xhtml).
   * @type {string}
   * @memberof LinkDescription
   */
  rel: string;
  /**
   * The HTTP method required to make the related call.
   * @type {string}
   * @memberof LinkDescription
   */
  method?: LinkDescriptionMethodEnum;
}

export const LinkDescriptionMethodEnum = {
  Get: 'GET',
  Post: 'POST',
  Put: 'PUT',
  Delete: 'DELETE',
  Head: 'HEAD',
  Connect: 'CONNECT',
  Options: 'OPTIONS',
  Patch: 'PATCH',
} as const;

export type LinkDescriptionMethodEnum =
  (typeof LinkDescriptionMethodEnum)[keyof typeof LinkDescriptionMethodEnum];

/**
 * The JSON patch object to apply partial updates to resources.
 * @export
 * @interface Patch
 */
export interface Patch {
  /**
   * The operation.
   * @type {string}
   * @memberof Patch
   */
  op: PatchOpEnum;
  /**
   * The <a href=\"https://tools.ietf.org/html/rfc6901\">JSON Pointer</a> to the target document location at which to complete the operation.
   * @type {string}
   * @memberof Patch
   */
  path?: string;
  /**
   * The value to apply. The <code>remove</code> operation does not require a value.
   * @type {any}
   * @memberof Patch
   */
  value?: any;
  /**
   * The <a href=\"https://tools.ietf.org/html/rfc6901\">JSON Pointer</a> to the target document location from which to move the value. Required for the <code>move</code> operation.
   * @type {string}
   * @memberof Patch
   */
  from?: string;
}

export const PatchOpEnum = {
  Add: 'add',
  Remove: 'remove',
  Replace: 'replace',
  Move: 'move',
  Copy: 'copy',
  Test: 'test',
} as const;

export type PatchOpEnum = (typeof PatchOpEnum)[keyof typeof PatchOpEnum];

/**
 * Simulates a mock webhook event.
 * @export
 * @interface SimulateEvent
 */
export interface SimulateEvent {
  /**
   * The ID of the webhook. If omitted, the URL is required.
   * @type {string}
   * @memberof SimulateEvent
   */
  webhook_id?: string;
  /**
   * The URL for the webhook endpoint. If omitted, the webhook ID is required.
   * @type {string}
   * @memberof SimulateEvent
   */
  url?: string;
  /**
   * The event name. Specify one of the subscribed events. For each request, provide only one event.
   * @type {string}
   * @memberof SimulateEvent
   */
  event_type: string;
  /**
   * The identifier for event type ex: 1.0/2.0 etc.
   * @type {string}
   * @memberof SimulateEvent
   */
  resource_version?: string;
}
/**
 * A verify webhook signature request.
 * @export
 * @interface VerifyWebhookSignature
 */
export interface VerifyWebhookSignature {
  /**
   * The algorithm that PayPal uses to generate the signature and that you can use to verify the signature. Extract this value from the `PAYPAL-AUTH-ALGO` response header, which is received with the webhook notification.
   * @type {string}
   * @memberof VerifyWebhookSignature
   */
  auth_algo: string;
  /**
   * The X.509 public key certificate. Download the certificate from this URL and use it to verify the signature. Extract this value from the `PAYPAL-CERT-URL` response header, which is received with the webhook notification.
   * @type {string}
   * @memberof VerifyWebhookSignature
   */
  cert_url: string;
  /**
   * The ID of the HTTP transmission. Contained in the `PAYPAL-TRANSMISSION-ID` header of the notification message.
   * @type {string}
   * @memberof VerifyWebhookSignature
   */
  transmission_id: string;
  /**
   * The PayPal-generated asymmetric signature. Appears in the `PAYPAL-TRANSMISSION-SIG` header of the notification message.
   * @type {string}
   * @memberof VerifyWebhookSignature
   */
  transmission_sig: string;
  /**
   * The date and time of the HTTP transmission, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Appears in the `PAYPAL-TRANSMISSION-TIME` header of the notification message.
   * @type {string}
   * @memberof VerifyWebhookSignature
   */
  transmission_time: string;
  /**
   * The ID of the webhook as configured in your Developer Portal account.
   * @type {string}
   * @memberof VerifyWebhookSignature
   */
  webhook_id: string;
  /**
   *
   * @type {Event}
   * @memberof VerifyWebhookSignature
   */
  webhook_event: Event;
}
/**
 * The verify webhook signature response.
 * @export
 * @interface VerifyWebhookSignatureResponse
 */
export interface VerifyWebhookSignatureResponse {
  /**
   * The status of the signature verification.
   * @type {string}
   * @memberof VerifyWebhookSignatureResponse
   */
  verification_status: VerifyWebhookSignatureResponseVerificationStatusEnum;
}

export const VerifyWebhookSignatureResponseVerificationStatusEnum = {
  Success: 'SUCCESS',
  Failure: 'FAILURE',
} as const;

export type VerifyWebhookSignatureResponseVerificationStatusEnum =
  (typeof VerifyWebhookSignatureResponseVerificationStatusEnum)[keyof typeof VerifyWebhookSignatureResponseVerificationStatusEnum];

/**
 * One or more webhook objects.
 * @export
 * @interface Webhook
 */
export interface Webhook {
  /**
   * The ID of the webhook.
   * @type {string}
   * @memberof Webhook
   */
  id?: string;
  /**
   * The URL that is configured to listen on `localhost` for incoming `POST` notification messages that contain event information.
   * @type {string}
   * @memberof Webhook
   */
  url: string;
  /**
   * An array of events to which to subscribe your webhook. To subscribe to all events, including events as they are added, specify the asterisk wild card. To replace the `event_types` array, specify the asterisk wild card. To list all supported events, <a href=\"#event-type_list\">list available events</a>.
   * @type {Array<EventType>}
   * @memberof Webhook
   */
  event_types: Array<EventType>;
  /**
   * An array of request-related [HATEOAS links](/docs/api/reference/api-responses/#hateoas-links/).
   * @type {Array<LinkDescription>}
   * @memberof Webhook
   */
  links?: Array<LinkDescription>;
}
/**
 * A list of webhooks.
 * @export
 * @interface WebhookList
 */
export interface WebhookList {
  /**
   * An array of webhooks.
   * @type {Array<Webhook>}
   * @memberof WebhookList
   */
  webhooks?: Array<Webhook>;
}
/**
 * A list of webhook lookups.
 * @export
 * @interface WebhookLookupList
 */
export interface WebhookLookupList {
  /**
   * An array of webhook lookups.
   * @type {Array<WebhooksLookup>}
   * @memberof WebhookLookupList
   */
  webhooks_lookups?: Array<WebhooksLookup>;
}
/**
 * The webhook lookup details.
 * @export
 * @interface WebhooksLookup
 */
export interface WebhooksLookup {
  /**
   * The ID of the webhook lookup.
   * @type {string}
   * @memberof WebhooksLookup
   */
  id?: string;
  /**
   * The application client ID.
   * @type {string}
   * @memberof WebhooksLookup
   */
  client_id?: string;
  /**
   * An array of request-related [HATEOAS links](/docs/api/reference/api-responses/#hateoas-links/).
   * @type {Array<LinkDescription>}
   * @memberof WebhooksLookup
   */
  links?: Array<LinkDescription>;
}

/**
 * SimulateEventApi - axios parameter creator
 * @export
 */
export const SimulateEventApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Simulates a webhook event. In the JSON request body, specify a sample payload.<br>You need to subscribe to the following webhook events for Pay upon Invoice:<br><table><thead><tr><th>Event</th><th>Trigger</th></tr></thead><tbody><tr><td><code>PAYMENT.CAPTURE.COMPLETED</code></td><td>A payment capture completes.</td></tr><tr><td><code>PAYMENT.CAPTURE.DENIED</code></td><td>A payment capture is denied.</td></tr><tr><td><code>CHECKOUT.PAYMENT-APPROVAL.REVERSED</code></td><td>PayPal reverses a payment capture.</td></tr></tbody></table>
     * @summary Simulate webhook event
     * @param {SimulateEvent} [simulateEvent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    simulateEventPost: async (
      simulateEvent?: SimulateEvent,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/notifications/simulate-event`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        simulateEvent,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SimulateEventApi - functional programming interface
 * @export
 */
export const SimulateEventApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SimulateEventApiAxiosParamCreator(configuration);
  return {
    /**
     * Simulates a webhook event. In the JSON request body, specify a sample payload.<br>You need to subscribe to the following webhook events for Pay upon Invoice:<br><table><thead><tr><th>Event</th><th>Trigger</th></tr></thead><tbody><tr><td><code>PAYMENT.CAPTURE.COMPLETED</code></td><td>A payment capture completes.</td></tr><tr><td><code>PAYMENT.CAPTURE.DENIED</code></td><td>A payment capture is denied.</td></tr><tr><td><code>CHECKOUT.PAYMENT-APPROVAL.REVERSED</code></td><td>PayPal reverses a payment capture.</td></tr></tbody></table>
     * @summary Simulate webhook event
     * @param {SimulateEvent} [simulateEvent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async simulateEventPost(
      simulateEvent?: SimulateEvent,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.simulateEventPost(
          simulateEvent,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SimulateEventApi - factory interface
 * @export
 */
export const SimulateEventApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SimulateEventApiFp(configuration);
  return {
    /**
     * Simulates a webhook event. In the JSON request body, specify a sample payload.<br>You need to subscribe to the following webhook events for Pay upon Invoice:<br><table><thead><tr><th>Event</th><th>Trigger</th></tr></thead><tbody><tr><td><code>PAYMENT.CAPTURE.COMPLETED</code></td><td>A payment capture completes.</td></tr><tr><td><code>PAYMENT.CAPTURE.DENIED</code></td><td>A payment capture is denied.</td></tr><tr><td><code>CHECKOUT.PAYMENT-APPROVAL.REVERSED</code></td><td>PayPal reverses a payment capture.</td></tr></tbody></table>
     * @summary Simulate webhook event
     * @param {SimulateEvent} [simulateEvent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    simulateEventPost(
      simulateEvent?: SimulateEvent,
      options?: any
    ): AxiosPromise<Event> {
      return localVarFp
        .simulateEventPost(simulateEvent, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SimulateEventApi - object-oriented interface
 * @export
 * @class SimulateEventApi
 * @extends {BaseAPI}
 */
export class SimulateEventApi extends BaseAPI {
  /**
   * Simulates a webhook event. In the JSON request body, specify a sample payload.<br>You need to subscribe to the following webhook events for Pay upon Invoice:<br><table><thead><tr><th>Event</th><th>Trigger</th></tr></thead><tbody><tr><td><code>PAYMENT.CAPTURE.COMPLETED</code></td><td>A payment capture completes.</td></tr><tr><td><code>PAYMENT.CAPTURE.DENIED</code></td><td>A payment capture is denied.</td></tr><tr><td><code>CHECKOUT.PAYMENT-APPROVAL.REVERSED</code></td><td>PayPal reverses a payment capture.</td></tr></tbody></table>
   * @summary Simulate webhook event
   * @param {SimulateEvent} [simulateEvent]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SimulateEventApi
   */
  public simulateEventPost(
    simulateEvent?: SimulateEvent,
    options?: AxiosRequestConfig
  ) {
    return SimulateEventApiFp(this.configuration)
      .simulateEventPost(simulateEvent, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * VerifyWebhookSignatureApi - axios parameter creator
 * @export
 */
export const VerifyWebhookSignatureApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Verifies a webhook signature.
     * @summary Verify webhook signature
     * @param {VerifyWebhookSignature} [verifyWebhookSignature]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyWebhookSignaturePost: async (
      verifyWebhookSignature?: VerifyWebhookSignature,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/notifications/verify-webhook-signature`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        verifyWebhookSignature,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VerifyWebhookSignatureApi - functional programming interface
 * @export
 */
export const VerifyWebhookSignatureApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    VerifyWebhookSignatureApiAxiosParamCreator(configuration);
  return {
    /**
     * Verifies a webhook signature.
     * @summary Verify webhook signature
     * @param {VerifyWebhookSignature} [verifyWebhookSignature]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyWebhookSignaturePost(
      verifyWebhookSignature?: VerifyWebhookSignature,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<VerifyWebhookSignatureResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifyWebhookSignaturePost(
          verifyWebhookSignature,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * VerifyWebhookSignatureApi - factory interface
 * @export
 */
export const VerifyWebhookSignatureApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = VerifyWebhookSignatureApiFp(configuration);
  return {
    /**
     * Verifies a webhook signature.
     * @summary Verify webhook signature
     * @param {VerifyWebhookSignature} [verifyWebhookSignature]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyWebhookSignaturePost(
      verifyWebhookSignature?: VerifyWebhookSignature,
      options?: any
    ): AxiosPromise<VerifyWebhookSignatureResponse> {
      return localVarFp
        .verifyWebhookSignaturePost(verifyWebhookSignature, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * VerifyWebhookSignatureApi - object-oriented interface
 * @export
 * @class VerifyWebhookSignatureApi
 * @extends {BaseAPI}
 */
export class VerifyWebhookSignatureApi extends BaseAPI {
  /**
   * Verifies a webhook signature.
   * @summary Verify webhook signature
   * @param {VerifyWebhookSignature} [verifyWebhookSignature]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifyWebhookSignatureApi
   */
  public verifyWebhookSignaturePost(
    verifyWebhookSignature?: VerifyWebhookSignature,
    options?: AxiosRequestConfig
  ) {
    return VerifyWebhookSignatureApiFp(this.configuration)
      .verifyWebhookSignaturePost(verifyWebhookSignature, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Lists event subscriptions for a webhook, by ID.
     * @summary List event subscriptions for webhook
     * @param {string} webhookId The ID of the webhook for which to list subscriptions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventTypesList: async (
      webhookId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists('eventTypesList', 'webhookId', webhookId);
      const localVarPath =
        `/v1/notifications/webhooks/{webhook_id}/event-types`.replace(
          `{${'webhook_id'}}`,
          encodeURIComponent(String(webhookId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a webhook, by ID.
     * @summary Delete webhook
     * @param {string} webhookId The ID of the webhook for which to list subscriptions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksDelete: async (
      webhookId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists('webhooksDelete', 'webhookId', webhookId);
      const localVarPath = `/v1/notifications/webhooks/{webhook_id}`.replace(
        `{${'webhook_id'}}`,
        encodeURIComponent(String(webhookId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Shows details for a webhook, by ID.
     * @summary Show webhook details
     * @param {string} webhookId The ID of the webhook for which to list subscriptions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksGet: async (
      webhookId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists('webhooksGet', 'webhookId', webhookId);
      const localVarPath = `/v1/notifications/webhooks/{webhook_id}`.replace(
        `{${'webhook_id'}}`,
        encodeURIComponent(String(webhookId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists webhooks for an app.
     * @summary List webhooks
     * @param {'APPLICATION' | 'ACCOUNT'} [anchorType] Filters the webhooks in the response by an anchor type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksList: async (
      anchorType?: 'APPLICATION' | 'ACCOUNT',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/notifications/webhooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      if (anchorType !== undefined) {
        localVarQueryParameter['anchor_type'] = anchorType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Subscribes your webhook listener to events.
     * @summary Create webhook
     * @param {Webhook} [webhook]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksPost: async (
      webhook?: Webhook,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/notifications/webhooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        webhook,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates a webhook to replace webhook fields with new values. Supports only the `replace` operation. Pass a `json_patch` object with `replace` operation and `path`, which is `/url` for a URL or `/event_types` for events. The `value` is either the URL or a list of events.
     * @summary Update webhook
     * @param {string} webhookId The ID of the webhook for which to list subscriptions.
     * @param {Array<Patch>} [patch]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksUpdate: async (
      webhookId: string,
      patch?: Array<Patch>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists('webhooksUpdate', 'webhookId', webhookId);
      const localVarPath = `/v1/notifications/webhooks/{webhook_id}`.replace(
        `{${'webhook_id'}}`,
        encodeURIComponent(String(webhookId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patch,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration);
  return {
    /**
     * Lists event subscriptions for a webhook, by ID.
     * @summary List event subscriptions for webhook
     * @param {string} webhookId The ID of the webhook for which to list subscriptions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eventTypesList(
      webhookId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventTypeList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.eventTypesList(
        webhookId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Deletes a webhook, by ID.
     * @summary Delete webhook
     * @param {string} webhookId The ID of the webhook for which to list subscriptions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksDelete(
      webhookId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksDelete(
        webhookId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Shows details for a webhook, by ID.
     * @summary Show webhook details
     * @param {string} webhookId The ID of the webhook for which to list subscriptions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksGet(
      webhookId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksGet(
        webhookId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists webhooks for an app.
     * @summary List webhooks
     * @param {'APPLICATION' | 'ACCOUNT'} [anchorType] Filters the webhooks in the response by an anchor type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksList(
      anchorType?: 'APPLICATION' | 'ACCOUNT',
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksList(
        anchorType,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Subscribes your webhook listener to events.
     * @summary Create webhook
     * @param {Webhook} [webhook]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksPost(
      webhook?: Webhook,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksPost(
        webhook,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Updates a webhook to replace webhook fields with new values. Supports only the `replace` operation. Pass a `json_patch` object with `replace` operation and `path`, which is `/url` for a URL or `/event_types` for events. The `value` is either the URL or a list of events.
     * @summary Update webhook
     * @param {string} webhookId The ID of the webhook for which to list subscriptions.
     * @param {Array<Patch>} [patch]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksUpdate(
      webhookId: string,
      patch?: Array<Patch>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksUpdate(
        webhookId,
        patch,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WebhooksApiFp(configuration);
  return {
    /**
     * Lists event subscriptions for a webhook, by ID.
     * @summary List event subscriptions for webhook
     * @param {string} webhookId The ID of the webhook for which to list subscriptions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventTypesList(
      webhookId: string,
      options?: any
    ): AxiosPromise<EventTypeList> {
      return localVarFp
        .eventTypesList(webhookId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes a webhook, by ID.
     * @summary Delete webhook
     * @param {string} webhookId The ID of the webhook for which to list subscriptions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksDelete(webhookId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .webhooksDelete(webhookId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Shows details for a webhook, by ID.
     * @summary Show webhook details
     * @param {string} webhookId The ID of the webhook for which to list subscriptions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksGet(webhookId: string, options?: any): AxiosPromise<Webhook> {
      return localVarFp
        .webhooksGet(webhookId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists webhooks for an app.
     * @summary List webhooks
     * @param {'APPLICATION' | 'ACCOUNT'} [anchorType] Filters the webhooks in the response by an anchor type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksList(
      anchorType?: 'APPLICATION' | 'ACCOUNT',
      options?: any
    ): AxiosPromise<WebhookList> {
      return localVarFp
        .webhooksList(anchorType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Subscribes your webhook listener to events.
     * @summary Create webhook
     * @param {Webhook} [webhook]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksPost(webhook?: Webhook, options?: any): AxiosPromise<Webhook> {
      return localVarFp
        .webhooksPost(webhook, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates a webhook to replace webhook fields with new values. Supports only the `replace` operation. Pass a `json_patch` object with `replace` operation and `path`, which is `/url` for a URL or `/event_types` for events. The `value` is either the URL or a list of events.
     * @summary Update webhook
     * @param {string} webhookId The ID of the webhook for which to list subscriptions.
     * @param {Array<Patch>} [patch]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksUpdate(
      webhookId: string,
      patch?: Array<Patch>,
      options?: any
    ): AxiosPromise<Webhook> {
      return localVarFp
        .webhooksUpdate(webhookId, patch, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
  /**
   * Lists event subscriptions for a webhook, by ID.
   * @summary List event subscriptions for webhook
   * @param {string} webhookId The ID of the webhook for which to list subscriptions.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public eventTypesList(webhookId: string, options?: AxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .eventTypesList(webhookId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a webhook, by ID.
   * @summary Delete webhook
   * @param {string} webhookId The ID of the webhook for which to list subscriptions.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public webhooksDelete(webhookId: string, options?: AxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .webhooksDelete(webhookId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Shows details for a webhook, by ID.
   * @summary Show webhook details
   * @param {string} webhookId The ID of the webhook for which to list subscriptions.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public webhooksGet(webhookId: string, options?: AxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .webhooksGet(webhookId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists webhooks for an app.
   * @summary List webhooks
   * @param {'APPLICATION' | 'ACCOUNT'} [anchorType] Filters the webhooks in the response by an anchor type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public webhooksList(
    anchorType?: 'APPLICATION' | 'ACCOUNT',
    options?: AxiosRequestConfig
  ) {
    return WebhooksApiFp(this.configuration)
      .webhooksList(anchorType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Subscribes your webhook listener to events.
   * @summary Create webhook
   * @param {Webhook} [webhook]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public webhooksPost(webhook?: Webhook, options?: AxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .webhooksPost(webhook, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates a webhook to replace webhook fields with new values. Supports only the `replace` operation. Pass a `json_patch` object with `replace` operation and `path`, which is `/url` for a URL or `/event_types` for events. The `value` is either the URL or a list of events.
   * @summary Update webhook
   * @param {string} webhookId The ID of the webhook for which to list subscriptions.
   * @param {Array<Patch>} [patch]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public webhooksUpdate(
    webhookId: string,
    patch?: Array<Patch>,
    options?: AxiosRequestConfig
  ) {
    return WebhooksApiFp(this.configuration)
      .webhooksUpdate(webhookId, patch, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WebhooksEventTypesApi - axios parameter creator
 * @export
 */
export const WebhooksEventTypesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Lists available events to which any webhook can subscribe. For a list of supported events, see [Webhook event names](/docs/api/notifications/webhooks/event-names/).
     * @summary List available events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksEventTypesList: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/notifications/webhooks-event-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WebhooksEventTypesApi - functional programming interface
 * @export
 */
export const WebhooksEventTypesApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    WebhooksEventTypesApiAxiosParamCreator(configuration);
  return {
    /**
     * Lists available events to which any webhook can subscribe. For a list of supported events, see [Webhook event names](/docs/api/notifications/webhooks/event-names/).
     * @summary List available events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksEventTypesList(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventTypeList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.webhooksEventTypesList(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * WebhooksEventTypesApi - factory interface
 * @export
 */
export const WebhooksEventTypesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WebhooksEventTypesApiFp(configuration);
  return {
    /**
     * Lists available events to which any webhook can subscribe. For a list of supported events, see [Webhook event names](/docs/api/notifications/webhooks/event-names/).
     * @summary List available events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksEventTypesList(options?: any): AxiosPromise<EventTypeList> {
      return localVarFp
        .webhooksEventTypesList(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WebhooksEventTypesApi - object-oriented interface
 * @export
 * @class WebhooksEventTypesApi
 * @extends {BaseAPI}
 */
export class WebhooksEventTypesApi extends BaseAPI {
  /**
   * Lists available events to which any webhook can subscribe. For a list of supported events, see [Webhook event names](/docs/api/notifications/webhooks/event-names/).
   * @summary List available events
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksEventTypesApi
   */
  public webhooksEventTypesList(options?: AxiosRequestConfig) {
    return WebhooksEventTypesApiFp(this.configuration)
      .webhooksEventTypesList(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WebhooksEventsApi - axios parameter creator
 * @export
 */
export const WebhooksEventsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Shows details for a webhooks event notification, by ID.
     * @summary Show event notification details
     * @param {string} eventId The ID of the webhook event notification to resend.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksEventsGet: async (
      eventId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventId' is not null or undefined
      assertParamExists('webhooksEventsGet', 'eventId', eventId);
      const localVarPath =
        `/v1/notifications/webhooks-events/{event_id}`.replace(
          `{${'event_id'}}`,
          encodeURIComponent(String(eventId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists webhooks event notifications. Use query parameters to filter the response.
     * @summary List event notifications
     * @param {number} [pageSize] Limits the number of items in the response to the specified page size.
     * @param {string} [startTime] Filters the errors in the response to those created on or after this date and time and on or before the &#x60;end_time&#x60; value. Both values are in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6) format. Example: &#x60;start_time&#x3D;2013-04-06T11:00:00Z&#x60;.
     * @param {string} [endTime] Filters the errors in the response to those created on or after the &#x60;start_time&#x60; and on or before this date and time. Both values are in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Example: &#x60;end_time&#x3D;2013-04-06T11:00:00Z&#x60;.
     * @param {string} [transactionId] Filters the response to a single transaction, by ID.
     * @param {string} [eventType] Filters the response to a single event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksEventsList: async (
      pageSize?: number,
      startTime?: string,
      endTime?: string,
      transactionId?: string,
      eventType?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/notifications/webhooks-events`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] = endTime;
      }

      if (transactionId !== undefined) {
        localVarQueryParameter['transaction_id'] = transactionId;
      }

      if (eventType !== undefined) {
        localVarQueryParameter['event_type'] = eventType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Resends a webhook event notification, by ID. Any pending notifications are not resent.
     * @summary Resend event notification
     * @param {string} eventId The ID of the webhook event notification to resend.
     * @param {EventResend} [eventResend]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksEventsResend: async (
      eventId: string,
      eventResend?: EventResend,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventId' is not null or undefined
      assertParamExists('webhooksEventsResend', 'eventId', eventId);
      const localVarPath =
        `/v1/notifications/webhooks-events/{event_id}/resend`.replace(
          `{${'event_id'}}`,
          encodeURIComponent(String(eventId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        eventResend,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WebhooksEventsApi - functional programming interface
 * @export
 */
export const WebhooksEventsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    WebhooksEventsApiAxiosParamCreator(configuration);
  return {
    /**
     * Shows details for a webhooks event notification, by ID.
     * @summary Show event notification details
     * @param {string} eventId The ID of the webhook event notification to resend.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksEventsGet(
      eventId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.webhooksEventsGet(eventId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists webhooks event notifications. Use query parameters to filter the response.
     * @summary List event notifications
     * @param {number} [pageSize] Limits the number of items in the response to the specified page size.
     * @param {string} [startTime] Filters the errors in the response to those created on or after this date and time and on or before the &#x60;end_time&#x60; value. Both values are in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6) format. Example: &#x60;start_time&#x3D;2013-04-06T11:00:00Z&#x60;.
     * @param {string} [endTime] Filters the errors in the response to those created on or after the &#x60;start_time&#x60; and on or before this date and time. Both values are in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Example: &#x60;end_time&#x3D;2013-04-06T11:00:00Z&#x60;.
     * @param {string} [transactionId] Filters the response to a single transaction, by ID.
     * @param {string} [eventType] Filters the response to a single event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksEventsList(
      pageSize?: number,
      startTime?: string,
      endTime?: string,
      transactionId?: string,
      eventType?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.webhooksEventsList(
          pageSize,
          startTime,
          endTime,
          transactionId,
          eventType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Resends a webhook event notification, by ID. Any pending notifications are not resent.
     * @summary Resend event notification
     * @param {string} eventId The ID of the webhook event notification to resend.
     * @param {EventResend} [eventResend]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksEventsResend(
      eventId: string,
      eventResend?: EventResend,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.webhooksEventsResend(
          eventId,
          eventResend,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * WebhooksEventsApi - factory interface
 * @export
 */
export const WebhooksEventsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WebhooksEventsApiFp(configuration);
  return {
    /**
     * Shows details for a webhooks event notification, by ID.
     * @summary Show event notification details
     * @param {string} eventId The ID of the webhook event notification to resend.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksEventsGet(eventId: string, options?: any): AxiosPromise<Event> {
      return localVarFp
        .webhooksEventsGet(eventId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists webhooks event notifications. Use query parameters to filter the response.
     * @summary List event notifications
     * @param {number} [pageSize] Limits the number of items in the response to the specified page size.
     * @param {string} [startTime] Filters the errors in the response to those created on or after this date and time and on or before the &#x60;end_time&#x60; value. Both values are in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6) format. Example: &#x60;start_time&#x3D;2013-04-06T11:00:00Z&#x60;.
     * @param {string} [endTime] Filters the errors in the response to those created on or after the &#x60;start_time&#x60; and on or before this date and time. Both values are in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Example: &#x60;end_time&#x3D;2013-04-06T11:00:00Z&#x60;.
     * @param {string} [transactionId] Filters the response to a single transaction, by ID.
     * @param {string} [eventType] Filters the response to a single event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksEventsList(
      pageSize?: number,
      startTime?: string,
      endTime?: string,
      transactionId?: string,
      eventType?: string,
      options?: any
    ): AxiosPromise<EventList> {
      return localVarFp
        .webhooksEventsList(
          pageSize,
          startTime,
          endTime,
          transactionId,
          eventType,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Resends a webhook event notification, by ID. Any pending notifications are not resent.
     * @summary Resend event notification
     * @param {string} eventId The ID of the webhook event notification to resend.
     * @param {EventResend} [eventResend]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksEventsResend(
      eventId: string,
      eventResend?: EventResend,
      options?: any
    ): AxiosPromise<Event> {
      return localVarFp
        .webhooksEventsResend(eventId, eventResend, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WebhooksEventsApi - object-oriented interface
 * @export
 * @class WebhooksEventsApi
 * @extends {BaseAPI}
 */
export class WebhooksEventsApi extends BaseAPI {
  /**
   * Shows details for a webhooks event notification, by ID.
   * @summary Show event notification details
   * @param {string} eventId The ID of the webhook event notification to resend.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksEventsApi
   */
  public webhooksEventsGet(eventId: string, options?: AxiosRequestConfig) {
    return WebhooksEventsApiFp(this.configuration)
      .webhooksEventsGet(eventId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists webhooks event notifications. Use query parameters to filter the response.
   * @summary List event notifications
   * @param {number} [pageSize] Limits the number of items in the response to the specified page size.
   * @param {string} [startTime] Filters the errors in the response to those created on or after this date and time and on or before the &#x60;end_time&#x60; value. Both values are in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6) format. Example: &#x60;start_time&#x3D;2013-04-06T11:00:00Z&#x60;.
   * @param {string} [endTime] Filters the errors in the response to those created on or after the &#x60;start_time&#x60; and on or before this date and time. Both values are in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Example: &#x60;end_time&#x3D;2013-04-06T11:00:00Z&#x60;.
   * @param {string} [transactionId] Filters the response to a single transaction, by ID.
   * @param {string} [eventType] Filters the response to a single event.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksEventsApi
   */
  public webhooksEventsList(
    pageSize?: number,
    startTime?: string,
    endTime?: string,
    transactionId?: string,
    eventType?: string,
    options?: AxiosRequestConfig
  ) {
    return WebhooksEventsApiFp(this.configuration)
      .webhooksEventsList(
        pageSize,
        startTime,
        endTime,
        transactionId,
        eventType,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Resends a webhook event notification, by ID. Any pending notifications are not resent.
   * @summary Resend event notification
   * @param {string} eventId The ID of the webhook event notification to resend.
   * @param {EventResend} [eventResend]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksEventsApi
   */
  public webhooksEventsResend(
    eventId: string,
    eventResend?: EventResend,
    options?: AxiosRequestConfig
  ) {
    return WebhooksEventsApiFp(this.configuration)
      .webhooksEventsResend(eventId, eventResend, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WebhooksLookupApi - axios parameter creator
 * @export
 */
export const WebhooksLookupApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Deletes a webhook lookup, by ID.
     * @summary Delete webhook lookup
     * @param {string} webhookLookupId The ID of the webhook lookup to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksLookupDelete: async (
      webhookLookupId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookLookupId' is not null or undefined
      assertParamExists(
        'webhooksLookupDelete',
        'webhookLookupId',
        webhookLookupId
      );
      const localVarPath =
        `/v1/notifications/webhooks-lookup/{webhook_lookup_id}`.replace(
          `{${'webhook_lookup_id'}}`,
          encodeURIComponent(String(webhookLookupId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Shows details for a webhook lookup, by ID.
     * @summary Show webhook lookup details
     * @param {string} webhookLookupId The ID of the webhook lookup to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksLookupGet: async (
      webhookLookupId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookLookupId' is not null or undefined
      assertParamExists(
        'webhooksLookupGet',
        'webhookLookupId',
        webhookLookupId
      );
      const localVarPath =
        `/v1/notifications/webhooks-lookup/{webhook_lookup_id}`.replace(
          `{${'webhook_lookup_id'}}`,
          encodeURIComponent(String(webhookLookupId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists webhook lookups.
     * @summary List webhook lookups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksLookupList: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/notifications/webhooks-lookup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a webhook lookup.
     * @summary Create webhook lookup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksLookupPost: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/notifications/webhooks-lookup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'Oauth2',
        ['https://uri.paypal.com/services/applications/webhooks'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WebhooksLookupApi - functional programming interface
 * @export
 */
export const WebhooksLookupApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    WebhooksLookupApiAxiosParamCreator(configuration);
  return {
    /**
     * Deletes a webhook lookup, by ID.
     * @summary Delete webhook lookup
     * @param {string} webhookLookupId The ID of the webhook lookup to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksLookupDelete(
      webhookLookupId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.webhooksLookupDelete(
          webhookLookupId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Shows details for a webhook lookup, by ID.
     * @summary Show webhook lookup details
     * @param {string} webhookLookupId The ID of the webhook lookup to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksLookupGet(
      webhookLookupId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksLookup>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.webhooksLookupGet(
          webhookLookupId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists webhook lookups.
     * @summary List webhook lookups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksLookupList(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<WebhookLookupList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.webhooksLookupList(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Creates a webhook lookup.
     * @summary Create webhook lookup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksLookupPost(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksLookup>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.webhooksLookupPost(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * WebhooksLookupApi - factory interface
 * @export
 */
export const WebhooksLookupApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WebhooksLookupApiFp(configuration);
  return {
    /**
     * Deletes a webhook lookup, by ID.
     * @summary Delete webhook lookup
     * @param {string} webhookLookupId The ID of the webhook lookup to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksLookupDelete(
      webhookLookupId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .webhooksLookupDelete(webhookLookupId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Shows details for a webhook lookup, by ID.
     * @summary Show webhook lookup details
     * @param {string} webhookLookupId The ID of the webhook lookup to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksLookupGet(
      webhookLookupId: string,
      options?: any
    ): AxiosPromise<WebhooksLookup> {
      return localVarFp
        .webhooksLookupGet(webhookLookupId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists webhook lookups.
     * @summary List webhook lookups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksLookupList(options?: any): AxiosPromise<WebhookLookupList> {
      return localVarFp
        .webhooksLookupList(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a webhook lookup.
     * @summary Create webhook lookup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksLookupPost(options?: any): AxiosPromise<WebhooksLookup> {
      return localVarFp
        .webhooksLookupPost(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WebhooksLookupApi - object-oriented interface
 * @export
 * @class WebhooksLookupApi
 * @extends {BaseAPI}
 */
export class WebhooksLookupApi extends BaseAPI {
  /**
   * Deletes a webhook lookup, by ID.
   * @summary Delete webhook lookup
   * @param {string} webhookLookupId The ID of the webhook lookup to delete.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksLookupApi
   */
  public webhooksLookupDelete(
    webhookLookupId: string,
    options?: AxiosRequestConfig
  ) {
    return WebhooksLookupApiFp(this.configuration)
      .webhooksLookupDelete(webhookLookupId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Shows details for a webhook lookup, by ID.
   * @summary Show webhook lookup details
   * @param {string} webhookLookupId The ID of the webhook lookup to delete.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksLookupApi
   */
  public webhooksLookupGet(
    webhookLookupId: string,
    options?: AxiosRequestConfig
  ) {
    return WebhooksLookupApiFp(this.configuration)
      .webhooksLookupGet(webhookLookupId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists webhook lookups.
   * @summary List webhook lookups
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksLookupApi
   */
  public webhooksLookupList(options?: AxiosRequestConfig) {
    return WebhooksLookupApiFp(this.configuration)
      .webhooksLookupList(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a webhook lookup.
   * @summary Create webhook lookup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksLookupApi
   */
  public webhooksLookupPost(options?: AxiosRequestConfig) {
    return WebhooksLookupApiFp(this.configuration)
      .webhooksLookupPost(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
